{==============================================================================
  ____                   _    
 / ___| _ __   __ _ _ __| | __
 \___ \| '_ \ / _` | '__| |/ /
  ___) | |_) | (_| | |  |   < 
 |____/| .__/ \__,_|_|  |_|\_\
       |_|  Game Library™

Copyright © 2021 tinyBigGAMES™ LLC
All Rights Reserved.

Website: https://tinybiggames.com
Email  : support@tinybiggames.com

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software in
   a product, an acknowledgment in the product documentation would be
   appreciated but is not required.

2. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

3. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

4. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

5. All video, audio, graphics and other content accessed through the
   software in this distro is the property of the applicable content owner
   and may be protected by applicable copyright law. This License gives
   Customer no rights to such content, and Company disclaims any liability
   for misuse of content.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
============================================================================= }

{$IFNDEF WIN64}
  {$MESSAGE Error 'Unsupported platform'}
{$ENDIF}

{$WARN SYMBOL_DEPRECATED OFF}
{$WARN SYMBOL_PLATFORM OFF}
{$WARN UNIT_PLATFORM OFF}
{$WARN UNIT_DEPRECATED OFF}
{$Z4}
{$A8}
{$INLINE AUTO}

unit Spark;

{$R Spark.res}

interface

uses
  System.Generics.Collections,
  System.SysUtils,
  System.Classes,
  System.Math,
  WinAPI.Windows,
  WinAPI.Messages,
  VCL.Graphics,
  VCL.Forms;
  
{$REGION '=== ALLEGRO ===================================================================='}
const
  ALLEGRO_UNSTABLE = 1;
  ALLEGRO_INTERNAL_UNSTABLE = 1;
  ALLEGRO_PLATFORM_STR = 'MSVC';
  ALLEGRO_EXTRA_HEADER = 'allegro5/platform/alwin.h';
  ALLEGRO_INTERNAL_HEADER = 'allegro5/platform/aintwin.h';
  ALLEGRO_INTERNAL_THREAD_HEADER = 'allegro5/platform/aintwthr.h';
  INT32_MIN = (-2147483647-1);
  _ALLEGRO_UNSTABLE_BIT_SET = INT32_MIN;
  ALLEGRO_VERSION = 5;
  ALLEGRO_SUB_VERSION = 2;
  ALLEGRO_WIP_VERSION = 8;
  ALLEGRO_UNSTABLE_BIT = _ALLEGRO_UNSTABLE_BIT_SET;
  ALLEGRO_RELEASE_NUMBER = 0;
  ALLEGRO_VERSION_STR = '5.2.8 (GIT)';
  ALLEGRO_DATE_STR = '2021';
  ALLEGRO_DATE = 20210307;
  ALLEGRO_VERSION_INT = ((ALLEGRO_VERSION shl 24) or (ALLEGRO_SUB_VERSION shl 16) or (ALLEGRO_WIP_VERSION shl 8) or ALLEGRO_RELEASE_NUMBER or ALLEGRO_UNSTABLE_BIT);
  ALLEGRO_PI = 3.14159265358979323846;
  ALLEGRO_NATIVE_PATH_SEP = '\';
  ALLEGRO_NATIVE_DRIVE_SEP = ':';
  ALLEGRO_NEW_WINDOW_TITLE_MAX_SIZE = 255;
  EOF = (-1);
  _AL_MAX_JOYSTICK_AXES = 3;
  _AL_MAX_JOYSTICK_STICKS = 16;
  _AL_MAX_JOYSTICK_BUTTONS = 32;
  ALLEGRO_MOUSE_MAX_EXTRA_AXES = 4;
  ALLEGRO_TOUCH_INPUT_MAX_TOUCH_COUNT = 16;
  ALLEGRO_SHADER_VAR_COLOR = 'al_color';
  ALLEGRO_SHADER_VAR_POS = 'al_pos';
  ALLEGRO_SHADER_VAR_PROJVIEW_MATRIX = 'al_projview_matrix';
  ALLEGRO_SHADER_VAR_TEX = 'al_tex';
  ALLEGRO_SHADER_VAR_TEXCOORD = 'al_texcoord';
  ALLEGRO_SHADER_VAR_TEX_MATRIX = 'al_tex_matrix';
  ALLEGRO_SHADER_VAR_USER_ATTR = 'al_user_attr_';
  ALLEGRO_SHADER_VAR_USE_TEX = 'al_use_tex';
  ALLEGRO_SHADER_VAR_USE_TEX_MATRIX = 'al_use_tex_matrix';
  ALLEGRO_SHADER_VAR_ALPHA_TEST = 'al_alpha_test';
  ALLEGRO_SHADER_VAR_ALPHA_FUNCTION = 'al_alpha_func';
  ALLEGRO_SHADER_VAR_ALPHA_TEST_VALUE = 'al_alpha_test_val';
  ALLEGRO_MAX_CHANNELS = 8;
  ALLEGRO_AUDIO_PAN_NONE = (-1000.0);
  ALLEGRO_VERTEX_CACHE_SIZE = 256;
  ALLEGRO_PRIM_QUALITY = 10;
  ALLEGRO_TTF_NO_KERNING = 1;
  ALLEGRO_TTF_MONOCHROME = 2;
  ALLEGRO_TTF_NO_AUTOHINT = 4;
  
  ALLEGRO_PIXEL_FORMAT_ANY = 0;
  ALLEGRO_PIXEL_FORMAT_ANY_NO_ALPHA = 1;
  ALLEGRO_PIXEL_FORMAT_ANY_WITH_ALPHA = 2;
  ALLEGRO_PIXEL_FORMAT_ANY_15_NO_ALPHA = 3;
  ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA = 4;
  ALLEGRO_PIXEL_FORMAT_ANY_16_WITH_ALPHA = 5;
  ALLEGRO_PIXEL_FORMAT_ANY_24_NO_ALPHA = 6;
  ALLEGRO_PIXEL_FORMAT_ANY_32_NO_ALPHA = 7;
  ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA = 8;
  ALLEGRO_PIXEL_FORMAT_ARGB_8888 = 9;
  ALLEGRO_PIXEL_FORMAT_RGBA_8888 = 10;
  ALLEGRO_PIXEL_FORMAT_ARGB_4444 = 11;
  ALLEGRO_PIXEL_FORMAT_RGB_888 = 12;
  ALLEGRO_PIXEL_FORMAT_RGB_565 = 13;
  ALLEGRO_PIXEL_FORMAT_RGB_555 = 14;
  ALLEGRO_PIXEL_FORMAT_RGBA_5551 = 15;
  ALLEGRO_PIXEL_FORMAT_ARGB_1555 = 16;
  ALLEGRO_PIXEL_FORMAT_ABGR_8888 = 17;
  ALLEGRO_PIXEL_FORMAT_XBGR_8888 = 18;
  ALLEGRO_PIXEL_FORMAT_BGR_888 = 19;
  ALLEGRO_PIXEL_FORMAT_BGR_565 = 20;
  ALLEGRO_PIXEL_FORMAT_BGR_555 = 21;
  ALLEGRO_PIXEL_FORMAT_RGBX_8888 = 22;
  ALLEGRO_PIXEL_FORMAT_XRGB_8888 = 23;
  ALLEGRO_PIXEL_FORMAT_ABGR_F32 = 24;
  ALLEGRO_PIXEL_FORMAT_ABGR_8888_LE = 25;
  ALLEGRO_PIXEL_FORMAT_RGBA_4444 = 26;
  ALLEGRO_PIXEL_FORMAT_SINGLE_CHANNEL_8 = 27;
  ALLEGRO_PIXEL_FORMAT_COMPRESSED_RGBA_DXT1 = 28;
  ALLEGRO_PIXEL_FORMAT_COMPRESSED_RGBA_DXT3 = 29;
  ALLEGRO_PIXEL_FORMAT_COMPRESSED_RGBA_DXT5 = 30;
  ALLEGRO_NUM_PIXEL_FORMATS = 31;  
  
  ALLEGRO_MEMORY_BITMAP = 1;
  _ALLEGRO_KEEP_BITMAP_FORMAT = 2;
  ALLEGRO_FORCE_LOCKING = 4;
  ALLEGRO_NO_PRESERVE_TEXTURE = 8;
  _ALLEGRO_ALPHA_TEST = 16;
  _ALLEGRO_INTERNAL_OPENGL = 32;
  ALLEGRO_MIN_LINEAR = 64;
  ALLEGRO_MAG_LINEAR = 128;
  ALLEGRO_MIPMAP = 256;
  _ALLEGRO_NO_PREMULTIPLIED_ALPHA = 512;
  ALLEGRO_VIDEO_BITMAP = 1024;
  ALLEGRO_CONVERT_BITMAP = 4096;

  ALLEGRO_FLIP_HORIZONTAL = 1;
  ALLEGRO_FLIP_VERTICAL = 2;
  
  ALLEGRO_SEEK_SET = 0;
  ALLEGRO_SEEK_CUR = 1;
  ALLEGRO_SEEK_END = 2;

  ALLEGRO_KEEP_BITMAP_FORMAT = 2;
  ALLEGRO_NO_PREMULTIPLIED_ALPHA = 512;
  ALLEGRO_KEEP_INDEX = 2048;  
  
  ALLEGRO_LOCK_READWRITE = 0;
  ALLEGRO_LOCK_READONLY = 1;
  ALLEGRO_LOCK_WRITEONLY = 2;  
  
  ALLEGRO_ZERO = 0;
  ALLEGRO_ONE = 1;
  ALLEGRO_ALPHA = 2;
  ALLEGRO_INVERSE_ALPHA = 3;
  ALLEGRO_SRC_COLOR = 4;
  ALLEGRO_DEST_COLOR = 5;
  ALLEGRO_INVERSE_SRC_COLOR = 6;
  ALLEGRO_INVERSE_DEST_COLOR = 7;
  ALLEGRO_CONST_COLOR = 8;
  ALLEGRO_INVERSE_CONST_COLOR = 9;
  ALLEGRO_NUM_BLEND_MODES = 10;

  ALLEGRO_DST_COLOR = (ALLEGRO_DEST_COLOR);
  ALLEGRO_INVERSE_DST_COLOR = (ALLEGRO_INVERSE_DEST_COLOR);  

  ALLEGRO_ADD = 0;
  ALLEGRO_SRC_MINUS_DEST = 1;
  ALLEGRO_DEST_MINUS_SRC = 2;
  ALLEGRO_NUM_BLEND_OPERATIONS = 3;

  ALLEGRO_EVENT_JOYSTICK_AXIS = 1;
  ALLEGRO_EVENT_JOYSTICK_BUTTON_DOWN = 2;
  ALLEGRO_EVENT_JOYSTICK_BUTTON_UP = 3;
  ALLEGRO_EVENT_JOYSTICK_CONFIGURATION = 4;
  ALLEGRO_EVENT_KEY_DOWN = 10;
  ALLEGRO_EVENT_KEY_CHAR = 11;
  ALLEGRO_EVENT_KEY_UP = 12;
  ALLEGRO_EVENT_MOUSE_AXES = 20;
  ALLEGRO_EVENT_MOUSE_BUTTON_DOWN = 21;
  ALLEGRO_EVENT_MOUSE_BUTTON_UP = 22;
  ALLEGRO_EVENT_MOUSE_ENTER_DISPLAY = 23;
  ALLEGRO_EVENT_MOUSE_LEAVE_DISPLAY = 24;
  ALLEGRO_EVENT_MOUSE_WARPED = 25;
  ALLEGRO_EVENT_TIMER = 30;
  ALLEGRO_EVENT_DISPLAY_EXPOSE = 40;
  ALLEGRO_EVENT_DISPLAY_RESIZE = 41;
  ALLEGRO_EVENT_DISPLAY_CLOSE = 42;
  ALLEGRO_EVENT_DISPLAY_LOST = 43;
  ALLEGRO_EVENT_DISPLAY_FOUND = 44;
  ALLEGRO_EVENT_DISPLAY_SWITCH_IN = 45;
  ALLEGRO_EVENT_DISPLAY_SWITCH_OUT = 46;
  ALLEGRO_EVENT_DISPLAY_ORIENTATION = 47;
  ALLEGRO_EVENT_DISPLAY_HALT_DRAWING = 48;
  ALLEGRO_EVENT_DISPLAY_RESUME_DRAWING = 49;
  ALLEGRO_EVENT_TOUCH_BEGIN = 50;
  ALLEGRO_EVENT_TOUCH_END = 51;
  ALLEGRO_EVENT_TOUCH_MOVE = 52;
  ALLEGRO_EVENT_TOUCH_CANCEL = 53;
  ALLEGRO_EVENT_DISPLAY_CONNECTED = 60;
  ALLEGRO_EVENT_DISPLAY_DISCONNECTED = 61;
  
  ALLEGRO_WINDOWED = 1;
  ALLEGRO_FULLSCREEN = 2;
  ALLEGRO_OPENGL = 4;
  ALLEGRO_DIRECT3D_INTERNAL = 8;
  ALLEGRO_RESIZABLE = 16;
  ALLEGRO_FRAMELESS = 32;
  ALLEGRO_NOFRAME = 32;
  ALLEGRO_GENERATE_EXPOSE_EVENTS = 64;
  ALLEGRO_OPENGL_3_0 = 128;
  ALLEGRO_OPENGL_FORWARD_COMPATIBLE = 256;
  ALLEGRO_FULLSCREEN_WINDOW = 512;
  ALLEGRO_MINIMIZED = 1024;
  ALLEGRO_PROGRAMMABLE_PIPELINE = 2048;
  ALLEGRO_GTK_TOPLEVEL_INTERNAL = 4096;
  ALLEGRO_MAXIMIZED = 8192;
  ALLEGRO_OPENGL_ES_PROFILE = 16384;
  ALLEGRO_OPENGL_CORE_PROFILE = 32768;  
  
  ALLEGRO_RED_SIZE = 0;
  ALLEGRO_GREEN_SIZE = 1;
  ALLEGRO_BLUE_SIZE = 2;
  ALLEGRO_ALPHA_SIZE = 3;
  ALLEGRO_RED_SHIFT = 4;
  ALLEGRO_GREEN_SHIFT = 5;
  ALLEGRO_BLUE_SHIFT = 6;
  ALLEGRO_ALPHA_SHIFT = 7;
  ALLEGRO_ACC_RED_SIZE = 8;
  ALLEGRO_ACC_GREEN_SIZE = 9;
  ALLEGRO_ACC_BLUE_SIZE = 10;
  ALLEGRO_ACC_ALPHA_SIZE = 11;
  ALLEGRO_STEREO = 12;
  ALLEGRO_AUX_BUFFERS = 13;
  ALLEGRO_COLOR_SIZE = 14;
  ALLEGRO_DEPTH_SIZE = 15;
  ALLEGRO_STENCIL_SIZE = 16;
  ALLEGRO_SAMPLE_BUFFERS = 17;
  ALLEGRO_SAMPLES = 18;
  ALLEGRO_RENDER_METHOD = 19;
  ALLEGRO_FLOAT_COLOR = 20;
  ALLEGRO_FLOAT_DEPTH = 21;
  ALLEGRO_SINGLE_BUFFER = 22;
  ALLEGRO_SWAP_METHOD = 23;
  ALLEGRO_COMPATIBLE_DISPLAY = 24;
  ALLEGRO_UPDATE_DISPLAY_REGION = 25;
  ALLEGRO_VSYNC = 26;
  ALLEGRO_MAX_BITMAP_SIZE = 27;
  ALLEGRO_SUPPORT_NPOT_BITMAP = 28;
  ALLEGRO_CAN_DRAW_INTO_BITMAP = 29;
  ALLEGRO_SUPPORT_SEPARATE_ALPHA = 30;
  ALLEGRO_AUTO_CONVERT_BITMAPS = 31;
  ALLEGRO_SUPPORTED_ORIENTATIONS = 32;
  ALLEGRO_OPENGL_MAJOR_VERSION = 33;
  ALLEGRO_OPENGL_MINOR_VERSION = 34;
  ALLEGRO_DISPLAY_OPTIONS_COUNT = 35;  

  ALLEGRO_DONTCARE = 0;
  ALLEGRO_REQUIRE = 1;
  ALLEGRO_SUGGEST = 2;

  ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN = 0;
  ALLEGRO_DISPLAY_ORIENTATION_0_DEGREES = 1;
  ALLEGRO_DISPLAY_ORIENTATION_90_DEGREES = 2;
  ALLEGRO_DISPLAY_ORIENTATION_180_DEGREES = 4;
  ALLEGRO_DISPLAY_ORIENTATION_270_DEGREES = 8;
  ALLEGRO_DISPLAY_ORIENTATION_PORTRAIT = 5;
  ALLEGRO_DISPLAY_ORIENTATION_LANDSCAPE = 10;
  ALLEGRO_DISPLAY_ORIENTATION_ALL = 15;
  ALLEGRO_DISPLAY_ORIENTATION_FACE_UP = 16;
  ALLEGRO_DISPLAY_ORIENTATION_FACE_DOWN = 32;
  
  _ALLEGRO_PRIM_MAX_USER_ATTR = 10;

  ALLEGRO_FILEMODE_READ = 1;
  ALLEGRO_FILEMODE_WRITE = 2;
  ALLEGRO_FILEMODE_EXECUTE = 4;
  ALLEGRO_FILEMODE_HIDDEN = 8;
  ALLEGRO_FILEMODE_ISFILE = 16;
  ALLEGRO_FILEMODE_ISDIR = 32;  
  
  ALLEGRO_JOYFLAG_DIGITAL = 1;
  ALLEGRO_JOYFLAG_ANALOGUE = 2;  

  ALLEGRO_KEY_A = 1;
  ALLEGRO_KEY_B = 2;
  ALLEGRO_KEY_C = 3;
  ALLEGRO_KEY_D = 4;
  ALLEGRO_KEY_E = 5;
  ALLEGRO_KEY_F = 6;
  ALLEGRO_KEY_G = 7;
  ALLEGRO_KEY_H = 8;
  ALLEGRO_KEY_I = 9;
  ALLEGRO_KEY_J = 10;
  ALLEGRO_KEY_K = 11;
  ALLEGRO_KEY_L = 12;
  ALLEGRO_KEY_M = 13;
  ALLEGRO_KEY_N = 14;
  ALLEGRO_KEY_O = 15;
  ALLEGRO_KEY_P = 16;
  ALLEGRO_KEY_Q = 17;
  ALLEGRO_KEY_R = 18;
  ALLEGRO_KEY_S = 19;
  ALLEGRO_KEY_T = 20;
  ALLEGRO_KEY_U = 21;
  ALLEGRO_KEY_V = 22;
  ALLEGRO_KEY_W = 23;
  ALLEGRO_KEY_X = 24;
  ALLEGRO_KEY_Y = 25;
  ALLEGRO_KEY_Z = 26;
  ALLEGRO_KEY_0 = 27;
  ALLEGRO_KEY_1 = 28;
  ALLEGRO_KEY_2 = 29;
  ALLEGRO_KEY_3 = 30;
  ALLEGRO_KEY_4 = 31;
  ALLEGRO_KEY_5 = 32;
  ALLEGRO_KEY_6 = 33;
  ALLEGRO_KEY_7 = 34;
  ALLEGRO_KEY_8 = 35;
  ALLEGRO_KEY_9 = 36;
  ALLEGRO_KEY_PAD_0 = 37;
  ALLEGRO_KEY_PAD_1 = 38;
  ALLEGRO_KEY_PAD_2 = 39;
  ALLEGRO_KEY_PAD_3 = 40;
  ALLEGRO_KEY_PAD_4 = 41;
  ALLEGRO_KEY_PAD_5 = 42;
  ALLEGRO_KEY_PAD_6 = 43;
  ALLEGRO_KEY_PAD_7 = 44;
  ALLEGRO_KEY_PAD_8 = 45;
  ALLEGRO_KEY_PAD_9 = 46;
  ALLEGRO_KEY_F1 = 47;
  ALLEGRO_KEY_F2 = 48;
  ALLEGRO_KEY_F3 = 49;
  ALLEGRO_KEY_F4 = 50;
  ALLEGRO_KEY_F5 = 51;
  ALLEGRO_KEY_F6 = 52;
  ALLEGRO_KEY_F7 = 53;
  ALLEGRO_KEY_F8 = 54;
  ALLEGRO_KEY_F9 = 55;
  ALLEGRO_KEY_F10 = 56;
  ALLEGRO_KEY_F11 = 57;
  ALLEGRO_KEY_F12 = 58;
  ALLEGRO_KEY_ESCAPE = 59;
  ALLEGRO_KEY_TILDE = 60;
  ALLEGRO_KEY_MINUS = 61;
  ALLEGRO_KEY_EQUALS = 62;
  ALLEGRO_KEY_BACKSPACE = 63;
  ALLEGRO_KEY_TAB = 64;
  ALLEGRO_KEY_OPENBRACE = 65;
  ALLEGRO_KEY_CLOSEBRACE = 66;
  ALLEGRO_KEY_ENTER = 67;
  ALLEGRO_KEY_SEMICOLON = 68;
  ALLEGRO_KEY_QUOTE = 69;
  ALLEGRO_KEY_BACKSLASH = 70;
  ALLEGRO_KEY_BACKSLASH2 = 71;
  ALLEGRO_KEY_COMMA = 72;
  ALLEGRO_KEY_FULLSTOP = 73;
  ALLEGRO_KEY_SLASH = 74;
  ALLEGRO_KEY_SPACE = 75;
  ALLEGRO_KEY_INSERT = 76;
  ALLEGRO_KEY_DELETE = 77;
  ALLEGRO_KEY_HOME = 78;
  ALLEGRO_KEY_END = 79;
  ALLEGRO_KEY_PGUP = 80;
  ALLEGRO_KEY_PGDN = 81;
  ALLEGRO_KEY_LEFT = 82;
  ALLEGRO_KEY_RIGHT = 83;
  ALLEGRO_KEY_UP = 84;
  ALLEGRO_KEY_DOWN = 85;
  ALLEGRO_KEY_PAD_SLASH = 86;
  ALLEGRO_KEY_PAD_ASTERISK = 87;
  ALLEGRO_KEY_PAD_MINUS = 88;
  ALLEGRO_KEY_PAD_PLUS = 89;
  ALLEGRO_KEY_PAD_DELETE = 90;
  ALLEGRO_KEY_PAD_ENTER = 91;
  ALLEGRO_KEY_PRINTSCREEN = 92;
  ALLEGRO_KEY_PAUSE = 93;
  ALLEGRO_KEY_ABNT_C1 = 94;
  ALLEGRO_KEY_YEN = 95;
  ALLEGRO_KEY_KANA = 96;
  ALLEGRO_KEY_CONVERT = 97;
  ALLEGRO_KEY_NOCONVERT = 98;
  ALLEGRO_KEY_AT = 99;
  ALLEGRO_KEY_CIRCUMFLEX = 100;
  ALLEGRO_KEY_COLON2 = 101;
  ALLEGRO_KEY_KANJI = 102;
  ALLEGRO_KEY_PAD_EQUALS = 103;
  ALLEGRO_KEY_BACKQUOTE = 104;
  ALLEGRO_KEY_SEMICOLON2 = 105;
  ALLEGRO_KEY_COMMAND = 106;
  ALLEGRO_KEY_BACK = 107;
  ALLEGRO_KEY_VOLUME_UP = 108;
  ALLEGRO_KEY_VOLUME_DOWN = 109;
  ALLEGRO_KEY_SEARCH = 110;
  ALLEGRO_KEY_DPAD_CENTER = 111;
  ALLEGRO_KEY_BUTTON_X = 112;
  ALLEGRO_KEY_BUTTON_Y = 113;
  ALLEGRO_KEY_DPAD_UP = 114;
  ALLEGRO_KEY_DPAD_DOWN = 115;
  ALLEGRO_KEY_DPAD_LEFT = 116;
  ALLEGRO_KEY_DPAD_RIGHT = 117;
  ALLEGRO_KEY_SELECT = 118;
  ALLEGRO_KEY_START = 119;
  ALLEGRO_KEY_BUTTON_L1 = 120;
  ALLEGRO_KEY_BUTTON_R1 = 121;
  ALLEGRO_KEY_BUTTON_L2 = 122;
  ALLEGRO_KEY_BUTTON_R2 = 123;
  ALLEGRO_KEY_BUTTON_A = 124;
  ALLEGRO_KEY_BUTTON_B = 125;
  ALLEGRO_KEY_THUMBL = 126;
  ALLEGRO_KEY_THUMBR = 127;
  ALLEGRO_KEY_UNKNOWN = 128;
  ALLEGRO_KEY_MODIFIERS = 215;
  ALLEGRO_KEY_LSHIFT = 215;
  ALLEGRO_KEY_RSHIFT = 216;
  ALLEGRO_KEY_LCTRL = 217;
  ALLEGRO_KEY_RCTRL = 218;
  ALLEGRO_KEY_ALT = 219;
  ALLEGRO_KEY_ALTGR = 220;
  ALLEGRO_KEY_LWIN = 221;
  ALLEGRO_KEY_RWIN = 222;
  ALLEGRO_KEY_MENU = 223;
  ALLEGRO_KEY_SCROLLLOCK = 224;
  ALLEGRO_KEY_NUMLOCK = 225;
  ALLEGRO_KEY_CAPSLOCK = 226;
  ALLEGRO_KEY_MAX = 227;
  
  ALLEGRO_KEYMOD_SHIFT = 1;
  ALLEGRO_KEYMOD_CTRL = 2;
  ALLEGRO_KEYMOD_ALT = 4;
  ALLEGRO_KEYMOD_LWIN = 8;
  ALLEGRO_KEYMOD_RWIN = 16;
  ALLEGRO_KEYMOD_MENU = 32;
  ALLEGRO_KEYMOD_ALTGR = 64;
  ALLEGRO_KEYMOD_COMMAND = 128;
  ALLEGRO_KEYMOD_SCROLLLOCK = 256;
  ALLEGRO_KEYMOD_NUMLOCK = 512;
  ALLEGRO_KEYMOD_CAPSLOCK = 1024;
  ALLEGRO_KEYMOD_INALTSEQ = 2048;
  ALLEGRO_KEYMOD_ACCENT1 = 4096;
  ALLEGRO_KEYMOD_ACCENT2 = 8192;
  ALLEGRO_KEYMOD_ACCENT3 = 16384;
  ALLEGRO_KEYMOD_ACCENT4 = 32768;

  ALLEGRO_MOUSE_EMULATION_NONE = 0;
  ALLEGRO_MOUSE_EMULATION_TRANSPARENT = 1;
  ALLEGRO_MOUSE_EMULATION_INCLUSIVE = 2;
  ALLEGRO_MOUSE_EMULATION_EXCLUSIVE = 3;
  ALLEGRO_MOUSE_EMULATION_5_0_x = 4;

  ALLEGRO_HAPTIC_RUMBLE = 1;
  ALLEGRO_HAPTIC_PERIODIC = 2;
  ALLEGRO_HAPTIC_CONSTANT = 4;
  ALLEGRO_HAPTIC_SPRING = 8;
  ALLEGRO_HAPTIC_FRICTION = 16;
  ALLEGRO_HAPTIC_DAMPER = 32;
  ALLEGRO_HAPTIC_INERTIA = 64;
  ALLEGRO_HAPTIC_RAMP = 128;
  ALLEGRO_HAPTIC_SQUARE = 256;
  ALLEGRO_HAPTIC_TRIANGLE = 512;
  ALLEGRO_HAPTIC_SINE = 1024;
  ALLEGRO_HAPTIC_SAW_UP = 2048;
  ALLEGRO_HAPTIC_SAW_DOWN = 4096;
  ALLEGRO_HAPTIC_CUSTOM = 8192;
  ALLEGRO_HAPTIC_GAIN = 16384;
  ALLEGRO_HAPTIC_ANGLE = 32768;
  ALLEGRO_HAPTIC_RADIUS = 65536;
  ALLEGRO_HAPTIC_AZIMUTH = 131072;
  ALLEGRO_HAPTIC_AUTOCENTER = 262144;

  ALLEGRO_DEFAULT_DISPLAY_ADAPTER = -1;  
  
  ALLEGRO_SYSTEM_MOUSE_CURSOR_NONE = 0;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_DEFAULT = 1;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_ARROW = 2;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_BUSY = 3;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_QUESTION = 4;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_EDIT = 5;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_MOVE = 6;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_N = 7;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_W = 8;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_S = 9;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_E = 10;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_NW = 11;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_SW = 12;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_SE = 13;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_NE = 14;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_PROGRESS = 15;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_PRECISION = 16;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_LINK = 17;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_ALT_SELECT = 18;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_UNAVAILABLE = 19;
  ALLEGRO_NUM_SYSTEM_MOUSE_CURSORS = 20;

  ALLEGRO_ALPHA_TEST = 16;
  ALLEGRO_WRITE_MASK = 17;
  ALLEGRO_DEPTH_TEST = 18;
  ALLEGRO_DEPTH_FUNCTION = 19;
  ALLEGRO_ALPHA_FUNCTION = 20;
  ALLEGRO_ALPHA_TEST_VALUE = 21; 

  ALLEGRO_RENDER_NEVER = 0;
  ALLEGRO_RENDER_ALWAYS = 1;
  ALLEGRO_RENDER_LESS = 2;
  ALLEGRO_RENDER_EQUAL = 3;
  ALLEGRO_RENDER_LESS_EQUAL = 4;
  ALLEGRO_RENDER_GREATER = 5;
  ALLEGRO_RENDER_NOT_EQUAL = 6;
  ALLEGRO_RENDER_GREATER_EQUAL = 7;

  ALLEGRO_MASK_RED = 1;
  ALLEGRO_MASK_GREEN = 2;
  ALLEGRO_MASK_BLUE = 4;
  ALLEGRO_MASK_ALPHA = 8;
  ALLEGRO_MASK_DEPTH = 16;
  ALLEGRO_MASK_RGB = 7;
  ALLEGRO_MASK_RGBA = 15; 

  ALLEGRO_VERTEX_SHADER = 1;
  ALLEGRO_PIXEL_SHADER = 2;

  ALLEGRO_SHADER_AUTO = 0;
  ALLEGRO_SHADER_GLSL = 1;
  ALLEGRO_SHADER_HLSL = 2;

  ALLEGRO_SYSTEM_ID_UNKNOWN = 0;
  ALLEGRO_SYSTEM_ID_XGLX = 1481067608;
  ALLEGRO_SYSTEM_ID_WINDOWS = 1464421956;
  ALLEGRO_SYSTEM_ID_MACOSX = 1330862112;
  ALLEGRO_SYSTEM_ID_ANDROID = 1095648338;
  ALLEGRO_SYSTEM_ID_IPHONE = 1229998159;
  ALLEGRO_SYSTEM_ID_GP2XWIZ = 1464424992;
  ALLEGRO_SYSTEM_ID_RASPBERRYPI = 1380012880;
  ALLEGRO_SYSTEM_ID_SDL = 1396984882;

  ALLEGRO_RESOURCES_PATH = 0;
  ALLEGRO_TEMP_PATH = 1;
  ALLEGRO_USER_DATA_PATH = 2;
  ALLEGRO_USER_HOME_PATH = 3;
  ALLEGRO_USER_SETTINGS_PATH = 4;
  ALLEGRO_USER_DOCUMENTS_PATH = 5;
  ALLEGRO_EXENAME_PATH = 6;
  ALLEGRO_LAST_PATH = 7; 

  ALLEGRO_STATE_NEW_DISPLAY_PARAMETERS = 1;
  ALLEGRO_STATE_NEW_BITMAP_PARAMETERS = 2;
  ALLEGRO_STATE_DISPLAY = 4;
  ALLEGRO_STATE_TARGET_BITMAP = 8;
  ALLEGRO_STATE_BLENDER = 16;
  ALLEGRO_STATE_NEW_FILE_INTERFACE = 32;
  ALLEGRO_STATE_TRANSFORM = 64;
  ALLEGRO_STATE_PROJECTION_TRANSFORM = 256;
  ALLEGRO_STATE_BITMAP = 10;
  ALLEGRO_STATE_ALL = 65535;

  _KCM_STREAM_FEEDER_QUIT_EVENT_TYPE = 512;
  ALLEGRO_EVENT_AUDIO_STREAM_FRAGMENT = 513;
  ALLEGRO_EVENT_AUDIO_STREAM_FINISHED = 514;
  ALLEGRO_EVENT_AUDIO_RECORDER_FRAGMENT = 515;

  ALLEGRO_AUDIO_DEPTH_INT8 = 0;
  ALLEGRO_AUDIO_DEPTH_INT16 = 1;
  ALLEGRO_AUDIO_DEPTH_INT24 = 2;
  ALLEGRO_AUDIO_DEPTH_FLOAT32 = 3;
  ALLEGRO_AUDIO_DEPTH_UNSIGNED = 8;
  ALLEGRO_AUDIO_DEPTH_UINT8 = 8;
  ALLEGRO_AUDIO_DEPTH_UINT16 = 9;
  ALLEGRO_AUDIO_DEPTH_UINT24 = 10;

  ALLEGRO_CHANNEL_CONF_1 = 16;
  ALLEGRO_CHANNEL_CONF_2 = 32;
  ALLEGRO_CHANNEL_CONF_3 = 48;
  ALLEGRO_CHANNEL_CONF_4 = 64;
  ALLEGRO_CHANNEL_CONF_5_1 = 81;
  ALLEGRO_CHANNEL_CONF_6_1 = 97;
  ALLEGRO_CHANNEL_CONF_7_1 = 113;

  ALLEGRO_PLAYMODE_ONCE = 256;
  ALLEGRO_PLAYMODE_LOOP = 257;
  ALLEGRO_PLAYMODE_BIDIR = 258;
  _ALLEGRO_PLAYMODE_STREAM_ONCE = 259;
  _ALLEGRO_PLAYMODE_STREAM_ONEDIR = 260;

  ALLEGRO_MIXER_QUALITY_POINT = 272;
  ALLEGRO_MIXER_QUALITY_LINEAR = 273;
  ALLEGRO_MIXER_QUALITY_CUBIC = 274;

  ALLEGRO_NO_KERNING = -1;
  ALLEGRO_ALIGN_LEFT = 0;
  ALLEGRO_ALIGN_CENTRE = 1;
  ALLEGRO_ALIGN_CENTER = 1;
  ALLEGRO_ALIGN_RIGHT = 2;
  ALLEGRO_ALIGN_INTEGER = 4;

  ALLEGRO_FILECHOOSER_FILE_MUST_EXIST = 1;
  ALLEGRO_FILECHOOSER_SAVE = 2;
  ALLEGRO_FILECHOOSER_FOLDER = 4;
  ALLEGRO_FILECHOOSER_PICTURES = 8;
  ALLEGRO_FILECHOOSER_SHOW_HIDDEN = 16;
  ALLEGRO_FILECHOOSER_MULTIPLE = 32;

  ALLEGRO_MESSAGEBOX_WARN = 1;
  ALLEGRO_MESSAGEBOX_ERROR = 2;
  ALLEGRO_MESSAGEBOX_OK_CANCEL = 4;
  ALLEGRO_MESSAGEBOX_YES_NO = 8;
  ALLEGRO_MESSAGEBOX_QUESTION = 16;

  ALLEGRO_TEXTLOG_NO_CLOSE = 1;
  ALLEGRO_TEXTLOG_MONOSPACE = 2; 

  ALLEGRO_EVENT_NATIVE_DIALOG_CLOSE = 600;
  ALLEGRO_EVENT_MENU_CLICK = 601;

  ALLEGRO_MENU_ITEM_ENABLED = 0;
  ALLEGRO_MENU_ITEM_CHECKBOX = 1;
  ALLEGRO_MENU_ITEM_CHECKED = 2;
  ALLEGRO_MENU_ITEM_DISABLED = 4;

  ALLEGRO_PRIM_LINE_LIST = 0;
  ALLEGRO_PRIM_LINE_STRIP = 1;
  ALLEGRO_PRIM_LINE_LOOP = 2;
  ALLEGRO_PRIM_TRIANGLE_LIST = 3;
  ALLEGRO_PRIM_TRIANGLE_STRIP = 4;
  ALLEGRO_PRIM_TRIANGLE_FAN = 5;
  ALLEGRO_PRIM_POINT_LIST = 6;
  ALLEGRO_PRIM_NUM_TYPES = 7;

  ALLEGRO_PRIM_MAX_USER_ATTR = 10; 

  ALLEGRO_PRIM_POSITION = 1;
  ALLEGRO_PRIM_COLOR_ATTR = 2;
  ALLEGRO_PRIM_TEX_COORD = 3;
  ALLEGRO_PRIM_TEX_COORD_PIXEL = 4;
  ALLEGRO_PRIM_USER_ATTR = 5;
  ALLEGRO_PRIM_ATTR_NUM = 15; 

  ALLEGRO_PRIM_FLOAT_2 = 0;
  ALLEGRO_PRIM_FLOAT_3 = 1;
  ALLEGRO_PRIM_SHORT_2 = 2;
  ALLEGRO_PRIM_FLOAT_1 = 3;
  ALLEGRO_PRIM_FLOAT_4 = 4;
  ALLEGRO_PRIM_UBYTE_4 = 5;
  ALLEGRO_PRIM_SHORT_4 = 6;
  ALLEGRO_PRIM_NORMALIZED_UBYTE_4 = 7;
  ALLEGRO_PRIM_NORMALIZED_SHORT_2 = 8;
  ALLEGRO_PRIM_NORMALIZED_SHORT_4 = 9;
  ALLEGRO_PRIM_NORMALIZED_USHORT_2 = 10;
  ALLEGRO_PRIM_NORMALIZED_USHORT_4 = 11;
  ALLEGRO_PRIM_HALF_FLOAT_2 = 12;
  ALLEGRO_PRIM_HALF_FLOAT_4 = 13;

  ALLEGRO_LINE_JOIN_NONE = 0;
  ALLEGRO_LINE_JOIN_BEVEL = 1;
  ALLEGRO_LINE_JOIN_ROUND = 2;
  ALLEGRO_LINE_JOIN_MITER = 3;
  ALLEGRO_LINE_JOIN_MITRE = 3;

  ALLEGRO_LINE_CAP_NONE = 0;
  ALLEGRO_LINE_CAP_SQUARE = 1;
  ALLEGRO_LINE_CAP_ROUND = 2;
  ALLEGRO_LINE_CAP_TRIANGLE = 3;
  ALLEGRO_LINE_CAP_CLOSED = 4; 

  ALLEGRO_PRIM_BUFFER_STREAM = 1;
  ALLEGRO_PRIM_BUFFER_STATIC = 2;
  ALLEGRO_PRIM_BUFFER_DYNAMIC = 4;
  ALLEGRO_PRIM_BUFFER_READWRITE = 8;

  ALLEGRO_EVENT_VIDEO_FRAME_SHOW = 550;
  ALLEGRO_EVENT_VIDEO_FINISHED = 551;
  _ALLEGRO_EVENT_VIDEO_SEEK = 552;

  ALLEGRO_VIDEO_POSITION_ACTUAL = 0;
  ALLEGRO_VIDEO_POSITION_VIDEO_DECODE = 1;
  ALLEGRO_VIDEO_POSITION_AUDIO_DECODE = 2;

  ALLEGRO_FOR_EACH_FS_ENTRY_ERROR = -1;
  ALLEGRO_FOR_EACH_FS_ENTRY_OK = 0;
  ALLEGRO_FOR_EACH_FS_ENTRY_SKIP = 1;
  ALLEGRO_FOR_EACH_FS_ENTRY_STOP = 2;  

type
  off_t = longint;

  ALLEGRO_PIXEL_FORMAT = Integer;
  PALLEGRO_PIXEL_FORMAT = ^ALLEGRO_PIXEL_FORMAT;

  _anonymous_type_1 = Integer;
  P_anonymous_type_1 = ^_anonymous_type_1;

  _anonymous_type_2 = Integer;
  P_anonymous_type_2 = ^_anonymous_type_2;

  ALLEGRO_SEEK = Integer;
  PALLEGRO_SEEK = ^ALLEGRO_SEEK;
  
  _anonymous_type_3 = Integer;
  P_anonymous_type_3 = ^_anonymous_type_3;

  _anonymous_type_4 = Integer;
  P_anonymous_type_4 = ^_anonymous_type_4;

  ALLEGRO_BLEND_MODE = Integer;
  PALLEGRO_BLEND_MODE = ^ALLEGRO_BLEND_MODE;

  ALLEGRO_BLEND_OPERATIONS = Integer;
  PALLEGRO_BLEND_OPERATIONS = ^ALLEGRO_BLEND_OPERATIONS;

  _anonymous_type_5 = Integer;
  P_anonymous_type_5 = ^_anonymous_type_5;

  _anonymous_type_6 = Integer;
  P_anonymous_type_6 = ^_anonymous_type_6;

  ALLEGRO_DISPLAY_OPTIONS = Integer;
  PALLEGRO_DISPLAY_OPTIONS = ^ALLEGRO_DISPLAY_OPTIONS;

  _anonymous_type_7 = Integer;
  P_anonymous_type_7 = ^_anonymous_type_7;
  
  ALLEGRO_DISPLAY_ORIENTATION = Integer;
  PALLEGRO_DISPLAY_ORIENTATION = ^ALLEGRO_DISPLAY_ORIENTATION;

  _anonymous_type_8 = Integer;
  P_anonymous_type_8 = ^_anonymous_type_8;

  ALLEGRO_FILE_MODE = Integer;
  PALLEGRO_FILE_MODE = ^ALLEGRO_FILE_MODE;

  ALLEGRO_FOR_EACH_FS_ENTRY_RESULT = Integer;
  PALLEGRO_FOR_EACH_FS_ENTRY_RESULT = ^ALLEGRO_FOR_EACH_FS_ENTRY_RESULT;

  ALLEGRO_JOYFLAGS = Integer;
  PALLEGRO_JOYFLAGS = ^ALLEGRO_JOYFLAGS;

  _anonymous_type_9 = Integer;
  P_anonymous_type_9 = ^_anonymous_type_9;

  _anonymous_type_10 = Integer;
  P_anonymous_type_10 = ^_anonymous_type_10;

  ALLEGRO_MOUSE_EMULATION_MODE = Integer;
  PALLEGRO_MOUSE_EMULATION_MODE = ^ALLEGRO_MOUSE_EMULATION_MODE;

  ALLEGRO_HAPTIC_CONSTANTS = Integer;
  PALLEGRO_HAPTIC_CONSTANTS = ^ALLEGRO_HAPTIC_CONSTANTS;

  _anonymous_type_11 = Integer;
  P_anonymous_type_11 = ^_anonymous_type_11;

  ALLEGRO_SYSTEM_MOUSE_CURSOR = Integer;
  PALLEGRO_SYSTEM_MOUSE_CURSOR = ^ALLEGRO_SYSTEM_MOUSE_CURSOR;
  
  ALLEGRO_RENDER_STATE = Integer;
  PALLEGRO_RENDER_STATE = ^ALLEGRO_RENDER_STATE;

  ALLEGRO_RENDER_FUNCTION = Integer;
  PALLEGRO_RENDER_FUNCTION = ^ALLEGRO_RENDER_FUNCTION;

  ALLEGRO_WRITE_MASK_FLAGS = Integer;
  PALLEGRO_WRITE_MASK_FLAGS = ^ALLEGRO_WRITE_MASK_FLAGS;

  ALLEGRO_SHADER_TYPE = Integer;
  PALLEGRO_SHADER_TYPE = ^ALLEGRO_SHADER_TYPE;

  ALLEGRO_SHADER_PLATFORM = Integer;
  PALLEGRO_SHADER_PLATFORM = ^ALLEGRO_SHADER_PLATFORM;

  ALLEGRO_SYSTEM_ID = Integer;
  PALLEGRO_SYSTEM_ID = ^ALLEGRO_SYSTEM_ID;

  _anonymous_type_12 = Integer;
  P_anonymous_type_12 = ^_anonymous_type_12;

  ALLEGRO_STATE_FLAGS = Integer;
  PALLEGRO_STATE_FLAGS = ^ALLEGRO_STATE_FLAGS;

  ALLEGRO_AUDIO_EVENT_TYPE = Integer;
  PALLEGRO_AUDIO_EVENT_TYPE = ^ALLEGRO_AUDIO_EVENT_TYPE;

  ALLEGRO_AUDIO_DEPTH = Integer;
  PALLEGRO_AUDIO_DEPTH = ^ALLEGRO_AUDIO_DEPTH;

  ALLEGRO_CHANNEL_CONF = Integer;
  PALLEGRO_CHANNEL_CONF = ^ALLEGRO_CHANNEL_CONF;

  ALLEGRO_PLAYMODE = Integer;
  PALLEGRO_PLAYMODE = ^ALLEGRO_PLAYMODE;

  ALLEGRO_MIXER_QUALITY = Integer;
  PALLEGRO_MIXER_QUALITY = ^ALLEGRO_MIXER_QUALITY;

  _anonymous_type_13 = Integer;
  P_anonymous_type_13 = ^_anonymous_type_13;

  _anonymous_type_14 = Integer;
  P_anonymous_type_14 = ^_anonymous_type_14;

  _anonymous_type_15 = Integer;
  P_anonymous_type_15 = ^_anonymous_type_15;

  _anonymous_type_16 = Integer;
  P_anonymous_type_16 = ^_anonymous_type_16;

  _anonymous_type_17 = Integer;
  P_anonymous_type_17 = ^_anonymous_type_17;

  _anonymous_type_18 = Integer;
  P_anonymous_type_18 = ^_anonymous_type_18;

  ALLEGRO_PRIM_TYPE = Integer;
  PALLEGRO_PRIM_TYPE = ^ALLEGRO_PRIM_TYPE;

  _anonymous_type_19 = Integer;
  P_anonymous_type_19 = ^_anonymous_type_19;

  ALLEGRO_PRIM_ATTR = Integer;
  PALLEGRO_PRIM_ATTR = ^ALLEGRO_PRIM_ATTR;

  ALLEGRO_PRIM_STORAGE = Integer;
  PALLEGRO_PRIM_STORAGE = ^ALLEGRO_PRIM_STORAGE;

  ALLEGRO_LINE_JOIN = Integer;
  PALLEGRO_LINE_JOIN = ^ALLEGRO_LINE_JOIN;

  ALLEGRO_LINE_CAP = Integer;
  PALLEGRO_LINE_CAP = ^ALLEGRO_LINE_CAP;

  ALLEGRO_PRIM_BUFFER_FLAGS = Integer;
  PALLEGRO_PRIM_BUFFER_FLAGS = ^ALLEGRO_PRIM_BUFFER_FLAGS;

  ALLEGRO_VIDEO_EVENT_TYPE = Integer;
  PALLEGRO_VIDEO_EVENT_TYPE = ^ALLEGRO_VIDEO_EVENT_TYPE;

  ALLEGRO_VIDEO_POSITION_TYPE = Integer;
  PALLEGRO_VIDEO_POSITION_TYPE = ^ALLEGRO_VIDEO_POSITION_TYPE;

  // Forward declarations
  PPUTF8Char = ^PUTF8Char;
  PUInt16 = ^UInt16;
  PALLEGRO_USER_EVENT_DESCRIPTOR = Pointer;
  PPALLEGRO_USER_EVENT_DESCRIPTOR = ^PALLEGRO_USER_EVENT_DESCRIPTOR;
  PALLEGRO_JOYSTICK_DRIVER = Pointer;
  PPALLEGRO_JOYSTICK_DRIVER = ^PALLEGRO_JOYSTICK_DRIVER;
  PALLEGRO_HAPTIC_DRIVER = Pointer;
  PPALLEGRO_HAPTIC_DRIVER = ^PALLEGRO_HAPTIC_DRIVER;
  PALLEGRO_TIMEOUT = ^ALLEGRO_TIMEOUT;
  PALLEGRO_COLOR = ^ALLEGRO_COLOR;
  P_al_tagbstring = ^_al_tagbstring;
  PALLEGRO_FILE_INTERFACE = ^ALLEGRO_FILE_INTERFACE;
  PALLEGRO_LOCKED_REGION = ^ALLEGRO_LOCKED_REGION;
  PALLEGRO_EVENT_SOURCE = ^ALLEGRO_EVENT_SOURCE;
  PALLEGRO_ANY_EVENT = ^ALLEGRO_ANY_EVENT;
  PALLEGRO_DISPLAY_EVENT = ^ALLEGRO_DISPLAY_EVENT;
  PALLEGRO_JOYSTICK_EVENT = ^ALLEGRO_JOYSTICK_EVENT;
  PALLEGRO_KEYBOARD_EVENT = ^ALLEGRO_KEYBOARD_EVENT;
  PALLEGRO_MOUSE_EVENT = ^ALLEGRO_MOUSE_EVENT;
  PALLEGRO_TIMER_EVENT = ^ALLEGRO_TIMER_EVENT;
  PALLEGRO_TOUCH_EVENT = ^ALLEGRO_TOUCH_EVENT;
  PALLEGRO_USER_EVENT = ^ALLEGRO_USER_EVENT;
  PALLEGRO_FS_ENTRY = ^ALLEGRO_FS_ENTRY;
  PALLEGRO_FS_INTERFACE = ^ALLEGRO_FS_INTERFACE;
  PALLEGRO_DISPLAY_MODE = ^ALLEGRO_DISPLAY_MODE;
  PALLEGRO_JOYSTICK_STATE = ^ALLEGRO_JOYSTICK_STATE;
  PALLEGRO_KEYBOARD_STATE = ^ALLEGRO_KEYBOARD_STATE;
  PALLEGRO_MOUSE_STATE = ^ALLEGRO_MOUSE_STATE;
  PALLEGRO_TOUCH_STATE = ^ALLEGRO_TOUCH_STATE;
  PALLEGRO_TOUCH_INPUT_STATE = ^ALLEGRO_TOUCH_INPUT_STATE;
  PALLEGRO_HAPTIC_DIRECTION = ^ALLEGRO_HAPTIC_DIRECTION;
  PALLEGRO_HAPTIC_REPLAY = ^ALLEGRO_HAPTIC_REPLAY;
  PALLEGRO_HAPTIC_ENVELOPE = ^ALLEGRO_HAPTIC_ENVELOPE;
  PALLEGRO_HAPTIC_CONSTANT_EFFECT = ^ALLEGRO_HAPTIC_CONSTANT_EFFECT;
  PALLEGRO_HAPTIC_RAMP_EFFECT = ^ALLEGRO_HAPTIC_RAMP_EFFECT;
  PALLEGRO_HAPTIC_CONDITION_EFFECT = ^ALLEGRO_HAPTIC_CONDITION_EFFECT;
  PALLEGRO_HAPTIC_PERIODIC_EFFECT = ^ALLEGRO_HAPTIC_PERIODIC_EFFECT;
  PALLEGRO_HAPTIC_RUMBLE_EFFECT = ^ALLEGRO_HAPTIC_RUMBLE_EFFECT;
  PALLEGRO_HAPTIC_EFFECT = ^ALLEGRO_HAPTIC_EFFECT;
  PALLEGRO_HAPTIC_EFFECT_ID = ^ALLEGRO_HAPTIC_EFFECT_ID;
  PALLEGRO_MEMORY_INTERFACE = ^ALLEGRO_MEMORY_INTERFACE;
  PALLEGRO_MONITOR_INFO = ^ALLEGRO_MONITOR_INFO;
  PALLEGRO_TRANSFORM = ^ALLEGRO_TRANSFORM;
  PALLEGRO_STATE = ^ALLEGRO_STATE;
  PALLEGRO_AUDIO_RECORDER_EVENT = ^ALLEGRO_AUDIO_RECORDER_EVENT;
  PALLEGRO_SAMPLE_ID = ^ALLEGRO_SAMPLE_ID;
  PALLEGRO_GLYPH = ^ALLEGRO_GLYPH;
  PALLEGRO_MENU_INFO = ^ALLEGRO_MENU_INFO;
  PALLEGRO_VERTEX_ELEMENT = ^ALLEGRO_VERTEX_ELEMENT;
  PALLEGRO_VERTEX = ^ALLEGRO_VERTEX;

  ALLEGRO_TIMEOUT = record
    __pad1__: UInt64;
    __pad2__: UInt64;
  end;

  ALLEGRO_COLOR = record
    r: Single;
    g: Single;
    b: Single;
    a: Single;
  end;

  _al_tagbstring = record
    mlen: Integer;
    slen: Integer;
    data: PByte;
  end;

  PALLEGRO_BITMAP = Pointer;
  PPALLEGRO_BITMAP = ^PALLEGRO_BITMAP;
  ALLEGRO_USTR = _al_tagbstring;
  PALLEGRO_USTR = ^ALLEGRO_USTR;
  ALLEGRO_USTR_INFO = _al_tagbstring;
  PALLEGRO_USTR_INFO = ^ALLEGRO_USTR_INFO;

  PALLEGRO_PATH = Pointer;
  PPALLEGRO_PATH = ^PALLEGRO_PATH;
  PALLEGRO_FILE = Pointer;
  PPALLEGRO_FILE = ^PALLEGRO_FILE;

  ALLEGRO_FILE_INTERFACE = record
    fi_fopen: function(const path: PUTF8Char; const mode: PUTF8Char): Pointer; cdecl;
    fi_fclose: function(handle: PALLEGRO_FILE): Boolean; cdecl;
    fi_fread: function(f: PALLEGRO_FILE; ptr: Pointer; size: NativeUInt): NativeUInt; cdecl;
    fi_fwrite: function(f: PALLEGRO_FILE; const ptr: Pointer; size: NativeUInt): NativeUInt; cdecl;
    fi_fflush: function(f: PALLEGRO_FILE): Boolean; cdecl;
    fi_ftell: function(f: PALLEGRO_FILE): Int64; cdecl;
    fi_fseek: function(f: PALLEGRO_FILE; offset: Int64; whence: Integer): Boolean; cdecl;
    fi_feof: function(f: PALLEGRO_FILE): Boolean; cdecl;
    fi_ferror: function(f: PALLEGRO_FILE): Integer; cdecl;
    fi_ferrmsg: function(f: PALLEGRO_FILE): PUTF8Char; cdecl;
    fi_fclearerr: procedure(f: PALLEGRO_FILE); cdecl;
    fi_fungetc: function(f: PALLEGRO_FILE; c: Integer): Integer; cdecl;
    fi_fsize: function(f: PALLEGRO_FILE): off_t; cdecl;
  end;

  ALLEGRO_IIO_LOADER_FUNCTION = function(const filename: PUTF8Char; flags: Integer): PALLEGRO_BITMAP; cdecl;
  ALLEGRO_IIO_FS_LOADER_FUNCTION = function(fp: PALLEGRO_FILE; flags: Integer): PALLEGRO_BITMAP; cdecl;
  ALLEGRO_IIO_SAVER_FUNCTION = function(const filename: PUTF8Char; bitmap: PALLEGRO_BITMAP): Boolean; cdecl;
  ALLEGRO_IIO_FS_SAVER_FUNCTION = function(fp: PALLEGRO_FILE; bitmap: PALLEGRO_BITMAP): Boolean; cdecl;
  ALLEGRO_IIO_IDENTIFIER_FUNCTION = function(f: PALLEGRO_FILE): Boolean; cdecl;

  ALLEGRO_LOCKED_REGION = record
    data: Pointer;
    format: Integer;
    pitch: Integer;
    pixel_size: Integer;
  end;

  ALLEGRO_EVENT_TYPE = Cardinal;

  ALLEGRO_EVENT_SOURCE = record
    __pad: array [0..31] of Integer;
  end;

  ALLEGRO_ANY_EVENT = record
    &type: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_EVENT_SOURCE;
    timestamp: Double;
  end;

  PALLEGRO_DISPLAY = Pointer;
  PPALLEGRO_DISPLAY = ^PALLEGRO_DISPLAY;

  ALLEGRO_DISPLAY_EVENT = record
    &type: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_DISPLAY;
    timestamp: Double;
    x: Integer;
    y: Integer;
    width: Integer;
    height: Integer;
    orientation: Integer;
  end;

  PALLEGRO_JOYSTICK = Pointer;
  PPALLEGRO_JOYSTICK = ^PALLEGRO_JOYSTICK;

  ALLEGRO_JOYSTICK_EVENT = record
    &type: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_JOYSTICK;
    timestamp: Double;
    id: PALLEGRO_JOYSTICK;
    stick: Integer;
    axis: Integer;
    pos: Single;
    button: Integer;
  end;

  PALLEGRO_KEYBOARD = Pointer;
  PPALLEGRO_KEYBOARD = ^PALLEGRO_KEYBOARD;

  ALLEGRO_KEYBOARD_EVENT = record
    &type: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_KEYBOARD;
    timestamp: Double;
    display: PALLEGRO_DISPLAY;
    keycode: Integer;
    unichar: Integer;
    modifiers: Cardinal;
    &repeat: Boolean;
  end;

  PALLEGRO_MOUSE = Pointer;
  PPALLEGRO_MOUSE = ^PALLEGRO_MOUSE;

  ALLEGRO_MOUSE_EVENT = record
    &type: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_MOUSE;
    timestamp: Double;
    display: PALLEGRO_DISPLAY;
    x: Integer;
    y: Integer;
    z: Integer;
    w: Integer;
    dx: Integer;
    dy: Integer;
    dz: Integer;
    dw: Integer;
    button: Cardinal;
    pressure: Single;
  end;

  PALLEGRO_TIMER = Pointer;
  PPALLEGRO_TIMER = ^PALLEGRO_TIMER;

  ALLEGRO_TIMER_EVENT = record
    &type: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_TIMER;
    timestamp: Double;
    count: Int64;
    error: Double;
  end;

  PALLEGRO_TOUCH_INPUT = Pointer;
  PPALLEGRO_TOUCH_INPUT = ^PALLEGRO_TOUCH_INPUT;

  ALLEGRO_TOUCH_EVENT = record
    &type: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_TOUCH_INPUT;
    timestamp: Double;
    display: PALLEGRO_DISPLAY;
    id: Integer;
    x: Single;
    y: Single;
    dx: Single;
    dy: Single;
    primary: Boolean;
  end;

  ALLEGRO_USER_EVENT = record
    &type: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_EVENT_SOURCE;
    timestamp: Double;
    __internal__descr: PALLEGRO_USER_EVENT_DESCRIPTOR;
    data1: IntPtr;
    data2: IntPtr;
    data3: IntPtr;
    data4: IntPtr;
  end;

  PALLEGRO_EVENT = ^ALLEGRO_EVENT;
  ALLEGRO_EVENT = record
    case Integer of
      0: (&type: ALLEGRO_EVENT_TYPE);
      1: (any: ALLEGRO_ANY_EVENT);
      2: (display: ALLEGRO_DISPLAY_EVENT);
      3: (joystick: ALLEGRO_JOYSTICK_EVENT);
      4: (keyboard: ALLEGRO_KEYBOARD_EVENT);
      5: (mouse: ALLEGRO_MOUSE_EVENT);
      6: (timer: ALLEGRO_TIMER_EVENT);
      7: (touch: ALLEGRO_TOUCH_EVENT);
      8: (user: ALLEGRO_USER_EVENT);
  end;

  PALLEGRO_EVENT_QUEUE = Pointer;
  PPALLEGRO_EVENT_QUEUE = ^PALLEGRO_EVENT_QUEUE;

  PALLEGRO_CONFIG = Pointer;
  PPALLEGRO_CONFIG = ^PALLEGRO_CONFIG;
  PALLEGRO_CONFIG_SECTION = Pointer;
  PPALLEGRO_CONFIG_SECTION = ^PALLEGRO_CONFIG_SECTION;
  PALLEGRO_CONFIG_ENTRY = Pointer;
  PPALLEGRO_CONFIG_ENTRY = ^PALLEGRO_CONFIG_ENTRY;
  al_fixed = Int32;

  ALLEGRO_FS_ENTRY = record
    vtable: PALLEGRO_FS_INTERFACE;
  end;

  ALLEGRO_FS_INTERFACE = record
    fs_create_entry: function(const path: PUTF8Char): PALLEGRO_FS_ENTRY; cdecl;
    fs_destroy_entry: procedure(e: PALLEGRO_FS_ENTRY); cdecl;
    fs_entry_name: function(e: PALLEGRO_FS_ENTRY): PUTF8Char; cdecl;
    fs_update_entry: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_entry_mode: function(e: PALLEGRO_FS_ENTRY): UInt32; cdecl;
    fs_entry_atime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
    fs_entry_mtime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
    fs_entry_ctime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
    fs_entry_size: function(e: PALLEGRO_FS_ENTRY): off_t; cdecl;
    fs_entry_exists: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_remove_entry: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_open_directory: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_read_directory: function(e: PALLEGRO_FS_ENTRY): PALLEGRO_FS_ENTRY; cdecl;
    fs_close_directory: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_filename_exists: function(const path: PUTF8Char): Boolean; cdecl;
    fs_remove_filename: function(const path: PUTF8Char): Boolean; cdecl;
    fs_get_current_directory: function(): PUTF8Char; cdecl;
    fs_change_directory: function(const path: PUTF8Char): Boolean; cdecl;
    fs_make_directory: function(const path: PUTF8Char): Boolean; cdecl;
    fs_open_file: function(e: PALLEGRO_FS_ENTRY; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  end;

  ALLEGRO_DISPLAY_MODE = record
    width: Integer;
    height: Integer;
    format: Integer;
    refresh_rate: Integer;
  end;

  _anonymous_type_20 = record
    axis: array [0..2] of Single;
  end;
  P_anonymous_type_20 = ^_anonymous_type_20;

  ALLEGRO_JOYSTICK_STATE = record
    stick: array [0..15] of _anonymous_type_20;
    button: array [0..31] of Integer;
  end;

  ALLEGRO_KEYBOARD_STATE = record
    display: PALLEGRO_DISPLAY;
    __key_down__internal__: array [0..7] of Cardinal;
  end;

  ALLEGRO_MOUSE_STATE = record
    x: Integer;
    y: Integer;
    z: Integer;
    w: Integer;
    more_axes: array [0..3] of Integer;
    buttons: Integer;
    pressure: Single;
    display: PALLEGRO_DISPLAY;
  end;

  ALLEGRO_TOUCH_STATE = record
    id: Integer;
    x: Single;
    y: Single;
    dx: Single;
    dy: Single;
    primary: Boolean;
    display: PALLEGRO_DISPLAY;
  end;

  ALLEGRO_TOUCH_INPUT_STATE = record
    touches: array [0..15] of ALLEGRO_TOUCH_STATE;
  end;

  PALLEGRO_HAPTIC = Pointer;
  PPALLEGRO_HAPTIC = ^PALLEGRO_HAPTIC;

  ALLEGRO_HAPTIC_DIRECTION = record
    angle: Double;
    radius: Double;
    azimuth: Double;
  end;

  ALLEGRO_HAPTIC_REPLAY = record
    length: Double;
    delay: Double;
  end;

  ALLEGRO_HAPTIC_ENVELOPE = record
    attack_length: Double;
    attack_level: Double;
    fade_length: Double;
    fade_level: Double;
  end;

  ALLEGRO_HAPTIC_CONSTANT_EFFECT = record
    level: Double;
    envelope: ALLEGRO_HAPTIC_ENVELOPE;
  end;

  ALLEGRO_HAPTIC_RAMP_EFFECT = record
    start_level: Double;
    end_level: Double;
    envelope: ALLEGRO_HAPTIC_ENVELOPE;
  end;

  ALLEGRO_HAPTIC_CONDITION_EFFECT = record
    right_saturation: Double;
    left_saturation: Double;
    right_coeff: Double;
    left_coeff: Double;
    deadband: Double;
    center: Double;
  end;

  ALLEGRO_HAPTIC_PERIODIC_EFFECT = record
    waveform: Integer;
    period: Double;
    magnitude: Double;
    offset: Double;
    phase: Double;
    envelope: ALLEGRO_HAPTIC_ENVELOPE;
    custom_len: Integer;
    custom_data: PDouble;
  end;

  ALLEGRO_HAPTIC_RUMBLE_EFFECT = record
    strong_magnitude: Double;
    weak_magnitude: Double;
  end;

  ALLEGRO_HAPTIC_EFFECT_UNION = record
    case Integer of
      0: (constant: ALLEGRO_HAPTIC_CONSTANT_EFFECT);
      1: (ramp: ALLEGRO_HAPTIC_RAMP_EFFECT);
      2: (periodic: ALLEGRO_HAPTIC_PERIODIC_EFFECT);
      3: (condition: ALLEGRO_HAPTIC_CONDITION_EFFECT);
      4: (rumble: ALLEGRO_HAPTIC_RUMBLE_EFFECT);
  end;

  ALLEGRO_HAPTIC_EFFECT = record
    &type: Integer;
    direction: ALLEGRO_HAPTIC_DIRECTION;
    replay: ALLEGRO_HAPTIC_REPLAY;
    data: ALLEGRO_HAPTIC_EFFECT_UNION;
  end;

  ALLEGRO_HAPTIC_EFFECT_ID = record
    _haptic: PALLEGRO_HAPTIC;
    _id: Integer;
    _handle: Integer;
    _pointer: Pointer;
    _effect_duration: Double;
    _playing: Boolean;
    _start_time: Double;
    _end_time: Double;
    driver: Pointer;
  end;

  ALLEGRO_MEMORY_INTERFACE = record
    mi_malloc: function(n: NativeUInt; line: Integer; const &file: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
    mi_free: procedure(ptr: Pointer; line: Integer; const &file: PUTF8Char; const func: PUTF8Char); cdecl;
    mi_realloc: function(ptr: Pointer; n: NativeUInt; line: Integer; const &file: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
    mi_calloc: function(count: NativeUInt; n: NativeUInt; line: Integer; const &file: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
  end;

  ALLEGRO_MONITOR_INFO = record
    x1: Integer;
    y1: Integer;
    x2: Integer;
    y2: Integer;
  end;

  PALLEGRO_MOUSE_CURSOR = Pointer;
  PPALLEGRO_MOUSE_CURSOR = ^PALLEGRO_MOUSE_CURSOR;

  ALLEGRO_TRANSFORM = record
    m: array [0..3] of array [0..3] of Single;
  end;

  PALLEGRO_SHADER = Pointer;
  PPALLEGRO_SHADER = ^PALLEGRO_SHADER;
  PALLEGRO_SYSTEM = Pointer;
  PPALLEGRO_SYSTEM = ^PALLEGRO_SYSTEM;
  PALLEGRO_THREAD = Pointer;
  PPALLEGRO_THREAD = ^PALLEGRO_THREAD;
  PALLEGRO_MUTEX = Pointer;
  PPALLEGRO_MUTEX = ^PALLEGRO_MUTEX;
  PALLEGRO_COND = Pointer;
  PPALLEGRO_COND = ^PALLEGRO_COND;

  ALLEGRO_STATE = record
    _tls: array [0..1023] of UTF8Char;
  end;

  PALLEGRO_AUDIO_RECORDER = Pointer;
  PPALLEGRO_AUDIO_RECORDER = ^PALLEGRO_AUDIO_RECORDER;

  ALLEGRO_AUDIO_RECORDER_EVENT = record
    &type: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_AUDIO_RECORDER;
    timestamp: Double;
    __internal__descr: PALLEGRO_USER_EVENT_DESCRIPTOR;
    buffer: Pointer;
    samples: Cardinal;
  end;

  PALLEGRO_SAMPLE = Pointer;
  PPALLEGRO_SAMPLE = ^PALLEGRO_SAMPLE;

  ALLEGRO_SAMPLE_ID = record
    _index: Integer;
    _id: Integer;
  end;

  PALLEGRO_SAMPLE_INSTANCE = Pointer;
  PPALLEGRO_SAMPLE_INSTANCE = ^PALLEGRO_SAMPLE_INSTANCE;
  PALLEGRO_AUDIO_STREAM = Pointer;
  PPALLEGRO_AUDIO_STREAM = ^PALLEGRO_AUDIO_STREAM;
  PALLEGRO_MIXER = Pointer;
  PPALLEGRO_MIXER = ^PALLEGRO_MIXER;
  PALLEGRO_VOICE = Pointer;
  PPALLEGRO_VOICE = ^PALLEGRO_VOICE;
  PALLEGRO_AUDIO_DEVICE = Pointer;
  PPALLEGRO_AUDIO_DEVICE = ^PALLEGRO_AUDIO_DEVICE;

  PALLEGRO_FONT = Pointer;
  PPALLEGRO_FONT = ^PALLEGRO_FONT;

  ALLEGRO_GLYPH = record
    bitmap: PALLEGRO_BITMAP;
    x: Integer;
    y: Integer;
    w: Integer;
    h: Integer;
    kerning: Integer;
    offset_x: Integer;
    offset_y: Integer;
    advance: Integer;
  end;

  PALLEGRO_FILECHOOSER = Pointer;
  PPALLEGRO_FILECHOOSER = ^PALLEGRO_FILECHOOSER;
  PALLEGRO_TEXTLOG = Pointer;
  PPALLEGRO_TEXTLOG = ^PALLEGRO_TEXTLOG;
  PALLEGRO_MENU = Pointer;
  PPALLEGRO_MENU = ^PALLEGRO_MENU;

  ALLEGRO_MENU_INFO = record
    caption: PUTF8Char;
    id: UInt16;
    flags: Integer;
    icon: PALLEGRO_BITMAP;
  end;

  ALLEGRO_VERTEX_ELEMENT = record
    attribute: Integer;
    storage: Integer;
    offset: Integer;
  end;

  PALLEGRO_VERTEX_DECL = Pointer;
  PPALLEGRO_VERTEX_DECL = ^PALLEGRO_VERTEX_DECL;

  ALLEGRO_VERTEX = record
    x: Single;
    y: Single;
    z: Single;
    u: Single;
    v: Single;
    color: ALLEGRO_COLOR;
  end;

  PALLEGRO_VERTEX_BUFFER = Pointer;
  PPALLEGRO_VERTEX_BUFFER = ^PALLEGRO_VERTEX_BUFFER;
  PALLEGRO_INDEX_BUFFER = Pointer;
  PPALLEGRO_INDEX_BUFFER = ^PALLEGRO_INDEX_BUFFER;
  PALLEGRO_VIDEO = Pointer;
  PPALLEGRO_VIDEO = ^PALLEGRO_VIDEO;

  al_run_main_ = function(p1: Integer; p2: PPUTF8Char): Integer; cdecl;
  al_emit_user_event_dtor = procedure(p1: PALLEGRO_USER_EVENT); cdecl;
  al_register_assert_handler_handler = procedure(const expr: PUTF8Char; const &file: PUTF8Char; line: Integer; const func: PUTF8Char); cdecl;
  al_register_trace_handler_handler = procedure(const p1: PUTF8Char); cdecl;
  al_for_each_fs_entry_callback = function(entry: PALLEGRO_FS_ENTRY; extra: Pointer): Integer; cdecl;
  atexit_ptr_ = Pointer;
  al_install_system_atexit_ptr = function(p1: atexit_ptr_): Integer; cdecl;
  al_create_thread_proc = function(thread: PALLEGRO_THREAD; arg: Pointer): Pointer; cdecl;
  al_create_thread_with_stacksize_proc = function(thread: PALLEGRO_THREAD; arg: Pointer): Pointer; cdecl;
  al_run_detached_thread_proc = function(arg: Pointer): Pointer; cdecl;
  al_set_mixer_postprocess_callback_cb = procedure(buf: Pointer; samples: Cardinal; data: Pointer); cdecl;
  al_register_sample_loader_loader = function(const filename: PUTF8Char): PALLEGRO_SAMPLE; cdecl;
  al_register_sample_saver_saver = function(const filename: PUTF8Char; spl: PALLEGRO_SAMPLE): Boolean; cdecl;
  al_register_audio_stream_loader_stream_loader = function(const filename: PUTF8Char; buffer_count: NativeUInt; samples: Cardinal): PALLEGRO_AUDIO_STREAM; cdecl;
  al_register_sample_loader_f_loader = function(fp: PALLEGRO_FILE): PALLEGRO_SAMPLE; cdecl;
  al_register_sample_saver_f_saver = function(fp: PALLEGRO_FILE; spl: PALLEGRO_SAMPLE): Boolean; cdecl;
  al_register_audio_stream_loader_f_stream_loader = function(fp: PALLEGRO_FILE; buffer_count: NativeUInt; samples: Cardinal): PALLEGRO_AUDIO_STREAM; cdecl;
  al_register_sample_identifier_identifier = function(fp: PALLEGRO_FILE): Boolean; cdecl;
  al_register_font_loader_load = function(const filename: PUTF8Char; size: Integer; flags: Integer): PALLEGRO_FONT; cdecl;
  al_do_multiline_text_cb = function(line_num: Integer; const line: PUTF8Char; size: Integer; extra: Pointer): Boolean; cdecl;
  al_do_multiline_ustr_cb = function(line_num: Integer; const line: PALLEGRO_USTR; extra: Pointer): Boolean; cdecl;
  al_triangulate_polygon_emit_triangle = procedure(p1: Integer; p2: Integer; p3: Integer; p4: Pointer); cdecl;
  al_draw_soft_triangle_init = procedure(p1: UIntPtr; p2: PALLEGRO_VERTEX; p3: PALLEGRO_VERTEX; p4: PALLEGRO_VERTEX); cdecl;
  al_draw_soft_triangle_first = procedure(p1: UIntPtr; p2: Integer; p3: Integer; p4: Integer; p5: Integer); cdecl;
  al_draw_soft_triangle_step = procedure(p1: UIntPtr; p2: Integer); cdecl;
  al_draw_soft_triangle_draw = procedure(p1: UIntPtr; p2: Integer; p3: Integer; p4: Integer); cdecl;
  al_draw_soft_line_first = procedure(p1: UIntPtr; p2: Integer; p3: Integer; p4: PALLEGRO_VERTEX; p5: PALLEGRO_VERTEX); cdecl;
  al_draw_soft_line_step = procedure(p1: UIntPtr; p2: Integer); cdecl;
  PLRESULT = ^LRESULT;
  al_win_add_window_callback_callback = function(display: PALLEGRO_DISPLAY; &message: UINT; wparam: WPARAM; lparam: LPARAM; result: PLRESULT; userdata: Pointer): Boolean; cdecl;
  al_win_remove_window_callback_callback = function(display: PALLEGRO_DISPLAY; &message: UINT; wparam: WPARAM; lparam: LPARAM; result: PLRESULT; userdata: Pointer): Boolean; cdecl;
  al_draw_soft_line_draw  = procedure(p1: UIntPtr; p2: Integer; p3: Integer); cdecl;

var
  al_get_allegro_version: function: UInt32; cdecl;
  al_run_main: function(argc: Integer; argv: PPUTF8Char; p3: al_run_main_): Integer; cdecl;
  al_get_time: function: Double; cdecl;
  al_rest: procedure(seconds: Double); cdecl;
  al_init_timeout: procedure(timeout: PALLEGRO_TIMEOUT; seconds: Double); cdecl;
  al_map_rgb: function(r: Byte; g: Byte; b: Byte): ALLEGRO_COLOR; cdecl;
  al_map_rgba: function(r: Byte; g: Byte; b: Byte; a: Byte): ALLEGRO_COLOR; cdecl;
  al_map_rgb_f: function(r: Single; g: Single; b: Single): ALLEGRO_COLOR; cdecl;
  al_map_rgba_f: function(r: Single; g: Single; b: Single; a: Single): ALLEGRO_COLOR; cdecl;
  al_premul_rgba: function(r: Byte; g: Byte; b: Byte; a: Byte): ALLEGRO_COLOR; cdecl;
  al_premul_rgba_f: function(r: Single; g: Single; b: Single; a: Single): ALLEGRO_COLOR; cdecl;
  al_unmap_rgb: procedure(color: ALLEGRO_COLOR; r: PByte; g: PByte; b: PByte); cdecl;
  al_unmap_rgba: procedure(color: ALLEGRO_COLOR; r: PByte; g: PByte; b: PByte; a: PByte); cdecl;
  al_unmap_rgb_f: procedure(color: ALLEGRO_COLOR; r: PSingle; g: PSingle; b: PSingle); cdecl;
  al_unmap_rgba_f: procedure(color: ALLEGRO_COLOR; r: PSingle; g: PSingle; b: PSingle; a: PSingle); cdecl;
  al_get_pixel_size: function(format: Integer): Integer; cdecl;
  al_get_pixel_format_bits: function(format: Integer): Integer; cdecl;
  al_get_pixel_block_size: function(format: Integer): Integer; cdecl;
  al_get_pixel_block_width: function(format: Integer): Integer; cdecl;
  al_get_pixel_block_height: function(format: Integer): Integer; cdecl;
  al_set_new_bitmap_format: procedure(format: Integer); cdecl;
  al_set_new_bitmap_flags: procedure(flags: Integer); cdecl;
  al_get_new_bitmap_format: function: Integer; cdecl;
  al_get_new_bitmap_flags: function: Integer; cdecl;
  al_add_new_bitmap_flag: procedure(flag: Integer); cdecl;
  al_get_new_bitmap_depth: function: Integer; cdecl;
  al_set_new_bitmap_depth: procedure(depth: Integer); cdecl;
  al_get_new_bitmap_samples: function: Integer; cdecl;
  al_set_new_bitmap_samples: procedure(samples: Integer); cdecl;
  al_get_bitmap_width: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_get_bitmap_height: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_get_bitmap_format: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_get_bitmap_flags: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_get_bitmap_depth: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_get_bitmap_samples: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_create_bitmap: function(w: Integer; h: Integer): PALLEGRO_BITMAP; cdecl;
  al_destroy_bitmap: procedure(bitmap: PALLEGRO_BITMAP); cdecl;
  al_put_pixel: procedure(x: Integer; y: Integer; color: ALLEGRO_COLOR); cdecl;
  al_put_blended_pixel: procedure(x: Integer; y: Integer; color: ALLEGRO_COLOR); cdecl;
  al_get_pixel: function(bitmap: PALLEGRO_BITMAP; x: Integer; y: Integer): ALLEGRO_COLOR; cdecl;
  al_convert_mask_to_alpha: procedure(bitmap: PALLEGRO_BITMAP; mask_color: ALLEGRO_COLOR); cdecl;
  al_get_bitmap_blend_color: function: ALLEGRO_COLOR; cdecl;
  al_get_bitmap_blender: procedure(op: PInteger; src: PInteger; dst: PInteger); cdecl;
  al_get_separate_bitmap_blender: procedure(op: PInteger; src: PInteger; dst: PInteger; alpha_op: PInteger; alpha_src: PInteger; alpha_dst: PInteger); cdecl;
  al_set_bitmap_blend_color: procedure(color: ALLEGRO_COLOR); cdecl;
  al_set_bitmap_blender: procedure(op: Integer; src: Integer; dst: Integer); cdecl;
  al_set_separate_bitmap_blender: procedure(op: Integer; src: Integer; dst: Integer; alpha_op: Integer; alpha_src: Integer; alpha_dst: Integer); cdecl;
  al_reset_bitmap_blender: procedure; cdecl;
  al_set_clipping_rectangle: procedure(x: Integer; y: Integer; width: Integer; height: Integer); cdecl;
  al_reset_clipping_rectangle: procedure; cdecl;
  al_get_clipping_rectangle: procedure(x: PInteger; y: PInteger; w: PInteger; h: PInteger); cdecl;
  al_create_sub_bitmap: function(parent: PALLEGRO_BITMAP; x: Integer; y: Integer; w: Integer; h: Integer): PALLEGRO_BITMAP; cdecl;
  al_is_sub_bitmap: function(bitmap: PALLEGRO_BITMAP): Boolean; cdecl;
  al_get_parent_bitmap: function(bitmap: PALLEGRO_BITMAP): PALLEGRO_BITMAP; cdecl;
  al_get_bitmap_x: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_get_bitmap_y: function(bitmap: PALLEGRO_BITMAP): Integer; cdecl;
  al_reparent_bitmap: procedure(bitmap: PALLEGRO_BITMAP; parent: PALLEGRO_BITMAP; x: Integer; y: Integer; w: Integer; h: Integer); cdecl;
  al_clone_bitmap: function(bitmap: PALLEGRO_BITMAP): PALLEGRO_BITMAP; cdecl;
  al_convert_bitmap: procedure(bitmap: PALLEGRO_BITMAP); cdecl;
  al_convert_memory_bitmaps: procedure; cdecl;
  al_backup_dirty_bitmap: procedure(bitmap: PALLEGRO_BITMAP); cdecl;
  al_draw_bitmap: procedure(bitmap: PALLEGRO_BITMAP; dx: Single; dy: Single; flags: Integer); cdecl;
  al_draw_bitmap_region: procedure(bitmap: PALLEGRO_BITMAP; sx: Single; sy: Single; sw: Single; sh: Single; dx: Single; dy: Single; flags: Integer); cdecl;
  al_draw_scaled_bitmap: procedure(bitmap: PALLEGRO_BITMAP; sx: Single; sy: Single; sw: Single; sh: Single; dx: Single; dy: Single; dw: Single; dh: Single; flags: Integer); cdecl;
  al_draw_rotated_bitmap: procedure(bitmap: PALLEGRO_BITMAP; cx: Single; cy: Single; dx: Single; dy: Single; angle: Single; flags: Integer); cdecl;
  al_draw_scaled_rotated_bitmap: procedure(bitmap: PALLEGRO_BITMAP; cx: Single; cy: Single; dx: Single; dy: Single; xscale: Single; yscale: Single; angle: Single; flags: Integer); cdecl;
  al_draw_tinted_bitmap: procedure(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; dx: Single; dy: Single; flags: Integer); cdecl;
  al_draw_tinted_bitmap_region: procedure(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; sx: Single; sy: Single; sw: Single; sh: Single; dx: Single; dy: Single; flags: Integer); cdecl;
  al_draw_tinted_scaled_bitmap: procedure(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; sx: Single; sy: Single; sw: Single; sh: Single; dx: Single; dy: Single; dw: Single; dh: Single; flags: Integer); cdecl;
  al_draw_tinted_rotated_bitmap: procedure(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; cx: Single; cy: Single; dx: Single; dy: Single; angle: Single; flags: Integer); cdecl;
  al_draw_tinted_scaled_rotated_bitmap: procedure(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; cx: Single; cy: Single; dx: Single; dy: Single; xscale: Single; yscale: Single; angle: Single; flags: Integer); cdecl;
  al_draw_tinted_scaled_rotated_bitmap_region: procedure(bitmap: PALLEGRO_BITMAP; sx: Single; sy: Single; sw: Single; sh: Single; tint: ALLEGRO_COLOR; cx: Single; cy: Single; dx: Single; dy: Single; xscale: Single; yscale: Single; angle: Single; flags: Integer); cdecl;
  al_ustr_new: function(const s: PUTF8Char): PALLEGRO_USTR; cdecl;
  al_ustr_new_from_buffer: function(const s: PUTF8Char; size: NativeUInt): PALLEGRO_USTR; cdecl;
  al_ustr_newf: function(const fmt: PUTF8Char): PALLEGRO_USTR varargs; cdecl;
  al_ustr_free: procedure(us: PALLEGRO_USTR); cdecl;
  al_cstr: function(const us: PALLEGRO_USTR): PUTF8Char; cdecl;
  al_ustr_to_buffer: procedure(const us: PALLEGRO_USTR; buffer: PUTF8Char; size: Integer); cdecl;
  al_cstr_dup: function(const us: PALLEGRO_USTR): PUTF8Char; cdecl;
  al_ustr_dup: function(const us: PALLEGRO_USTR): PALLEGRO_USTR; cdecl;
  al_ustr_dup_substr: function(const us: PALLEGRO_USTR; start_pos: Integer; end_pos: Integer): PALLEGRO_USTR; cdecl;
  al_ustr_empty_string: function: PALLEGRO_USTR; cdecl;
  al_ref_cstr: function(info: PALLEGRO_USTR_INFO; const s: PUTF8Char): PALLEGRO_USTR; cdecl;
  al_ref_buffer: function(info: PALLEGRO_USTR_INFO; const s: PUTF8Char; size: NativeUInt): PALLEGRO_USTR; cdecl;
  al_ref_ustr: function(info: PALLEGRO_USTR_INFO; const us: PALLEGRO_USTR; start_pos: Integer; end_pos: Integer): PALLEGRO_USTR; cdecl;
  al_ustr_size: function(const us: PALLEGRO_USTR): NativeUInt; cdecl;
  al_ustr_length: function(const us: PALLEGRO_USTR): NativeUInt; cdecl;
  al_ustr_offset: function(const us: PALLEGRO_USTR; index: Integer): Integer; cdecl;
  al_ustr_next: function(const us: PALLEGRO_USTR; pos: PInteger): Boolean; cdecl;
  al_ustr_prev: function(const us: PALLEGRO_USTR; pos: PInteger): Boolean; cdecl;
  al_ustr_get: function(const us: PALLEGRO_USTR; pos: Integer): Int32; cdecl;
  al_ustr_get_next: function(const us: PALLEGRO_USTR; pos: PInteger): Int32; cdecl;
  al_ustr_prev_get: function(const us: PALLEGRO_USTR; pos: PInteger): Int32; cdecl;
  al_ustr_insert: function(us1: PALLEGRO_USTR; pos: Integer; const us2: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_insert_cstr: function(us: PALLEGRO_USTR; pos: Integer; const us2: PUTF8Char): Boolean; cdecl;
  al_ustr_insert_chr: function(us: PALLEGRO_USTR; pos: Integer; c: Int32): NativeUInt; cdecl;
  al_ustr_append: function(us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_append_cstr: function(us: PALLEGRO_USTR; const s: PUTF8Char): Boolean; cdecl;
  al_ustr_append_chr: function(us: PALLEGRO_USTR; c: Int32): NativeUInt; cdecl;
  al_ustr_appendf: function(us: PALLEGRO_USTR; const fmt: PUTF8Char): Boolean varargs; cdecl;
  al_ustr_vappendf: function(us: PALLEGRO_USTR; const fmt: PUTF8Char; ap: Pointer): Boolean; cdecl;
  al_ustr_remove_chr: function(us: PALLEGRO_USTR; pos: Integer): Boolean; cdecl;
  al_ustr_remove_range: function(us: PALLEGRO_USTR; start_pos: Integer; end_pos: Integer): Boolean; cdecl;
  al_ustr_truncate: function(us: PALLEGRO_USTR; start_pos: Integer): Boolean; cdecl;
  al_ustr_ltrim_ws: function(us: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_rtrim_ws: function(us: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_trim_ws: function(us: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_assign: function(us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_assign_substr: function(us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR; start_pos: Integer; end_pos: Integer): Boolean; cdecl;
  al_ustr_assign_cstr: function(us1: PALLEGRO_USTR; const s: PUTF8Char): Boolean; cdecl;
  al_ustr_set_chr: function(us: PALLEGRO_USTR; pos: Integer; c: Int32): NativeUInt; cdecl;
  al_ustr_replace_range: function(us1: PALLEGRO_USTR; start_pos1: Integer; end_pos1: Integer; const us2: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_find_chr: function(const us: PALLEGRO_USTR; start_pos: Integer; c: Int32): Integer; cdecl;
  al_ustr_rfind_chr: function(const us: PALLEGRO_USTR; start_pos: Integer; c: Int32): Integer; cdecl;
  al_ustr_find_set: function(const us: PALLEGRO_USTR; start_pos: Integer; const accept: PALLEGRO_USTR): Integer; cdecl;
  al_ustr_find_set_cstr: function(const us: PALLEGRO_USTR; start_pos: Integer; const accept: PUTF8Char): Integer; cdecl;
  al_ustr_find_cset: function(const us: PALLEGRO_USTR; start_pos: Integer; const reject: PALLEGRO_USTR): Integer; cdecl;
  al_ustr_find_cset_cstr: function(const us: PALLEGRO_USTR; start_pos: Integer; const reject: PUTF8Char): Integer; cdecl;
  al_ustr_find_str: function(const haystack: PALLEGRO_USTR; start_pos: Integer; const needle: PALLEGRO_USTR): Integer; cdecl;
  al_ustr_find_cstr: function(const haystack: PALLEGRO_USTR; start_pos: Integer; const needle: PUTF8Char): Integer; cdecl;
  al_ustr_rfind_str: function(const haystack: PALLEGRO_USTR; start_pos: Integer; const needle: PALLEGRO_USTR): Integer; cdecl;
  al_ustr_rfind_cstr: function(const haystack: PALLEGRO_USTR; start_pos: Integer; const needle: PUTF8Char): Integer; cdecl;
  al_ustr_find_replace: function(us: PALLEGRO_USTR; start_pos: Integer; const find: PALLEGRO_USTR; const replace: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_find_replace_cstr: function(us: PALLEGRO_USTR; start_pos: Integer; const find: PUTF8Char; const replace: PUTF8Char): Boolean; cdecl;
  al_ustr_equal: function(const us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_compare: function(const u: PALLEGRO_USTR; const v: PALLEGRO_USTR): Integer; cdecl;
  al_ustr_ncompare: function(const us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR; n: Integer): Integer; cdecl;
  al_ustr_has_prefix: function(const u: PALLEGRO_USTR; const v: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_has_prefix_cstr: function(const u: PALLEGRO_USTR; const s: PUTF8Char): Boolean; cdecl;
  al_ustr_has_suffix: function(const u: PALLEGRO_USTR; const v: PALLEGRO_USTR): Boolean; cdecl;
  al_ustr_has_suffix_cstr: function(const us1: PALLEGRO_USTR; const s: PUTF8Char): Boolean; cdecl;
  al_utf8_width: function(c: Int32): NativeUInt; cdecl;
  al_utf8_encode: function(s: PUTF8Char; c: Int32): NativeUInt; cdecl;
  al_ustr_new_from_utf16: function(const s: PUInt16): PALLEGRO_USTR; cdecl;
  al_ustr_size_utf16: function(const us: PALLEGRO_USTR): NativeUInt; cdecl;
  al_ustr_encode_utf16: function(const us: PALLEGRO_USTR; s: PUInt16; n: NativeUInt): NativeUInt; cdecl;
  al_utf16_width: function(c: Integer): NativeUInt; cdecl;
  al_utf16_encode: function(s: PUInt16; c: Int32): NativeUInt; cdecl;
  al_create_path: function(const str: PUTF8Char): PALLEGRO_PATH; cdecl;
  al_create_path_for_directory: function(const str: PUTF8Char): PALLEGRO_PATH; cdecl;
  al_clone_path: function(const path: PALLEGRO_PATH): PALLEGRO_PATH; cdecl;
  al_get_path_num_components: function(const path: PALLEGRO_PATH): Integer; cdecl;
  al_get_path_component: function(const path: PALLEGRO_PATH; i: Integer): PUTF8Char; cdecl;
  al_replace_path_component: procedure(path: PALLEGRO_PATH; i: Integer; const s: PUTF8Char); cdecl;
  al_remove_path_component: procedure(path: PALLEGRO_PATH; i: Integer); cdecl;
  al_insert_path_component: procedure(path: PALLEGRO_PATH; i: Integer; const s: PUTF8Char); cdecl;
  al_get_path_tail: function(const path: PALLEGRO_PATH): PUTF8Char; cdecl;
  al_drop_path_tail: procedure(path: PALLEGRO_PATH); cdecl;
  al_append_path_component: procedure(path: PALLEGRO_PATH; const s: PUTF8Char); cdecl;
  al_join_paths: function(path: PALLEGRO_PATH; const tail: PALLEGRO_PATH): Boolean; cdecl;
  al_rebase_path: function(const head: PALLEGRO_PATH; tail: PALLEGRO_PATH): Boolean; cdecl;
  al_path_cstr: function(const path: PALLEGRO_PATH; delim: UTF8Char): PUTF8Char; cdecl;
  al_path_ustr: function(const path: PALLEGRO_PATH; delim: UTF8Char): PALLEGRO_USTR; cdecl;
  al_destroy_path: procedure(path: PALLEGRO_PATH); cdecl;
  al_set_path_drive: procedure(path: PALLEGRO_PATH; const drive: PUTF8Char); cdecl;
  al_get_path_drive: function(const path: PALLEGRO_PATH): PUTF8Char; cdecl;
  al_set_path_filename: procedure(path: PALLEGRO_PATH; const filename: PUTF8Char); cdecl;
  al_get_path_filename: function(const path: PALLEGRO_PATH): PUTF8Char; cdecl;
  al_get_path_extension: function(const path: PALLEGRO_PATH): PUTF8Char; cdecl;
  al_set_path_extension: function(path: PALLEGRO_PATH; const extension: PUTF8Char): Boolean; cdecl;
  al_get_path_basename: function(const path: PALLEGRO_PATH): PUTF8Char; cdecl;
  al_make_path_canonical: function(path: PALLEGRO_PATH): Boolean; cdecl;
  al_fopen: function(const path: PUTF8Char; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  al_fopen_interface: function(const vt: PALLEGRO_FILE_INTERFACE; const path: PUTF8Char; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  al_create_file_handle: function(const vt: PALLEGRO_FILE_INTERFACE; userdata: Pointer): PALLEGRO_FILE; cdecl;
  al_fclose: function(f: PALLEGRO_FILE): Boolean; cdecl;
  al_fread: function(f: PALLEGRO_FILE; ptr: Pointer; size: NativeUInt): NativeUInt; cdecl;
  al_fwrite: function(f: PALLEGRO_FILE; const ptr: Pointer; size: NativeUInt): NativeUInt; cdecl;
  al_fflush: function(f: PALLEGRO_FILE): Boolean; cdecl;
  al_ftell: function(f: PALLEGRO_FILE): Int64; cdecl;
  al_fseek: function(f: PALLEGRO_FILE; offset: Int64; whence: Integer): Boolean; cdecl;
  al_feof: function(f: PALLEGRO_FILE): Boolean; cdecl;
  al_ferror: function(f: PALLEGRO_FILE): Integer; cdecl;
  al_ferrmsg: function(f: PALLEGRO_FILE): PUTF8Char; cdecl;
  al_fclearerr: procedure(f: PALLEGRO_FILE); cdecl;
  al_fungetc: function(f: PALLEGRO_FILE; c: Integer): Integer; cdecl;
  al_fsize: function(f: PALLEGRO_FILE): Int64; cdecl;
  al_fgetc: function(f: PALLEGRO_FILE): Integer; cdecl;
  al_fputc: function(f: PALLEGRO_FILE; c: Integer): Integer; cdecl;
  al_fread16le: function(f: PALLEGRO_FILE): Int16; cdecl;
  al_fread16be: function(f: PALLEGRO_FILE): Int16; cdecl;
  al_fwrite16le: function(f: PALLEGRO_FILE; w: Int16): NativeUInt; cdecl;
  al_fwrite16be: function(f: PALLEGRO_FILE; w: Int16): NativeUInt; cdecl;
  al_fread32le: function(f: PALLEGRO_FILE): Int32; cdecl;
  al_fread32be: function(f: PALLEGRO_FILE): Int32; cdecl;
  al_fwrite32le: function(f: PALLEGRO_FILE; l: Int32): NativeUInt; cdecl;
  al_fwrite32be: function(f: PALLEGRO_FILE; l: Int32): NativeUInt; cdecl;
  al_fgets: function(f: PALLEGRO_FILE; const p: PUTF8Char; max: NativeUInt): PUTF8Char; cdecl;
  al_fget_ustr: function(f: PALLEGRO_FILE): PALLEGRO_USTR; cdecl;
  al_fputs: function(f: PALLEGRO_FILE; const p: PUTF8Char): Integer; cdecl;
  al_fprintf: function(f: PALLEGRO_FILE; const format: PUTF8Char): Integer varargs; cdecl;
  al_vfprintf: function(f: PALLEGRO_FILE; const format: PUTF8Char; args: Pointer): Integer; cdecl;
  al_fopen_fd: function(fd: Integer; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  al_make_temp_file: function(const tmpl: PUTF8Char; ret_path: PPALLEGRO_PATH): PALLEGRO_FILE; cdecl;
  al_fopen_slice: function(fp: PALLEGRO_FILE; initial_size: NativeUInt; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  al_get_new_file_interface: function: PALLEGRO_FILE_INTERFACE; cdecl;
  al_set_new_file_interface: procedure(const file_interface: PALLEGRO_FILE_INTERFACE); cdecl;
  al_set_standard_file_interface: procedure; cdecl;
  al_get_file_userdata: function(f: PALLEGRO_FILE): Pointer; cdecl;
  al_register_bitmap_loader: function(const ext: PUTF8Char; loader: ALLEGRO_IIO_LOADER_FUNCTION): Boolean; cdecl;
  al_register_bitmap_saver: function(const ext: PUTF8Char; saver: ALLEGRO_IIO_SAVER_FUNCTION): Boolean; cdecl;
  al_register_bitmap_loader_f: function(const ext: PUTF8Char; fs_loader: ALLEGRO_IIO_FS_LOADER_FUNCTION): Boolean; cdecl;
  al_register_bitmap_saver_f: function(const ext: PUTF8Char; fs_saver: ALLEGRO_IIO_FS_SAVER_FUNCTION): Boolean; cdecl;
  al_register_bitmap_identifier: function(const ext: PUTF8Char; identifier: ALLEGRO_IIO_IDENTIFIER_FUNCTION): Boolean; cdecl;
  al_load_bitmap: function(const filename: PUTF8Char): PALLEGRO_BITMAP; cdecl;
  al_load_bitmap_flags: function(const filename: PUTF8Char; flags: Integer): PALLEGRO_BITMAP; cdecl;
  al_load_bitmap_f: function(fp: PALLEGRO_FILE; const ident: PUTF8Char): PALLEGRO_BITMAP; cdecl;
  al_load_bitmap_flags_f: function(fp: PALLEGRO_FILE; const ident: PUTF8Char; flags: Integer): PALLEGRO_BITMAP; cdecl;
  al_save_bitmap: function(const filename: PUTF8Char; bitmap: PALLEGRO_BITMAP): Boolean; cdecl;
  al_save_bitmap_f: function(fp: PALLEGRO_FILE; const ident: PUTF8Char; bitmap: PALLEGRO_BITMAP): Boolean; cdecl;
  al_identify_bitmap_f: function(fp: PALLEGRO_FILE): PUTF8Char; cdecl;
  al_identify_bitmap: function(const filename: PUTF8Char): PUTF8Char; cdecl;
  al_lock_bitmap: function(bitmap: PALLEGRO_BITMAP; format: Integer; flags: Integer): PALLEGRO_LOCKED_REGION; cdecl;
  al_lock_bitmap_region: function(bitmap: PALLEGRO_BITMAP; x: Integer; y: Integer; width: Integer; height: Integer; format: Integer; flags: Integer): PALLEGRO_LOCKED_REGION; cdecl;
  al_lock_bitmap_blocked: function(bitmap: PALLEGRO_BITMAP; flags: Integer): PALLEGRO_LOCKED_REGION; cdecl;
  al_lock_bitmap_region_blocked: function(bitmap: PALLEGRO_BITMAP; x_block: Integer; y_block: Integer; width_block: Integer; height_block: Integer; flags: Integer): PALLEGRO_LOCKED_REGION; cdecl;
  al_unlock_bitmap: procedure(bitmap: PALLEGRO_BITMAP); cdecl;
  al_is_bitmap_locked: function(bitmap: PALLEGRO_BITMAP): Boolean; cdecl;
  al_set_blender: procedure(op: Integer; source: Integer; dest: Integer); cdecl;
  al_set_blend_color: procedure(color: ALLEGRO_COLOR); cdecl;
  al_get_blender: procedure(op: PInteger; source: PInteger; dest: PInteger); cdecl;
  al_get_blend_color: function: ALLEGRO_COLOR; cdecl;
  al_set_separate_blender: procedure(op: Integer; source: Integer; dest: Integer; alpha_op: Integer; alpha_source: Integer; alpha_dest: Integer); cdecl;
  al_get_separate_blender: procedure(op: PInteger; source: PInteger; dest: PInteger; alpha_op: PInteger; alpha_src: PInteger; alpha_dest: PInteger); cdecl;
  al_init_user_event_source: procedure(p1: PALLEGRO_EVENT_SOURCE); cdecl;
  al_destroy_user_event_source: procedure(p1: PALLEGRO_EVENT_SOURCE); cdecl;
  al_emit_user_event: function(p1: PALLEGRO_EVENT_SOURCE; p2: PALLEGRO_EVENT; dtor: al_emit_user_event_dtor): Boolean; cdecl;
  al_unref_user_event: procedure(p1: PALLEGRO_USER_EVENT); cdecl;
  al_set_event_source_data: procedure(p1: PALLEGRO_EVENT_SOURCE; data: IntPtr); cdecl;
  al_get_event_source_data: function(const p1: PALLEGRO_EVENT_SOURCE): IntPtr; cdecl;
  al_create_event_queue: function: PALLEGRO_EVENT_QUEUE; cdecl;
  al_destroy_event_queue: procedure(p1: PALLEGRO_EVENT_QUEUE); cdecl;
  al_is_event_source_registered: function(p1: PALLEGRO_EVENT_QUEUE; p2: PALLEGRO_EVENT_SOURCE): Boolean; cdecl;
  al_register_event_source: procedure(p1: PALLEGRO_EVENT_QUEUE; p2: PALLEGRO_EVENT_SOURCE); cdecl;
  al_unregister_event_source: procedure(p1: PALLEGRO_EVENT_QUEUE; p2: PALLEGRO_EVENT_SOURCE); cdecl;
  al_pause_event_queue: procedure(p1: PALLEGRO_EVENT_QUEUE; p2: Boolean); cdecl;
  al_is_event_queue_paused: function(const p1: PALLEGRO_EVENT_QUEUE): Boolean; cdecl;
  al_is_event_queue_empty: function(p1: PALLEGRO_EVENT_QUEUE): Boolean; cdecl;
  al_get_next_event: function(p1: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT): Boolean; cdecl;
  al_peek_next_event: function(p1: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT): Boolean; cdecl;
  al_drop_next_event: function(p1: PALLEGRO_EVENT_QUEUE): Boolean; cdecl;
  al_flush_event_queue: procedure(p1: PALLEGRO_EVENT_QUEUE); cdecl;
  al_wait_for_event: procedure(p1: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT); cdecl;
  al_wait_for_event_timed: function(p1: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT; secs: Single): Boolean; cdecl;
  al_wait_for_event_until: function(queue: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT; timeout: PALLEGRO_TIMEOUT): Boolean; cdecl;
  al_set_new_display_refresh_rate: procedure(refresh_rate: Integer); cdecl;
  al_set_new_display_flags: procedure(flags: Integer); cdecl;
  al_get_new_display_refresh_rate: function: Integer; cdecl;
  al_get_new_display_flags: function: Integer; cdecl;
  al_set_new_window_title: procedure(const title: PUTF8Char); cdecl;
  al_get_new_window_title: function: PUTF8Char; cdecl;
  al_get_display_width: function(display: PALLEGRO_DISPLAY): Integer; cdecl;
  al_get_display_height: function(display: PALLEGRO_DISPLAY): Integer; cdecl;
  al_get_display_format: function(display: PALLEGRO_DISPLAY): Integer; cdecl;
  al_get_display_refresh_rate: function(display: PALLEGRO_DISPLAY): Integer; cdecl;
  al_get_display_flags: function(display: PALLEGRO_DISPLAY): Integer; cdecl;
  al_get_display_orientation: function(display: PALLEGRO_DISPLAY): Integer; cdecl;
  al_set_display_flag: function(display: PALLEGRO_DISPLAY; flag: Integer; onoff: Boolean): Boolean; cdecl;
  al_create_display: function(w: Integer; h: Integer): PALLEGRO_DISPLAY; cdecl;
  al_destroy_display: procedure(display: PALLEGRO_DISPLAY); cdecl;
  al_get_current_display: function: PALLEGRO_DISPLAY; cdecl;
  al_set_target_bitmap: procedure(bitmap: PALLEGRO_BITMAP); cdecl;
  al_set_target_backbuffer: procedure(display: PALLEGRO_DISPLAY); cdecl;
  al_get_backbuffer: function(display: PALLEGRO_DISPLAY): PALLEGRO_BITMAP; cdecl;
  al_get_target_bitmap: function: PALLEGRO_BITMAP; cdecl;
  al_acknowledge_resize: function(display: PALLEGRO_DISPLAY): Boolean; cdecl;
  al_resize_display: function(display: PALLEGRO_DISPLAY; width: Integer; height: Integer): Boolean; cdecl;
  al_flip_display: procedure; cdecl;
  al_update_display_region: procedure(x: Integer; y: Integer; width: Integer; height: Integer); cdecl;
  al_is_compatible_bitmap: function(bitmap: PALLEGRO_BITMAP): Boolean; cdecl;
  al_wait_for_vsync: function: Boolean; cdecl;
  al_get_display_event_source: function(display: PALLEGRO_DISPLAY): PALLEGRO_EVENT_SOURCE; cdecl;
  al_set_display_icon: procedure(display: PALLEGRO_DISPLAY; icon: PALLEGRO_BITMAP); cdecl;
  al_set_display_icons: procedure(display: PALLEGRO_DISPLAY; num_icons: Integer; icons: PPALLEGRO_BITMAP); cdecl;
  al_get_new_display_adapter: function: Integer; cdecl;
  al_set_new_display_adapter: procedure(adapter: Integer); cdecl;
  al_set_new_window_position: procedure(x: Integer; y: Integer); cdecl;
  al_get_new_window_position: procedure(x: PInteger; y: PInteger); cdecl;
  al_set_window_position: procedure(display: PALLEGRO_DISPLAY; x: Integer; y: Integer); cdecl;
  al_get_window_position: procedure(display: PALLEGRO_DISPLAY; x: PInteger; y: PInteger); cdecl;
  al_set_window_constraints: function(display: PALLEGRO_DISPLAY; min_w: Integer; min_h: Integer; max_w: Integer; max_h: Integer): Boolean; cdecl;
  al_get_window_constraints: function(display: PALLEGRO_DISPLAY; min_w: PInteger; min_h: PInteger; max_w: PInteger; max_h: PInteger): Boolean; cdecl;
  al_apply_window_constraints: procedure(display: PALLEGRO_DISPLAY; onoff: Boolean); cdecl;
  al_set_window_title: procedure(display: PALLEGRO_DISPLAY; const title: PUTF8Char); cdecl;
  al_set_new_display_option: procedure(option: Integer; value: Integer; importance: Integer); cdecl;
  al_get_new_display_option: function(option: Integer; importance: PInteger): Integer; cdecl;
  al_reset_new_display_options: procedure; cdecl;
  al_set_display_option: procedure(display: PALLEGRO_DISPLAY; option: Integer; value: Integer); cdecl;
  al_get_display_option: function(display: PALLEGRO_DISPLAY; option: Integer): Integer; cdecl;
  al_hold_bitmap_drawing: procedure(hold: Boolean); cdecl;
  al_is_bitmap_drawing_held: function: Boolean; cdecl;
  al_acknowledge_drawing_halt: procedure(display: PALLEGRO_DISPLAY); cdecl;
  al_acknowledge_drawing_resume: procedure(display: PALLEGRO_DISPLAY); cdecl;
  al_backup_dirty_bitmaps: procedure(display: PALLEGRO_DISPLAY); cdecl;
  al_get_clipboard_text: function(display: PALLEGRO_DISPLAY): PUTF8Char; cdecl;
  al_set_clipboard_text: function(display: PALLEGRO_DISPLAY; const text: PUTF8Char): Boolean; cdecl;
  al_clipboard_has_text: function(display: PALLEGRO_DISPLAY): Boolean; cdecl;
  al_create_config: function: PALLEGRO_CONFIG; cdecl;
  al_add_config_section: procedure(config: PALLEGRO_CONFIG; const name: PUTF8Char); cdecl;
  al_set_config_value: procedure(config: PALLEGRO_CONFIG; const section: PUTF8Char; const key: PUTF8Char; const value: PUTF8Char); cdecl;
  al_add_config_comment: procedure(config: PALLEGRO_CONFIG; const section: PUTF8Char; const comment: PUTF8Char); cdecl;
  al_get_config_value: function(const config: PALLEGRO_CONFIG; const section: PUTF8Char; const key: PUTF8Char): PUTF8Char; cdecl;
  al_load_config_file: function(const filename: PUTF8Char): PALLEGRO_CONFIG; cdecl;
  al_load_config_file_f: function(filename: PALLEGRO_FILE): PALLEGRO_CONFIG; cdecl;
  al_save_config_file: function(const filename: PUTF8Char; const config: PALLEGRO_CONFIG): Boolean; cdecl;
  al_save_config_file_f: function(&file: PALLEGRO_FILE; const config: PALLEGRO_CONFIG): Boolean; cdecl;
  al_merge_config_into: procedure(master: PALLEGRO_CONFIG; const add: PALLEGRO_CONFIG); cdecl;
  al_merge_config: function(const cfg1: PALLEGRO_CONFIG; const cfg2: PALLEGRO_CONFIG): PALLEGRO_CONFIG; cdecl;
  al_destroy_config: procedure(config: PALLEGRO_CONFIG); cdecl;
  al_remove_config_section: function(config: PALLEGRO_CONFIG; const section: PUTF8Char): Boolean; cdecl;
  al_remove_config_key: function(config: PALLEGRO_CONFIG; const section: PUTF8Char; const key: PUTF8Char): Boolean; cdecl;
  al_get_first_config_section: function(const config: PALLEGRO_CONFIG; iterator: PPALLEGRO_CONFIG_SECTION): PUTF8Char; cdecl;
  al_get_next_config_section: function(iterator: PPALLEGRO_CONFIG_SECTION): PUTF8Char; cdecl;
  al_get_first_config_entry: function(const config: PALLEGRO_CONFIG; const section: PUTF8Char; iterator: PPALLEGRO_CONFIG_ENTRY): PUTF8Char; cdecl;
  al_get_next_config_entry: function(iterator: PPALLEGRO_CONFIG_ENTRY): PUTF8Char; cdecl;
  al_get_cpu_count: function: Integer; cdecl;
  al_get_ram_size: function: Integer; cdecl;
  _al_trace_prefix: function(const channel: PUTF8Char; level: Integer; const &file: PUTF8Char; line: Integer; const &function: PUTF8Char): Boolean; cdecl;
  _al_trace_suffix: procedure(const msg: PUTF8Char) varargs; cdecl;
  al_register_assert_handler: procedure(handler: al_register_assert_handler_handler); cdecl;
  al_register_trace_handler: procedure(handler: al_register_trace_handler_handler); cdecl;
  al_clear_to_color: procedure(color: ALLEGRO_COLOR); cdecl;
  al_clear_depth_buffer: procedure(x: Single); cdecl;
  al_draw_pixel: procedure(x: Single; y: Single; color: ALLEGRO_COLOR); cdecl;
  al_get_errno: function: Integer; cdecl;
  al_set_errno: procedure(errnum: Integer); cdecl;
  al_fixsqrt: function(x: al_fixed): al_fixed; cdecl;
  al_fixhypot: function(x: al_fixed; y: al_fixed): al_fixed; cdecl;
  al_fixatan: function(x: al_fixed): al_fixed; cdecl;
  al_fixatan2: function(y: al_fixed; x: al_fixed): al_fixed; cdecl;
  al_create_fs_entry: function(const path: PUTF8Char): PALLEGRO_FS_ENTRY; cdecl;
  al_destroy_fs_entry: procedure(e: PALLEGRO_FS_ENTRY); cdecl;
  al_get_fs_entry_name: function(e: PALLEGRO_FS_ENTRY): PUTF8Char; cdecl;
  al_update_fs_entry: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
  al_get_fs_entry_mode: function(e: PALLEGRO_FS_ENTRY): UInt32; cdecl;
  al_get_fs_entry_atime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
  al_get_fs_entry_mtime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
  al_get_fs_entry_ctime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
  al_get_fs_entry_size: function(e: PALLEGRO_FS_ENTRY): off_t; cdecl;
  al_fs_entry_exists: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
  al_remove_fs_entry: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
  al_open_directory: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
  al_read_directory: function(e: PALLEGRO_FS_ENTRY): PALLEGRO_FS_ENTRY; cdecl;
  al_close_directory: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
  al_filename_exists: function(const path: PUTF8Char): Boolean; cdecl;
  al_remove_filename: function(const path: PUTF8Char): Boolean; cdecl;
  al_get_current_directory: function: PUTF8Char; cdecl;
  al_change_directory: function(const path: PUTF8Char): Boolean; cdecl;
  al_make_directory: function(const path: PUTF8Char): Boolean; cdecl;
  al_open_fs_entry: function(e: PALLEGRO_FS_ENTRY; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  al_for_each_fs_entry: function(dir: PALLEGRO_FS_ENTRY; callback: al_for_each_fs_entry_callback; extra: Pointer): Integer; cdecl;
  al_get_fs_interface: function: PALLEGRO_FS_INTERFACE; cdecl;
  al_set_fs_interface: procedure(const vtable: PALLEGRO_FS_INTERFACE); cdecl;
  al_set_standard_fs_interface: procedure; cdecl;
  al_get_num_display_modes: function: Integer; cdecl;
  al_get_display_mode: function(index: Integer; mode: PALLEGRO_DISPLAY_MODE): PALLEGRO_DISPLAY_MODE; cdecl;
  al_install_joystick: function: Boolean; cdecl;
  al_uninstall_joystick: procedure; cdecl;
  al_is_joystick_installed: function: Boolean; cdecl;
  al_reconfigure_joysticks: function: Boolean; cdecl;
  al_get_num_joysticks: function: Integer; cdecl;
  al_get_joystick: function(joyn: Integer): PALLEGRO_JOYSTICK; cdecl;
  al_release_joystick: procedure(p1: PALLEGRO_JOYSTICK); cdecl;
  al_get_joystick_active: function(p1: PALLEGRO_JOYSTICK): Boolean; cdecl;
  al_get_joystick_name: function(p1: PALLEGRO_JOYSTICK): PUTF8Char; cdecl;
  al_get_joystick_num_sticks: function(p1: PALLEGRO_JOYSTICK): Integer; cdecl;
  al_get_joystick_stick_flags: function(p1: PALLEGRO_JOYSTICK; stick: Integer): Integer; cdecl;
  al_get_joystick_stick_name: function(p1: PALLEGRO_JOYSTICK; stick: Integer): PUTF8Char; cdecl;
  al_get_joystick_num_axes: function(p1: PALLEGRO_JOYSTICK; stick: Integer): Integer; cdecl;
  al_get_joystick_axis_name: function(p1: PALLEGRO_JOYSTICK; stick: Integer; axis: Integer): PUTF8Char; cdecl;
  al_get_joystick_num_buttons: function(p1: PALLEGRO_JOYSTICK): Integer; cdecl;
  al_get_joystick_button_name: function(p1: PALLEGRO_JOYSTICK; buttonn: Integer): PUTF8Char; cdecl;
  al_get_joystick_state: procedure(p1: PALLEGRO_JOYSTICK; ret_state: PALLEGRO_JOYSTICK_STATE); cdecl;
  al_get_joystick_event_source: function: PALLEGRO_EVENT_SOURCE; cdecl;
  al_is_keyboard_installed: function: Boolean; cdecl;
  al_install_keyboard: function: Boolean; cdecl;
  al_uninstall_keyboard: procedure; cdecl;
  al_set_keyboard_leds: function(leds: Integer): Boolean; cdecl;
  al_keycode_to_name: function(keycode: Integer): PUTF8Char; cdecl;
  al_get_keyboard_state: procedure(ret_state: PALLEGRO_KEYBOARD_STATE); cdecl;
  al_clear_keyboard_state: procedure(display: PALLEGRO_DISPLAY); cdecl;
  al_key_down: function(const p1: PALLEGRO_KEYBOARD_STATE; keycode: Integer): Boolean; cdecl;
  al_get_keyboard_event_source: function: PALLEGRO_EVENT_SOURCE; cdecl;
  al_is_mouse_installed: function: Boolean; cdecl;
  al_install_mouse: function: Boolean; cdecl;
  al_uninstall_mouse: procedure; cdecl;
  al_get_mouse_num_buttons: function: Cardinal; cdecl;
  al_get_mouse_num_axes: function: Cardinal; cdecl;
  al_set_mouse_xy: function(display: PALLEGRO_DISPLAY; x: Integer; y: Integer): Boolean; cdecl;
  al_set_mouse_z: function(z: Integer): Boolean; cdecl;
  al_set_mouse_w: function(w: Integer): Boolean; cdecl;
  al_set_mouse_axis: function(axis: Integer; value: Integer): Boolean; cdecl;
  al_get_mouse_state: procedure(ret_state: PALLEGRO_MOUSE_STATE); cdecl;
  al_mouse_button_down: function(const state: PALLEGRO_MOUSE_STATE; button: Integer): Boolean; cdecl;
  al_get_mouse_state_axis: function(const state: PALLEGRO_MOUSE_STATE; axis: Integer): Integer; cdecl;
  al_get_mouse_cursor_position: function(ret_x: PInteger; ret_y: PInteger): Boolean; cdecl;
  al_grab_mouse: function(display: PALLEGRO_DISPLAY): Boolean; cdecl;
  al_ungrab_mouse: function: Boolean; cdecl;
  al_set_mouse_wheel_precision: procedure(precision: Integer); cdecl;
  al_get_mouse_wheel_precision: function: Integer; cdecl;
  al_get_mouse_event_source: function: PALLEGRO_EVENT_SOURCE; cdecl;
  al_is_touch_input_installed: function: Boolean; cdecl;
  al_install_touch_input: function: Boolean; cdecl;
  al_uninstall_touch_input: procedure;  cdecl;
  al_get_touch_input_state: procedure(ret_state: PALLEGRO_TOUCH_INPUT_STATE); cdecl;
  al_get_touch_input_event_source: function: PALLEGRO_EVENT_SOURCE; cdecl;
  al_set_mouse_emulation_mode: procedure(mode: Integer); cdecl;
  al_get_mouse_emulation_mode: function: Integer; cdecl;
  al_get_touch_input_mouse_emulation_event_source: function: PALLEGRO_EVENT_SOURCE; cdecl;
  al_install_haptic: function: Boolean; cdecl;
  al_uninstall_haptic: procedure; cdecl;
  al_is_haptic_installed: function: Boolean; cdecl;
  al_is_mouse_haptic: function(p1: PALLEGRO_MOUSE): Boolean; cdecl;
  al_is_joystick_haptic: function(p1: PALLEGRO_JOYSTICK): Boolean; cdecl;
  al_is_keyboard_haptic: function(p1: PALLEGRO_KEYBOARD): Boolean; cdecl;
  al_is_display_haptic: function(p1: PALLEGRO_DISPLAY): Boolean; cdecl;
  al_is_touch_input_haptic: function(p1: PALLEGRO_TOUCH_INPUT): Boolean; cdecl;
  al_get_haptic_from_mouse: function(p1: PALLEGRO_MOUSE): PALLEGRO_HAPTIC; cdecl;
  al_get_haptic_from_joystick: function(p1: PALLEGRO_JOYSTICK): PALLEGRO_HAPTIC; cdecl;
  al_get_haptic_from_keyboard: function(p1: PALLEGRO_KEYBOARD): PALLEGRO_HAPTIC; cdecl;
  al_get_haptic_from_display: function(p1: PALLEGRO_DISPLAY): PALLEGRO_HAPTIC; cdecl;
  al_get_haptic_from_touch_input: function(p1: PALLEGRO_TOUCH_INPUT): PALLEGRO_HAPTIC; cdecl;
  al_release_haptic: function(p1: PALLEGRO_HAPTIC): Boolean; cdecl;
  al_is_haptic_active: function(p1: PALLEGRO_HAPTIC): Boolean; cdecl;
  al_get_haptic_capabilities: function(p1: PALLEGRO_HAPTIC): Integer; cdecl;
  al_is_haptic_capable: function(p1: PALLEGRO_HAPTIC; p2: Integer): Boolean; cdecl;
  al_set_haptic_gain: function(p1: PALLEGRO_HAPTIC; p2: Double): Boolean; cdecl;
  al_get_haptic_gain: function(p1: PALLEGRO_HAPTIC): Double; cdecl;
  al_set_haptic_autocenter: function(p1: PALLEGRO_HAPTIC; p2: Double): Boolean; cdecl;
  al_get_haptic_autocenter: function(p1: PALLEGRO_HAPTIC): Double; cdecl;
  al_get_max_haptic_effects: function(p1: PALLEGRO_HAPTIC): Integer; cdecl;
  al_is_haptic_effect_ok: function(p1: PALLEGRO_HAPTIC; p2: PALLEGRO_HAPTIC_EFFECT): Boolean; cdecl;
  al_upload_haptic_effect: function(p1: PALLEGRO_HAPTIC; p2: PALLEGRO_HAPTIC_EFFECT; p3: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl;
  al_play_haptic_effect: function(p1: PALLEGRO_HAPTIC_EFFECT_ID; p2: Integer): Boolean; cdecl;
  al_upload_and_play_haptic_effect: function(p1: PALLEGRO_HAPTIC; p2: PALLEGRO_HAPTIC_EFFECT; p3: PALLEGRO_HAPTIC_EFFECT_ID; p4: Integer): Boolean; cdecl;
  al_stop_haptic_effect: function(p1: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl;
  al_is_haptic_effect_playing: function(p1: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl;
  al_release_haptic_effect: function(p1: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl;
  al_get_haptic_effect_duration: function(p1: PALLEGRO_HAPTIC_EFFECT): Double; cdecl;
  al_rumble_haptic: function(p1: PALLEGRO_HAPTIC; p2: Double; p3: Double; p4: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl;
  al_set_memory_interface: procedure(iface: PALLEGRO_MEMORY_INTERFACE); cdecl;
  al_malloc_with_context: function(n: NativeUInt; line: Integer; const &file: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
  al_free_with_context: procedure(ptr: Pointer; line: Integer; const &file: PUTF8Char; const func: PUTF8Char); cdecl;
  al_realloc_with_context: function(ptr: Pointer; n: NativeUInt; line: Integer; const &file: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
  al_calloc_with_context: function(count: NativeUInt; n: NativeUInt; line: Integer; const &file: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
  al_get_num_video_adapters: function: Integer; cdecl;
  al_get_monitor_info: function(adapter: Integer; info: PALLEGRO_MONITOR_INFO): Boolean; cdecl;
  al_get_monitor_dpi: function(adapter: Integer): Integer; cdecl;
  al_get_monitor_refresh_rate: function(adapter: Integer): Integer; cdecl;
  al_create_mouse_cursor: function(sprite: PALLEGRO_BITMAP; xfocus: Integer; yfocus: Integer): PALLEGRO_MOUSE_CURSOR; cdecl;
  al_destroy_mouse_cursor: procedure(p1: PALLEGRO_MOUSE_CURSOR); cdecl;
  al_set_mouse_cursor: function(display: PALLEGRO_DISPLAY; cursor: PALLEGRO_MOUSE_CURSOR): Boolean; cdecl;
  al_set_system_mouse_cursor: function(display: PALLEGRO_DISPLAY; cursor_id: ALLEGRO_SYSTEM_MOUSE_CURSOR): Boolean; cdecl;
  al_show_mouse_cursor: function(display: PALLEGRO_DISPLAY): Boolean; cdecl;
  al_hide_mouse_cursor: function(display: PALLEGRO_DISPLAY): Boolean; cdecl;
  al_set_render_state: procedure(state: ALLEGRO_RENDER_STATE; value: Integer); cdecl;
  al_use_transform: procedure(const trans: PALLEGRO_TRANSFORM); cdecl;
  al_use_projection_transform: procedure(const trans: PALLEGRO_TRANSFORM); cdecl;
  al_copy_transform: procedure(dest: PALLEGRO_TRANSFORM; const src: PALLEGRO_TRANSFORM); cdecl;
  al_identity_transform: procedure(trans: PALLEGRO_TRANSFORM); cdecl;
  al_build_transform: procedure(trans: PALLEGRO_TRANSFORM; x: Single; y: Single; sx: Single; sy: Single; theta: Single); cdecl;
  al_build_camera_transform: procedure(trans: PALLEGRO_TRANSFORM; position_x: Single; position_y: Single; position_z: Single; look_x: Single; look_y: Single; look_z: Single; up_x: Single; up_y: Single; up_z: Single); cdecl;
  al_translate_transform: procedure(trans: PALLEGRO_TRANSFORM; x: Single; y: Single); cdecl;
  al_translate_transform_3d: procedure(trans: PALLEGRO_TRANSFORM; x: Single; y: Single; z: Single); cdecl;
  al_rotate_transform: procedure(trans: PALLEGRO_TRANSFORM; theta: Single); cdecl;
  al_rotate_transform_3d: procedure(trans: PALLEGRO_TRANSFORM; x: Single; y: Single; z: Single; angle: Single); cdecl;
  al_scale_transform: procedure(trans: PALLEGRO_TRANSFORM; sx: Single; sy: Single); cdecl;
  al_scale_transform_3d: procedure(trans: PALLEGRO_TRANSFORM; sx: Single; sy: Single; sz: Single); cdecl;
  al_transform_coordinates: procedure(const trans: PALLEGRO_TRANSFORM; x: PSingle; y: PSingle); cdecl;
  al_transform_coordinates_3d: procedure(const trans: PALLEGRO_TRANSFORM; x: PSingle; y: PSingle; z: PSingle); cdecl;
  al_transform_coordinates_4d: procedure(const trans: PALLEGRO_TRANSFORM; x: PSingle; y: PSingle; z: PSingle; w: PSingle); cdecl;
  al_transform_coordinates_3d_projective: procedure(const trans: PALLEGRO_TRANSFORM; x: PSingle; y: PSingle; z: PSingle); cdecl;
  al_compose_transform: procedure(trans: PALLEGRO_TRANSFORM; const other: PALLEGRO_TRANSFORM); cdecl;
  al_get_current_transform: function: PALLEGRO_TRANSFORM; cdecl;
  al_get_current_inverse_transform: function: PALLEGRO_TRANSFORM; cdecl;
  al_get_current_projection_transform: function: PALLEGRO_TRANSFORM; cdecl;
  al_invert_transform: procedure(trans: PALLEGRO_TRANSFORM); cdecl;
  al_transpose_transform: procedure(trans: PALLEGRO_TRANSFORM); cdecl;
  al_check_inverse: function(const trans: PALLEGRO_TRANSFORM; tol: Single): Integer; cdecl;
  al_orthographic_transform: procedure(trans: PALLEGRO_TRANSFORM; left: Single; top: Single; n: Single; right: Single; bottom: Single; f: Single); cdecl;
  al_perspective_transform: procedure(trans: PALLEGRO_TRANSFORM; left: Single; top: Single; n: Single; right: Single; bottom: Single; f: Single); cdecl;
  al_horizontal_shear_transform: procedure(trans: PALLEGRO_TRANSFORM; theta: Single); cdecl;
  al_vertical_shear_transform: procedure(trans: PALLEGRO_TRANSFORM; theta: Single); cdecl;
  al_create_shader: function(&platform: ALLEGRO_SHADER_PLATFORM): PALLEGRO_SHADER; cdecl;
  al_attach_shader_source: function(shader: PALLEGRO_SHADER; &type: ALLEGRO_SHADER_TYPE; const source: PUTF8Char): Boolean; cdecl;
  al_attach_shader_source_file: function(shader: PALLEGRO_SHADER; &type: ALLEGRO_SHADER_TYPE; const filename: PUTF8Char): Boolean; cdecl;
  al_build_shader: function(shader: PALLEGRO_SHADER): Boolean; cdecl;
  al_get_shader_log: function(shader: PALLEGRO_SHADER): PUTF8Char; cdecl;
  al_get_shader_platform: function(shader: PALLEGRO_SHADER): ALLEGRO_SHADER_PLATFORM; cdecl;
  al_use_shader: function(shader: PALLEGRO_SHADER): Boolean; cdecl;
  al_destroy_shader: procedure(shader: PALLEGRO_SHADER); cdecl;
  al_set_shader_sampler: function(const name: PUTF8Char; bitmap: PALLEGRO_BITMAP; &unit: Integer): Boolean; cdecl;
  al_set_shader_matrix: function(const name: PUTF8Char; const matrix: PALLEGRO_TRANSFORM): Boolean; cdecl;
  al_set_shader_int: function(const name: PUTF8Char; i: Integer): Boolean; cdecl;
  al_set_shader_float: function(const name: PUTF8Char; f: Single): Boolean; cdecl;
  al_set_shader_int_vector: function(const name: PUTF8Char; num_components: Integer; const i: PInteger; num_elems: Integer): Boolean; cdecl;
  al_set_shader_float_vector: function(const name: PUTF8Char; num_components: Integer; const f: PSingle; num_elems: Integer): Boolean; cdecl;
  al_set_shader_bool: function(const name: PUTF8Char; b: Boolean): Boolean; cdecl;
  al_get_default_shader_source: function(&platform: ALLEGRO_SHADER_PLATFORM; &type: ALLEGRO_SHADER_TYPE): PUTF8Char; cdecl;
  al_install_system: function(version: Integer; atexit_ptr: al_install_system_atexit_ptr): Boolean; cdecl;
  al_uninstall_system: procedure; cdecl;
  al_is_system_installed: function: Boolean; cdecl;
  al_get_system_driver: function: PALLEGRO_SYSTEM; cdecl;
  al_get_system_config: function: PALLEGRO_CONFIG; cdecl;
  al_get_system_id: function: ALLEGRO_SYSTEM_ID; cdecl;
  al_get_standard_path: function(id: Integer): PALLEGRO_PATH; cdecl;
  al_set_exe_name: procedure(const path: PUTF8Char); cdecl;
  al_set_org_name: procedure(const org_name: PUTF8Char); cdecl;
  al_set_app_name: procedure(const app_name: PUTF8Char); cdecl;
  al_get_org_name: function: PUTF8Char; cdecl;
  al_get_app_name: function: PUTF8Char; cdecl;
  al_inhibit_screensaver: function(inhibit: Boolean): Boolean; cdecl;
  al_create_thread: function(proc: al_create_thread_proc; arg: Pointer): PALLEGRO_THREAD; cdecl;
  al_create_thread_with_stacksize: function(proc: al_create_thread_with_stacksize_proc; arg: Pointer; stacksize: NativeUInt): PALLEGRO_THREAD; cdecl;
  al_start_thread: procedure(outer: PALLEGRO_THREAD); cdecl;
  al_join_thread: procedure(outer: PALLEGRO_THREAD; ret_value: PPointer); cdecl;
  al_set_thread_should_stop: procedure(outer: PALLEGRO_THREAD); cdecl;
  al_get_thread_should_stop: function(outer: PALLEGRO_THREAD): Boolean; cdecl;
  al_destroy_thread: procedure(thread: PALLEGRO_THREAD); cdecl;
  al_run_detached_thread: procedure(proc: al_run_detached_thread_proc; arg: Pointer); cdecl;
  al_create_mutex: function: PALLEGRO_MUTEX; cdecl;
  al_create_mutex_recursive: function: PALLEGRO_MUTEX; cdecl;
  al_lock_mutex: procedure(mutex: PALLEGRO_MUTEX); cdecl;
  al_unlock_mutex: procedure(mutex: PALLEGRO_MUTEX); cdecl;
  al_destroy_mutex: procedure(mutex: PALLEGRO_MUTEX); cdecl;
  al_create_cond: function: PALLEGRO_COND; cdecl;
  al_destroy_cond: procedure(cond: PALLEGRO_COND); cdecl;
  al_wait_cond: procedure(cond: PALLEGRO_COND; mutex: PALLEGRO_MUTEX); cdecl;
  al_wait_cond_until: function(cond: PALLEGRO_COND; mutex: PALLEGRO_MUTEX; const timeout: PALLEGRO_TIMEOUT): Integer; cdecl;
  al_broadcast_cond: procedure(cond: PALLEGRO_COND); cdecl;
  al_signal_cond: procedure(cond: PALLEGRO_COND); cdecl;
  al_create_timer: function(speed_secs: Double): PALLEGRO_TIMER; cdecl;
  al_destroy_timer: procedure(timer: PALLEGRO_TIMER); cdecl;
  al_start_timer: procedure(timer: PALLEGRO_TIMER); cdecl;
  al_stop_timer: procedure(timer: PALLEGRO_TIMER); cdecl;
  al_resume_timer: procedure(timer: PALLEGRO_TIMER); cdecl;
  al_get_timer_started: function(const timer: PALLEGRO_TIMER): Boolean; cdecl;
  al_get_timer_speed: function(const timer: PALLEGRO_TIMER): Double; cdecl;
  al_set_timer_speed: procedure(timer: PALLEGRO_TIMER; speed_secs: Double); cdecl;
  al_get_timer_count: function(const timer: PALLEGRO_TIMER): Int64; cdecl;
  al_set_timer_count: procedure(timer: PALLEGRO_TIMER; count: Int64); cdecl;
  al_add_timer_count: procedure(timer: PALLEGRO_TIMER; diff: Int64); cdecl;
  al_get_timer_event_source: function(timer: PALLEGRO_TIMER): PALLEGRO_EVENT_SOURCE; cdecl;
  al_store_state: procedure(state: PALLEGRO_STATE; flags: Integer); cdecl;
  al_restore_state: procedure(const state: PALLEGRO_STATE); cdecl;
  al_create_sample: function(buf: Pointer; samples: Cardinal; freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF; free_buf: Boolean): PALLEGRO_SAMPLE; cdecl;
  al_destroy_sample: procedure(spl: PALLEGRO_SAMPLE); cdecl;
  al_create_sample_instance: function(data: PALLEGRO_SAMPLE): PALLEGRO_SAMPLE_INSTANCE; cdecl;
  al_destroy_sample_instance: procedure(spl: PALLEGRO_SAMPLE_INSTANCE); cdecl;
  al_get_sample_frequency: function(const spl: PALLEGRO_SAMPLE): Cardinal; cdecl;
  al_get_sample_length: function(const spl: PALLEGRO_SAMPLE): Cardinal; cdecl;
  al_get_sample_depth: function(const spl: PALLEGRO_SAMPLE): ALLEGRO_AUDIO_DEPTH; cdecl;
  al_get_sample_channels: function(const spl: PALLEGRO_SAMPLE): ALLEGRO_CHANNEL_CONF; cdecl;
  al_get_sample_data: function(const spl: PALLEGRO_SAMPLE): Pointer; cdecl;
  al_get_sample_instance_frequency: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Cardinal; cdecl;
  al_get_sample_instance_length: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Cardinal; cdecl;
  al_get_sample_instance_position: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Cardinal; cdecl;
  al_get_sample_instance_speed: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Single; cdecl;
  al_get_sample_instance_gain: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Single; cdecl;
  al_get_sample_instance_pan: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Single; cdecl;
  al_get_sample_instance_time: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Single; cdecl;
  al_get_sample_instance_depth: function(const spl: PALLEGRO_SAMPLE_INSTANCE): ALLEGRO_AUDIO_DEPTH; cdecl;
  al_get_sample_instance_channels: function(const spl: PALLEGRO_SAMPLE_INSTANCE): ALLEGRO_CHANNEL_CONF; cdecl;
  al_get_sample_instance_playmode: function(const spl: PALLEGRO_SAMPLE_INSTANCE): ALLEGRO_PLAYMODE; cdecl;
  al_get_sample_instance_playing: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl;
  al_get_sample_instance_attached: function(const spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl;
  al_set_sample_instance_position: function(spl: PALLEGRO_SAMPLE_INSTANCE; val: Cardinal): Boolean; cdecl;
  al_set_sample_instance_length: function(spl: PALLEGRO_SAMPLE_INSTANCE; val: Cardinal): Boolean; cdecl;
  al_set_sample_instance_speed: function(spl: PALLEGRO_SAMPLE_INSTANCE; val: Single): Boolean; cdecl;
  al_set_sample_instance_gain: function(spl: PALLEGRO_SAMPLE_INSTANCE; val: Single): Boolean; cdecl;
  al_set_sample_instance_pan: function(spl: PALLEGRO_SAMPLE_INSTANCE; val: Single): Boolean; cdecl;
  al_set_sample_instance_playmode: function(spl: PALLEGRO_SAMPLE_INSTANCE; val: ALLEGRO_PLAYMODE): Boolean; cdecl;
  al_set_sample_instance_playing: function(spl: PALLEGRO_SAMPLE_INSTANCE; val: Boolean): Boolean; cdecl;
  al_detach_sample_instance: function(spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl;
  al_set_sample: function(spl: PALLEGRO_SAMPLE_INSTANCE; data: PALLEGRO_SAMPLE): Boolean; cdecl;
  al_get_sample: function(spl: PALLEGRO_SAMPLE_INSTANCE): PALLEGRO_SAMPLE; cdecl;
  al_play_sample_instance: function(spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl;
  al_stop_sample_instance: function(spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl;
  al_set_sample_instance_channel_matrix: function(spl: PALLEGRO_SAMPLE_INSTANCE; const matrix: PSingle): Boolean; cdecl;
  al_create_audio_stream: function(buffer_count: NativeUInt; samples: Cardinal; freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF): PALLEGRO_AUDIO_STREAM; cdecl;
  al_destroy_audio_stream: procedure(stream: PALLEGRO_AUDIO_STREAM); cdecl;
  al_drain_audio_stream: procedure(stream: PALLEGRO_AUDIO_STREAM); cdecl;
  al_get_audio_stream_frequency: function(const stream: PALLEGRO_AUDIO_STREAM): Cardinal; cdecl;
  al_get_audio_stream_length: function(const stream: PALLEGRO_AUDIO_STREAM): Cardinal; cdecl;
  al_get_audio_stream_fragments: function(const stream: PALLEGRO_AUDIO_STREAM): Cardinal; cdecl;
  al_get_available_audio_stream_fragments: function(const stream: PALLEGRO_AUDIO_STREAM): Cardinal; cdecl;
  al_get_audio_stream_speed: function(const stream: PALLEGRO_AUDIO_STREAM): Single; cdecl;
  al_get_audio_stream_gain: function(const stream: PALLEGRO_AUDIO_STREAM): Single; cdecl;
  al_get_audio_stream_pan: function(const stream: PALLEGRO_AUDIO_STREAM): Single; cdecl;
  al_get_audio_stream_channels: function(const stream: PALLEGRO_AUDIO_STREAM): ALLEGRO_CHANNEL_CONF; cdecl;
  al_get_audio_stream_depth: function(const stream: PALLEGRO_AUDIO_STREAM): ALLEGRO_AUDIO_DEPTH; cdecl;
  al_get_audio_stream_playmode: function(const stream: PALLEGRO_AUDIO_STREAM): ALLEGRO_PLAYMODE; cdecl;
  al_get_audio_stream_playing: function(const spl: PALLEGRO_AUDIO_STREAM): Boolean; cdecl;
  al_get_audio_stream_attached: function(const spl: PALLEGRO_AUDIO_STREAM): Boolean; cdecl;
  al_get_audio_stream_played_samples: function(const stream: PALLEGRO_AUDIO_STREAM): UInt64; cdecl;
  al_get_audio_stream_fragment: function(const stream: PALLEGRO_AUDIO_STREAM): Pointer; cdecl;
  al_set_audio_stream_speed: function(stream: PALLEGRO_AUDIO_STREAM; val: Single): Boolean; cdecl;
  al_set_audio_stream_gain: function(stream: PALLEGRO_AUDIO_STREAM; val: Single): Boolean; cdecl;
  al_set_audio_stream_pan: function(stream: PALLEGRO_AUDIO_STREAM; val: Single): Boolean; cdecl;
  al_set_audio_stream_playmode: function(stream: PALLEGRO_AUDIO_STREAM; val: ALLEGRO_PLAYMODE): Boolean; cdecl;
  al_set_audio_stream_playing: function(stream: PALLEGRO_AUDIO_STREAM; val: Boolean): Boolean; cdecl;
  al_detach_audio_stream: function(stream: PALLEGRO_AUDIO_STREAM): Boolean; cdecl;
  al_set_audio_stream_fragment: function(stream: PALLEGRO_AUDIO_STREAM; val: Pointer): Boolean; cdecl;
  al_rewind_audio_stream: function(stream: PALLEGRO_AUDIO_STREAM): Boolean; cdecl;
  al_seek_audio_stream_secs: function(stream: PALLEGRO_AUDIO_STREAM; time: Double): Boolean; cdecl;
  al_get_audio_stream_position_secs: function(stream: PALLEGRO_AUDIO_STREAM): Double; cdecl;
  al_get_audio_stream_length_secs: function(stream: PALLEGRO_AUDIO_STREAM): Double; cdecl;
  al_set_audio_stream_loop_secs: function(stream: PALLEGRO_AUDIO_STREAM; start: Double; &end: Double): Boolean; cdecl;
  al_get_audio_stream_event_source: function(stream: PALLEGRO_AUDIO_STREAM): PALLEGRO_EVENT_SOURCE; cdecl;
  al_set_audio_stream_channel_matrix: function(stream: PALLEGRO_AUDIO_STREAM; const matrix: PSingle): Boolean; cdecl;
  al_create_mixer: function(freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF): PALLEGRO_MIXER; cdecl;
  al_destroy_mixer: procedure(mixer: PALLEGRO_MIXER); cdecl;
  al_attach_sample_instance_to_mixer: function(stream: PALLEGRO_SAMPLE_INSTANCE; mixer: PALLEGRO_MIXER): Boolean; cdecl;
  al_attach_audio_stream_to_mixer: function(stream: PALLEGRO_AUDIO_STREAM; mixer: PALLEGRO_MIXER): Boolean; cdecl;
  al_attach_mixer_to_mixer: function(stream: PALLEGRO_MIXER; mixer: PALLEGRO_MIXER): Boolean; cdecl;
  al_set_mixer_postprocess_callback: function(mixer: PALLEGRO_MIXER; cb: al_set_mixer_postprocess_callback_cb; data: Pointer): Boolean; cdecl;
  al_get_mixer_frequency: function(const mixer: PALLEGRO_MIXER): Cardinal; cdecl;
  al_get_mixer_channels: function(const mixer: PALLEGRO_MIXER): ALLEGRO_CHANNEL_CONF; cdecl;
  al_get_mixer_depth: function(const mixer: PALLEGRO_MIXER): ALLEGRO_AUDIO_DEPTH; cdecl;
  al_get_mixer_quality: function(const mixer: PALLEGRO_MIXER): ALLEGRO_MIXER_QUALITY; cdecl;
  al_get_mixer_gain: function(const mixer: PALLEGRO_MIXER): Single; cdecl;
  al_get_mixer_playing: function(const mixer: PALLEGRO_MIXER): Boolean; cdecl;
  al_get_mixer_attached: function(const mixer: PALLEGRO_MIXER): Boolean; cdecl;
  al_set_mixer_frequency: function(mixer: PALLEGRO_MIXER; val: Cardinal): Boolean; cdecl;
  al_set_mixer_quality: function(mixer: PALLEGRO_MIXER; val: ALLEGRO_MIXER_QUALITY): Boolean; cdecl;
  al_set_mixer_gain: function(mixer: PALLEGRO_MIXER; gain: Single): Boolean; cdecl;
  al_set_mixer_playing: function(mixer: PALLEGRO_MIXER; val: Boolean): Boolean; cdecl;
  al_detach_mixer: function(mixer: PALLEGRO_MIXER): Boolean; cdecl;
  al_create_voice: function(freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF): PALLEGRO_VOICE; cdecl;
  al_destroy_voice: procedure(voice: PALLEGRO_VOICE); cdecl;
  al_attach_sample_instance_to_voice: function(stream: PALLEGRO_SAMPLE_INSTANCE; voice: PALLEGRO_VOICE): Boolean; cdecl;
  al_attach_audio_stream_to_voice: function(stream: PALLEGRO_AUDIO_STREAM; voice: PALLEGRO_VOICE): Boolean; cdecl;
  al_attach_mixer_to_voice: function(mixer: PALLEGRO_MIXER; voice: PALLEGRO_VOICE): Boolean; cdecl;
  al_detach_voice: procedure(voice: PALLEGRO_VOICE); cdecl;
  al_get_voice_frequency: function(const voice: PALLEGRO_VOICE): Cardinal; cdecl;
  al_get_voice_position: function(const voice: PALLEGRO_VOICE): Cardinal; cdecl;
  al_get_voice_channels: function(const voice: PALLEGRO_VOICE): ALLEGRO_CHANNEL_CONF; cdecl;
  al_get_voice_depth: function(const voice: PALLEGRO_VOICE): ALLEGRO_AUDIO_DEPTH; cdecl;
  al_get_voice_playing: function(const voice: PALLEGRO_VOICE): Boolean; cdecl;
  al_set_voice_position: function(voice: PALLEGRO_VOICE; val: Cardinal): Boolean; cdecl;
  al_set_voice_playing: function(voice: PALLEGRO_VOICE; val: Boolean): Boolean; cdecl;
  al_install_audio: function: Boolean; cdecl;
  al_uninstall_audio: procedure; cdecl;
  al_is_audio_installed: function: Boolean; cdecl;
  al_get_allegro_audio_version: function: UInt32; cdecl;
  al_get_channel_count: function(conf: ALLEGRO_CHANNEL_CONF): NativeUInt; cdecl;
  al_get_audio_depth_size: function(conf: ALLEGRO_AUDIO_DEPTH): NativeUInt; cdecl;
  al_fill_silence: procedure(buf: Pointer; samples: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF); cdecl;
  al_get_num_audio_output_devices: function: Integer; cdecl;
  al_get_audio_output_device: function(index: Integer): PALLEGRO_AUDIO_DEVICE; cdecl;
  al_get_audio_device_name: function(const device: PALLEGRO_AUDIO_DEVICE): PUTF8Char; cdecl;
  al_reserve_samples: function(reserve_samples: Integer): Boolean; cdecl;
  al_get_default_mixer: function: PALLEGRO_MIXER; cdecl;
  al_set_default_mixer: function(mixer: PALLEGRO_MIXER): Boolean; cdecl;
  al_restore_default_mixer: function: Boolean; cdecl;
  al_play_sample: function(data: PALLEGRO_SAMPLE; gain: Single; pan: Single; speed: Single; loop: ALLEGRO_PLAYMODE; ret_id: PALLEGRO_SAMPLE_ID): Boolean; cdecl;
  al_stop_sample: procedure(spl_id: PALLEGRO_SAMPLE_ID); cdecl;
  al_stop_samples: procedure; cdecl;
  al_get_default_voice: function: PALLEGRO_VOICE; cdecl;
  al_set_default_voice: procedure(voice: PALLEGRO_VOICE); cdecl;
  al_lock_sample_id: function(spl_id: PALLEGRO_SAMPLE_ID): PALLEGRO_SAMPLE_INSTANCE; cdecl;
  al_unlock_sample_id: procedure(spl_id: PALLEGRO_SAMPLE_ID); cdecl;
  al_register_sample_loader: function(const ext: PUTF8Char; loader: al_register_sample_loader_loader): Boolean; cdecl;
  al_register_sample_saver: function(const ext: PUTF8Char; saver: al_register_sample_saver_saver): Boolean; cdecl;
  al_register_audio_stream_loader: function(const ext: PUTF8Char; stream_loader: al_register_audio_stream_loader_stream_loader): Boolean; cdecl;
  al_register_sample_loader_f: function(const ext: PUTF8Char; loader: al_register_sample_loader_f_loader): Boolean; cdecl;
  al_register_sample_saver_f: function(const ext: PUTF8Char; saver: al_register_sample_saver_f_saver): Boolean; cdecl;
  al_register_audio_stream_loader_f: function(const ext: PUTF8Char; stream_loader: al_register_audio_stream_loader_f_stream_loader): Boolean; cdecl;
  al_register_sample_identifier: function(const ext: PUTF8Char; identifier: al_register_sample_identifier_identifier): Boolean; cdecl;
  al_load_sample: function(const filename: PUTF8Char): PALLEGRO_SAMPLE; cdecl;
  al_save_sample: function(const filename: PUTF8Char; spl: PALLEGRO_SAMPLE): Boolean; cdecl;
  al_load_audio_stream: function(const filename: PUTF8Char; buffer_count: NativeUInt; samples: Cardinal): PALLEGRO_AUDIO_STREAM; cdecl;
  al_load_sample_f: function(fp: PALLEGRO_FILE; const ident: PUTF8Char): PALLEGRO_SAMPLE; cdecl;
  al_save_sample_f: function(fp: PALLEGRO_FILE; const ident: PUTF8Char; spl: PALLEGRO_SAMPLE): Boolean; cdecl;
  al_load_audio_stream_f: function(fp: PALLEGRO_FILE; const ident: PUTF8Char; buffer_count: NativeUInt; samples: Cardinal): PALLEGRO_AUDIO_STREAM; cdecl;
  al_identify_sample_f: function(fp: PALLEGRO_FILE): PUTF8Char; cdecl;
  al_identify_sample: function(const filename: PUTF8Char): PUTF8Char; cdecl;
  al_create_audio_recorder: function(fragment_count: NativeUInt; samples: Cardinal; freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF): PALLEGRO_AUDIO_RECORDER; cdecl;
  al_start_audio_recorder: function(r: PALLEGRO_AUDIO_RECORDER): Boolean; cdecl;
  al_stop_audio_recorder: procedure(r: PALLEGRO_AUDIO_RECORDER); cdecl;
  al_is_audio_recorder_recording: function(r: PALLEGRO_AUDIO_RECORDER): Boolean; cdecl;
  al_get_audio_recorder_event_source: function(r: PALLEGRO_AUDIO_RECORDER): PALLEGRO_EVENT_SOURCE; cdecl;
  al_get_audio_recorder_event: function(event: PALLEGRO_EVENT): PALLEGRO_AUDIO_RECORDER_EVENT; cdecl;
  al_destroy_audio_recorder: procedure(r: PALLEGRO_AUDIO_RECORDER); cdecl;
  al_init_acodec_addon: function: Boolean; cdecl;
  al_is_acodec_addon_initialized: function: Boolean; cdecl;
  al_get_allegro_acodec_version: function: UInt32; cdecl;
  al_get_allegro_color_version: function: UInt32; cdecl;
  al_color_hsv_to_rgb: procedure(hue: Single; saturation: Single; value: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_hsl: procedure(red: Single; green: Single; blue: Single; hue: PSingle; saturation: PSingle; lightness: PSingle); cdecl;
  al_color_rgb_to_hsv: procedure(red: Single; green: Single; blue: Single; hue: PSingle; saturation: PSingle; value: PSingle); cdecl;
  al_color_hsl_to_rgb: procedure(hue: Single; saturation: Single; lightness: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_name_to_rgb: function(const name: PUTF8Char; r: PSingle; g: PSingle; b: PSingle): Boolean; cdecl;
  al_color_rgb_to_name: function(r: Single; g: Single; b: Single): PUTF8Char; cdecl;
  al_color_cmyk_to_rgb: procedure(cyan: Single; magenta: Single; yellow: Single; key: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_cmyk: procedure(red: Single; green: Single; blue: Single; cyan: PSingle; magenta: PSingle; yellow: PSingle; key: PSingle); cdecl;
  al_color_yuv_to_rgb: procedure(y: Single; u: Single; v: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_yuv: procedure(red: Single; green: Single; blue: Single; y: PSingle; u: PSingle; v: PSingle); cdecl;
  al_color_rgb_to_html: procedure(red: Single; green: Single; blue: Single; &string: PUTF8Char); cdecl;
  al_color_html_to_rgb: function(const &string: PUTF8Char; red: PSingle; green: PSingle; blue: PSingle): Boolean; cdecl;
  al_color_yuv: function(y: Single; u: Single; v: Single): ALLEGRO_COLOR; cdecl;
  al_color_cmyk: function(c: Single; m: Single; y: Single; k: Single): ALLEGRO_COLOR; cdecl;
  al_color_hsl: function(h: Single; s: Single; l: Single): ALLEGRO_COLOR; cdecl;
  al_color_hsv: function(h: Single; s: Single; v: Single): ALLEGRO_COLOR; cdecl;
  al_color_name: function(const name: PUTF8Char): ALLEGRO_COLOR; cdecl;
  al_color_html: function(const &string: PUTF8Char): ALLEGRO_COLOR; cdecl;
  al_color_xyz_to_rgb: procedure(x: Single; y: Single; z: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_xyz: procedure(red: Single; green: Single; blue: Single; x: PSingle; y: PSingle; z: PSingle); cdecl;
  al_color_xyz: function(x: Single; y: Single; z: Single): ALLEGRO_COLOR; cdecl;
  al_color_lab_to_rgb: procedure(l: Single; a: Single; b: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_lab: procedure(red: Single; green: Single; blue: Single; l: PSingle; a: PSingle; b: PSingle); cdecl;
  al_color_lab: function(l: Single; a: Single; b: Single): ALLEGRO_COLOR; cdecl;
  al_color_xyy_to_rgb: procedure(x: Single; y: Single; y2: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_xyy: procedure(red: Single; green: Single; blue: Single; x: PSingle; y: PSingle; y2: PSingle); cdecl;
  al_color_xyy: function(x: Single; y: Single; y2: Single): ALLEGRO_COLOR; cdecl;
  al_color_distance_ciede2000: function(c1: ALLEGRO_COLOR; c2: ALLEGRO_COLOR): Double; cdecl;
  al_color_lch_to_rgb: procedure(l: Single; c: Single; h: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl;
  al_color_rgb_to_lch: procedure(red: Single; green: Single; blue: Single; l: PSingle; c: PSingle; h: PSingle); cdecl;
  al_color_lch: function(l: Single; c: Single; h: Single): ALLEGRO_COLOR; cdecl;
  al_is_color_valid: function(color: ALLEGRO_COLOR): Boolean; cdecl;
  al_register_font_loader: function(const ext: PUTF8Char; load: al_register_font_loader_load): Boolean; cdecl;
  al_load_bitmap_font: function(const filename: PUTF8Char): PALLEGRO_FONT; cdecl;
  al_load_bitmap_font_flags: function(const filename: PUTF8Char; flags: Integer): PALLEGRO_FONT; cdecl;
  al_load_font: function(const filename: PUTF8Char; size: Integer; flags: Integer): PALLEGRO_FONT; cdecl;
  al_grab_font_from_bitmap: function(bmp: PALLEGRO_BITMAP; n: Integer; ranges: PInteger): PALLEGRO_FONT; cdecl;
  al_create_builtin_font: function: PALLEGRO_FONT; cdecl;
  al_draw_ustr: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; flags: Integer; const ustr: PALLEGRO_USTR); cdecl;
  al_draw_text: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; flags: Integer; const text: PUTF8Char); cdecl;
  al_draw_justified_text: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x1: Single; x2: Single; y: Single; diff: Single; flags: Integer; const text: PUTF8Char); cdecl;
  al_draw_justified_ustr: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x1: Single; x2: Single; y: Single; diff: Single; flags: Integer; const text: PALLEGRO_USTR); cdecl;
  al_draw_textf: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; flags: Integer; const format: PUTF8Char) varargs; cdecl;
  al_draw_justified_textf: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x1: Single; x2: Single; y: Single; diff: Single; flags: Integer; const format: PUTF8Char) varargs; cdecl;
  al_get_text_width: function(const f: PALLEGRO_FONT; const str: PUTF8Char): Integer; cdecl;
  al_get_ustr_width: function(const f: PALLEGRO_FONT; const ustr: PALLEGRO_USTR): Integer; cdecl;
  al_get_font_line_height: function(const f: PALLEGRO_FONT): Integer; cdecl;
  al_get_font_ascent: function(const f: PALLEGRO_FONT): Integer; cdecl;
  al_get_font_descent: function(const f: PALLEGRO_FONT): Integer; cdecl;
  al_destroy_font: procedure(f: PALLEGRO_FONT); cdecl;
  al_get_ustr_dimensions: procedure(const f: PALLEGRO_FONT; const text: PALLEGRO_USTR; bbx: PInteger; bby: PInteger; bbw: PInteger; bbh: PInteger); cdecl;
  al_get_text_dimensions: procedure(const f: PALLEGRO_FONT; const text: PUTF8Char; bbx: PInteger; bby: PInteger; bbw: PInteger; bbh: PInteger); cdecl;
  al_init_font_addon: function: Boolean; cdecl;
  al_is_font_addon_initialized: function: Boolean; cdecl;
  al_shutdown_font_addon: procedure; cdecl;
  al_get_allegro_font_version: function: UInt32; cdecl;
  al_get_font_ranges: function(font: PALLEGRO_FONT; ranges_count: Integer; ranges: PInteger): Integer; cdecl;
  al_draw_glyph: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; codepoint: Integer); cdecl;
  al_get_glyph_width: function(const f: PALLEGRO_FONT; codepoint: Integer): Integer; cdecl;
  al_get_glyph_dimensions: function(const f: PALLEGRO_FONT; codepoint: Integer; bbx: PInteger; bby: PInteger; bbw: PInteger; bbh: PInteger): Boolean; cdecl;
  al_get_glyph_advance: function(const f: PALLEGRO_FONT; codepoint1: Integer; codepoint2: Integer): Integer; cdecl;
  al_get_glyph: function(const f: PALLEGRO_FONT; prev_codepoint: Integer; codepoint: Integer; glyph: PALLEGRO_GLYPH): Boolean; cdecl;
  al_draw_multiline_text: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; max_width: Single; line_height: Single; flags: Integer; const text: PUTF8Char); cdecl;
  al_draw_multiline_textf: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; max_width: Single; line_height: Single; flags: Integer; const format: PUTF8Char) varargs; cdecl;
  al_draw_multiline_ustr: procedure(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; max_width: Single; line_height: Single; flags: Integer; const text: PALLEGRO_USTR); cdecl;
  al_do_multiline_text: procedure(const font: PALLEGRO_FONT; max_width: Single; const text: PUTF8Char; cb: al_do_multiline_text_cb; extra: Pointer); cdecl;
  al_do_multiline_ustr: procedure(const font: PALLEGRO_FONT; max_width: Single; const ustr: PALLEGRO_USTR; cb: al_do_multiline_ustr_cb; extra: Pointer); cdecl;
  al_set_fallback_font: procedure(font: PALLEGRO_FONT; fallback: PALLEGRO_FONT); cdecl;
  al_get_fallback_font: function(font: PALLEGRO_FONT): PALLEGRO_FONT; cdecl;
  al_init_image_addon: function: Boolean; cdecl;
  al_is_image_addon_initialized: function: Boolean; cdecl;
  al_shutdown_image_addon: procedure; cdecl;
  al_get_allegro_image_version: function: UInt32; cdecl;
  al_open_memfile: function(mem: Pointer; size: Int64; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  al_get_allegro_memfile_version: function: UInt32; cdecl;
  al_init_native_dialog_addon: function: Boolean; cdecl;
  al_is_native_dialog_addon_initialized: function: Boolean; cdecl;
  al_shutdown_native_dialog_addon: procedure; cdecl;
  al_create_native_file_dialog: function(const initial_path: PUTF8Char; const title: PUTF8Char; const patterns: PUTF8Char; mode: Integer): PALLEGRO_FILECHOOSER; cdecl;
  al_show_native_file_dialog: function(display: PALLEGRO_DISPLAY; dialog: PALLEGRO_FILECHOOSER): Boolean; cdecl;
  al_get_native_file_dialog_count: function(const dialog: PALLEGRO_FILECHOOSER): Integer; cdecl;
  al_get_native_file_dialog_path: function(const dialog: PALLEGRO_FILECHOOSER; index: NativeUInt): PUTF8Char; cdecl;
  al_destroy_native_file_dialog: procedure(dialog: PALLEGRO_FILECHOOSER); cdecl;
  al_show_native_message_box: function(display: PALLEGRO_DISPLAY; const title: PUTF8Char; const heading: PUTF8Char; const text: PUTF8Char; const buttons: PUTF8Char; flags: Integer): Integer; cdecl;
  al_open_native_text_log: function(const title: PUTF8Char; flags: Integer): PALLEGRO_TEXTLOG; cdecl;
  al_close_native_text_log: procedure(textlog: PALLEGRO_TEXTLOG); cdecl;
  al_append_native_text_log: procedure(textlog: PALLEGRO_TEXTLOG; const format: PUTF8Char) varargs; cdecl;
  al_get_native_text_log_event_source: function(textlog: PALLEGRO_TEXTLOG): PALLEGRO_EVENT_SOURCE; cdecl;
  al_create_menu: function: PALLEGRO_MENU; cdecl;
  al_create_popup_menu: function: PALLEGRO_MENU; cdecl;
  al_build_menu: function(info: PALLEGRO_MENU_INFO): PALLEGRO_MENU; cdecl;
  al_append_menu_item: function(parent: PALLEGRO_MENU; const title: PUTF8Char; id: UInt16; flags: Integer; icon: PALLEGRO_BITMAP; submenu: PALLEGRO_MENU): Integer; cdecl;
  al_insert_menu_item: function(parent: PALLEGRO_MENU; pos: Integer; const title: PUTF8Char; id: UInt16; flags: Integer; icon: PALLEGRO_BITMAP; submenu: PALLEGRO_MENU): Integer; cdecl;
  al_remove_menu_item: function(menu: PALLEGRO_MENU; pos: Integer): Boolean; cdecl;
  al_clone_menu: function(menu: PALLEGRO_MENU): PALLEGRO_MENU; cdecl;
  al_clone_menu_for_popup: function(menu: PALLEGRO_MENU): PALLEGRO_MENU; cdecl;
  al_destroy_menu: procedure(menu: PALLEGRO_MENU); cdecl;
  al_get_menu_item_caption: function(menu: PALLEGRO_MENU; pos: Integer): PUTF8Char; cdecl;
  al_set_menu_item_caption: procedure(menu: PALLEGRO_MENU; pos: Integer; const caption: PUTF8Char); cdecl;
  al_get_menu_item_flags: function(menu: PALLEGRO_MENU; pos: Integer): Integer; cdecl;
  al_set_menu_item_flags: procedure(menu: PALLEGRO_MENU; pos: Integer; flags: Integer); cdecl;
  al_get_menu_item_icon: function(menu: PALLEGRO_MENU; pos: Integer): PALLEGRO_BITMAP; cdecl;
  al_set_menu_item_icon: procedure(menu: PALLEGRO_MENU; pos: Integer; icon: PALLEGRO_BITMAP); cdecl;
  al_toggle_menu_item_flags: function(menu: PALLEGRO_MENU; pos: Integer; flags: Integer): Integer; cdecl;
  al_find_menu: function(haystack: PALLEGRO_MENU; id: UInt16): PALLEGRO_MENU; cdecl;
  al_find_menu_item: function(haystack: PALLEGRO_MENU; id: UInt16; menu: PPALLEGRO_MENU; index: PInteger): Boolean; cdecl;
  al_get_default_menu_event_source: function: PALLEGRO_EVENT_SOURCE; cdecl;
  al_enable_menu_event_source: function(menu: PALLEGRO_MENU): PALLEGRO_EVENT_SOURCE; cdecl;
  al_disable_menu_event_source: procedure(menu: PALLEGRO_MENU); cdecl;
  al_get_display_menu: function(display: PALLEGRO_DISPLAY): PALLEGRO_MENU; cdecl;
  al_set_display_menu: function(display: PALLEGRO_DISPLAY; menu: PALLEGRO_MENU): Boolean; cdecl;
  al_popup_menu: function(popup: PALLEGRO_MENU; display: PALLEGRO_DISPLAY): Boolean; cdecl;
  al_remove_display_menu: function(display: PALLEGRO_DISPLAY): PALLEGRO_MENU; cdecl;
  al_get_allegro_native_dialog_version: function: UInt32; cdecl;
  al_get_allegro_primitives_version: function: UInt32; cdecl;
  al_init_primitives_addon: function: Boolean; cdecl;
  al_is_primitives_addon_initialized: function: Boolean; cdecl;
  al_shutdown_primitives_addon: procedure; cdecl;
  al_draw_prim: function(const vtxs: Pointer; const decl: PALLEGRO_VERTEX_DECL; texture: PALLEGRO_BITMAP; start: Integer; &end: Integer; &type: Integer): Integer; cdecl;
  al_draw_indexed_prim: function(const vtxs: Pointer; const decl: PALLEGRO_VERTEX_DECL; texture: PALLEGRO_BITMAP; const indices: PInteger; num_vtx: Integer; &type: Integer): Integer; cdecl;
  al_draw_vertex_buffer: function(vertex_buffer: PALLEGRO_VERTEX_BUFFER; texture: PALLEGRO_BITMAP; start: Integer; &end: Integer; &type: Integer): Integer; cdecl;
  al_draw_indexed_buffer: function(vertex_buffer: PALLEGRO_VERTEX_BUFFER; texture: PALLEGRO_BITMAP; index_buffer: PALLEGRO_INDEX_BUFFER; start: Integer; &end: Integer; &type: Integer): Integer; cdecl;
  al_create_vertex_decl: function(const elements: PALLEGRO_VERTEX_ELEMENT; stride: Integer): PALLEGRO_VERTEX_DECL; cdecl;
  al_destroy_vertex_decl: procedure(decl: PALLEGRO_VERTEX_DECL); cdecl;
  al_create_vertex_buffer: function(decl: PALLEGRO_VERTEX_DECL; const initial_data: Pointer; num_vertices: Integer; flags: Integer): PALLEGRO_VERTEX_BUFFER; cdecl;
  al_destroy_vertex_buffer: procedure(buffer: PALLEGRO_VERTEX_BUFFER); cdecl;
  al_lock_vertex_buffer: function(buffer: PALLEGRO_VERTEX_BUFFER; offset: Integer; length: Integer; flags: Integer): Pointer; cdecl;
  al_unlock_vertex_buffer: procedure(buffer: PALLEGRO_VERTEX_BUFFER); cdecl;
  al_get_vertex_buffer_size: function(buffer: PALLEGRO_VERTEX_BUFFER): Integer; cdecl;
  al_create_index_buffer: function(index_size: Integer; const initial_data: Pointer; num_indices: Integer; flags: Integer): PALLEGRO_INDEX_BUFFER; cdecl;
  al_destroy_index_buffer: procedure(buffer: PALLEGRO_INDEX_BUFFER); cdecl;
  al_lock_index_buffer: function(buffer: PALLEGRO_INDEX_BUFFER; offset: Integer; length: Integer; flags: Integer): Pointer; cdecl;
  al_unlock_index_buffer: procedure(buffer: PALLEGRO_INDEX_BUFFER); cdecl;
  al_get_index_buffer_size: function(buffer: PALLEGRO_INDEX_BUFFER): Integer; cdecl;
  al_triangulate_polygon: function(const vertices: PSingle; vertex_stride: NativeUInt; const vertex_counts: PInteger; emit_triangle: al_triangulate_polygon_emit_triangle; userdata: Pointer): Boolean; cdecl;
  al_draw_soft_triangle: procedure(v1: PALLEGRO_VERTEX; v2: PALLEGRO_VERTEX; v3: PALLEGRO_VERTEX; state: UIntPtr; init: al_draw_soft_triangle_init; first: al_draw_soft_triangle_first; step: al_draw_soft_triangle_step; draw: al_draw_soft_triangle_draw); cdecl;
  al_draw_soft_line: procedure(v1: PALLEGRO_VERTEX; v2: PALLEGRO_VERTEX; state: UIntPtr; first: al_draw_soft_line_first; step: al_draw_soft_line_step; draw: al_draw_soft_line_draw); cdecl;
  al_draw_line: procedure(x1: Single; y1: Single; x2: Single; y2: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_draw_triangle: procedure(x1: Single; y1: Single; x2: Single; y2: Single; x3: Single; y3: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_draw_rectangle: procedure(x1: Single; y1: Single; x2: Single; y2: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_draw_rounded_rectangle: procedure(x1: Single; y1: Single; x2: Single; y2: Single; rx: Single; ry: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_calculate_arc: procedure(dest: PSingle; stride: Integer; cx: Single; cy: Single; rx: Single; ry: Single; start_theta: Single; delta_theta: Single; thickness: Single; num_points: Integer); cdecl;
  al_draw_circle: procedure(cx: Single; cy: Single; r: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_draw_ellipse: procedure(cx: Single; cy: Single; rx: Single; ry: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_draw_arc: procedure(cx: Single; cy: Single; r: Single; start_theta: Single; delta_theta: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_draw_elliptical_arc: procedure(cx: Single; cy: Single; rx: Single; ry: Single; start_theta: Single; delta_theta: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_draw_pieslice: procedure(cx: Single; cy: Single; r: Single; start_theta: Single; delta_theta: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_calculate_spline: procedure(dest: PSingle; stride: Integer; points: PSingle; thickness: Single; num_segments: Integer); cdecl;
  al_draw_spline: procedure(points: PSingle; color: ALLEGRO_COLOR; thickness: Single); cdecl;
  al_calculate_ribbon: procedure(dest: PSingle; dest_stride: Integer; const points: PSingle; points_stride: Integer; thickness: Single; num_segments: Integer); cdecl;
  al_draw_ribbon: procedure(const points: PSingle; points_stride: Integer; color: ALLEGRO_COLOR; thickness: Single; num_segments: Integer); cdecl;
  al_draw_filled_triangle: procedure(x1: Single; y1: Single; x2: Single; y2: Single; x3: Single; y3: Single; color: ALLEGRO_COLOR); cdecl;
  al_draw_filled_rectangle: procedure(x1: Single; y1: Single; x2: Single; y2: Single; color: ALLEGRO_COLOR); cdecl;
  al_draw_filled_ellipse: procedure(cx: Single; cy: Single; rx: Single; ry: Single; color: ALLEGRO_COLOR); cdecl;
  al_draw_filled_circle: procedure(cx: Single; cy: Single; r: Single; color: ALLEGRO_COLOR); cdecl;
  al_draw_filled_pieslice: procedure(cx: Single; cy: Single; r: Single; start_theta: Single; delta_theta: Single; color: ALLEGRO_COLOR); cdecl;
  al_draw_filled_rounded_rectangle: procedure(x1: Single; y1: Single; x2: Single; y2: Single; rx: Single; ry: Single; color: ALLEGRO_COLOR); cdecl;
  al_draw_polyline: procedure(const vertices: PSingle; vertex_stride: Integer; vertex_count: Integer; join_style: Integer; cap_style: Integer; color: ALLEGRO_COLOR; thickness: Single; miter_limit: Single); cdecl;
  al_draw_polygon: procedure(const vertices: PSingle; vertex_count: Integer; join_style: Integer; color: ALLEGRO_COLOR; thickness: Single; miter_limit: Single); cdecl;
  al_draw_filled_polygon: procedure(const vertices: PSingle; vertex_count: Integer; color: ALLEGRO_COLOR); cdecl;
  al_draw_filled_polygon_with_holes: procedure(const vertices: PSingle; const vertex_counts: PInteger; color: ALLEGRO_COLOR); cdecl;
  al_load_ttf_font: function(const filename: PUTF8Char; size: Integer; flags: Integer): PALLEGRO_FONT; cdecl;
  al_load_ttf_font_f: function(&file: PALLEGRO_FILE; const filename: PUTF8Char; size: Integer; flags: Integer): PALLEGRO_FONT; cdecl;
  al_load_ttf_font_stretch: function(const filename: PUTF8Char; w: Integer; h: Integer; flags: Integer): PALLEGRO_FONT; cdecl;
  al_load_ttf_font_stretch_f: function(&file: PALLEGRO_FILE; const filename: PUTF8Char; w: Integer; h: Integer; flags: Integer): PALLEGRO_FONT; cdecl;
  al_init_ttf_addon: function: Boolean; cdecl;
  al_is_ttf_addon_initialized: function: Boolean; cdecl;
  al_shutdown_ttf_addon: procedure; cdecl;
  al_get_allegro_ttf_version: function: UInt32; cdecl;
  al_open_video: function(const filename: PUTF8Char): PALLEGRO_VIDEO; cdecl;
  al_close_video: procedure(video: PALLEGRO_VIDEO); cdecl;
  al_start_video: procedure(video: PALLEGRO_VIDEO; mixer: PALLEGRO_MIXER); cdecl;
  al_start_video_with_voice: procedure(video: PALLEGRO_VIDEO; voice: PALLEGRO_VOICE); cdecl;
  al_get_video_event_source: function(video: PALLEGRO_VIDEO): PALLEGRO_EVENT_SOURCE; cdecl;
  al_set_video_playing: procedure(video: PALLEGRO_VIDEO; playing: Boolean); cdecl;
  al_is_video_playing: function(video: PALLEGRO_VIDEO): Boolean; cdecl;
  al_get_video_audio_rate: function(video: PALLEGRO_VIDEO): Double; cdecl;
  al_get_video_fps: function(video: PALLEGRO_VIDEO): Double; cdecl;
  al_get_video_scaled_width: function(video: PALLEGRO_VIDEO): Single; cdecl;
  al_get_video_scaled_height: function(video: PALLEGRO_VIDEO): Single; cdecl;
  al_get_video_frame: function(video: PALLEGRO_VIDEO): PALLEGRO_BITMAP; cdecl;
  al_get_video_position: function(video: PALLEGRO_VIDEO; which: ALLEGRO_VIDEO_POSITION_TYPE): Double; cdecl;
  al_seek_video: function(video: PALLEGRO_VIDEO; pos_in_seconds: Double): Boolean; cdecl;
  al_init_video_addon: function: Boolean; cdecl;
  al_is_video_addon_initialized: function: Boolean; cdecl;
  al_shutdown_video_addon: procedure; cdecl;
  al_get_allegro_video_version: function: UInt32; cdecl;
  al_identify_video_f: function(fp: PALLEGRO_FILE): PUTF8Char; cdecl;
  al_identify_video: function(const filename: PUTF8Char): PUTF8Char; cdecl;
  al_get_win_window_handle: function(display: PALLEGRO_DISPLAY): HWND; cdecl;
  al_win_add_window_callback: function(display: PALLEGRO_DISPLAY; callback: al_win_add_window_callback_callback; userdata: Pointer): Boolean; cdecl;
  al_win_remove_window_callback: function(display: PALLEGRO_DISPLAY; callback: al_win_remove_window_callback_callback; userdata: Pointer): Boolean; cdecl;
  al_set_physfs_file_interface: procedure; cdecl;
  al_get_allegro_physfs_version: function: UInt32; cdecl;
  _WinMain: function(_main: Pointer; hInst: Pointer; hPrev: Pointer; Cmd: PUTF8Char; nShow: Integer): Integer; cdecl;
    
  // physfs
  PHYSFS_init: function(const argv0: PUTF8Char): Integer; cdecl;
  PHYSFS_deinit: function: Integer; cdecl;
  PHYSFS_mount: function(const newDir: PUTF8Char; const mountPoint: PUTF8Char; appendToPath: Integer): Integer; cdecl;
  PHYSFS_unmount: function(const oldDir: PUTF8Char): Integer; cdecl;

function al_init: Boolean;

{$ENDREGION}

{$REGION '=== SPARK ======================================================================'}
{ --- COMMON ---------------------------------------------------------------- }
const
  SPARK_VERSION = '1.0.alpha1';

  ID_NIL = -1;

  cPNGExt = '.png';
  cLOGExt = '.log';

type
  { THAlign }
  THAlign = (haLeft, haCenter, haRight);

  { TVAlign }
  TVAlign = (vaTop, vaCenter, vaBottom);

  { TLineIntersection }
  TLineIntersection = (liNone, liTrue, liParallel);

{ --- MATH ------------------------------------------------------------------ }
const
  // Degree/Radian conversion
  RAD2DEG = 180.0 / PI;
  DEG2RAD = PI / 180.0;

  { Misc }
  EPSILON = 0.00001;

type
  { TPointi }
  PPointi = ^TPointi;
  TPointi = record
    X, Y: Integer;
  end;

  { TPoint }
  PPointf = ^TPointi;
  TPointf = record
    X, Y: Single;
  end;

  { TRange }
  PRange = ^TRange;
  TRange = record
    MinX, MinY, MaxX, MaxY: Single;
  end;

  { TVector }
  PVector = ^TVector;
  TVector = record
    X,Y,Z: Single;
    constructor Create(aX: Single; aY: Single);
    procedure Assign(aX: Single; aY: Single); overload; inline;
    procedure Assign(aX: Single; aY: Single; aZ: Single); overload; inline;
    procedure Assign(aVector: TVector); overload; inline;
    procedure Clear; inline;
    procedure Add(aVector: TVector); inline;
    procedure Subtract(aVector: TVector); inline;
    procedure Multiply(aVector: TVector); inline;
    procedure Divide(aVector: TVector); inline;
    function  Magnitude: Single; inline;
    function  MagnitudeTruncate(aMaxMagitude: Single): TVector; inline;
    function  Distance(aVector: TVector): Single; inline;
    procedure Normalize; inline;
    function  Angle(aVector: TVector): Single; inline;
    procedure Thrust(aAngle: Single; aSpeed: Single); inline;
    function  MagnitudeSquared: Single; inline;
    function  DotProduct(aVector: TVector): Single; inline;
    procedure Scale(aValue: Single); inline;
    procedure DivideBy(aValue: Single); inline;
    function  Project(aVector: TVector): TVector; inline;
    procedure Negate; inline;
  end;

  { TRectangle }
  PRectangle = ^TRectangle;
  TRectangle = record
    X, Y, Width, Height: Single;
    constructor Create(aX: Single; aY: Single; aWidth: Single; aHeight: Single);
    procedure Assign(aX: Single; aY: Single; aWidth: Single; aHeight: Single); inline;
    function  Intersect(aRect: TRectangle): Boolean; inline;
  end;

{ --- COLOR ----------------------------------------------------------------- }
type
  { TColor }
  PColor = ^TColor;
  TColor = record
    Red, Green, Blue, Alpha: Single;
  end;

const
  ALICEBLUE           : TColor = (Red:$F0/$FF; Green:$F8/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  ANTIQUEWHITE        : TColor = (Red:$FA/$FF; Green:$EB/$FF; Blue:$D7/$FF; Alpha:$FF/$FF);
  AQUA                : TColor = (Red:$00/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  AQUAMARINE          : TColor = (Red:$7F/$FF; Green:$FF/$FF; Blue:$D4/$FF; Alpha:$FF/$FF);
  AZURE               : TColor = (Red:$F0/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  BEIGE               : TColor = (Red:$F5/$FF; Green:$F5/$FF; Blue:$DC/$FF; Alpha:$FF/$FF);
  BISQUE              : TColor = (Red:$FF/$FF; Green:$E4/$FF; Blue:$C4/$FF; Alpha:$FF/$FF);
  BLACK               : TColor = (Red:$00/$FF; Green:$00/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  BLANCHEDALMOND      : TColor = (Red:$FF/$FF; Green:$EB/$FF; Blue:$CD/$FF; Alpha:$FF/$FF);
  BLUE                : TColor = (Red:$00/$FF; Green:$00/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  BLUEVIOLET          : TColor = (Red:$8A/$FF; Green:$2B/$FF; Blue:$E2/$FF; Alpha:$FF/$FF);
  BROWN               : TColor = (Red:$A5/$FF; Green:$2A/$FF; Blue:$2A/$FF; Alpha:$FF/$FF);
  BURLYWOOD           : TColor = (Red:$DE/$FF; Green:$B8/$FF; Blue:$87/$FF; Alpha:$FF/$FF);
  CADETBLUE           : TColor = (Red:$5F/$FF; Green:$9E/$FF; Blue:$A0/$FF; Alpha:$FF/$FF);
  CHARTREUSE          : TColor = (Red:$7F/$FF; Green:$FF/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  CHOCOLATE           : TColor = (Red:$D2/$FF; Green:$69/$FF; Blue:$1E/$FF; Alpha:$FF/$FF);
  CORAL               : TColor = (Red:$FF/$FF; Green:$7F/$FF; Blue:$50/$FF; Alpha:$FF/$FF);
  CORNFLOWERBLUE      : TColor = (Red:$64/$FF; Green:$95/$FF; Blue:$ED/$FF; Alpha:$FF/$FF);
  CORNSILK            : TColor = (Red:$FF/$FF; Green:$F8/$FF; Blue:$DC/$FF; Alpha:$FF/$FF);
  CRIMSON             : TColor = (Red:$DC/$FF; Green:$14/$FF; Blue:$3C/$FF; Alpha:$FF/$FF);
  CYAN                : TColor = (Red:$00/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  DARKBLUE            : TColor = (Red:$00/$FF; Green:$00/$FF; Blue:$8B/$FF; Alpha:$FF/$FF);
  DARKCYAN            : TColor = (Red:$00/$FF; Green:$8B/$FF; Blue:$8B/$FF; Alpha:$FF/$FF);
  DARKGOLDENROD       : TColor = (Red:$B8/$FF; Green:$86/$FF; Blue:$0B/$FF; Alpha:$FF/$FF);
  DARKGRAY            : TColor = (Red:$A9/$FF; Green:$A9/$FF; Blue:$A9/$FF; Alpha:$FF/$FF);
  DARKGREEN           : TColor = (Red:$00/$FF; Green:$64/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  DARKGREY            : TColor = (Red:$A9/$FF; Green:$A9/$FF; Blue:$A9/$FF; Alpha:$FF/$FF);
  DARKKHAKI           : TColor = (Red:$BD/$FF; Green:$B7/$FF; Blue:$6B/$FF; Alpha:$FF/$FF);
  DARKMAGENTA         : TColor = (Red:$8B/$FF; Green:$00/$FF; Blue:$8B/$FF; Alpha:$FF/$FF);
  DARKOLIVEGREEN      : TColor = (Red:$55/$FF; Green:$6B/$FF; Blue:$2F/$FF; Alpha:$FF/$FF);
  DARKORANGE          : TColor = (Red:$FF/$FF; Green:$8C/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  DARKORCHID          : TColor = (Red:$99/$FF; Green:$32/$FF; Blue:$CC/$FF; Alpha:$FF/$FF);
  DARKRED             : TColor = (Red:$8B/$FF; Green:$00/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  DARKSALMON          : TColor = (Red:$E9/$FF; Green:$96/$FF; Blue:$7A/$FF; Alpha:$FF/$FF);
  DARKSEAGREEN        : TColor = (Red:$8F/$FF; Green:$BC/$FF; Blue:$8F/$FF; Alpha:$FF/$FF);
  DARKSLATEBLUE       : TColor = (Red:$48/$FF; Green:$3D/$FF; Blue:$8B/$FF; Alpha:$FF/$FF);
  DARKSLATEGRAY       : TColor = (Red:$2F/$FF; Green:$4F/$FF; Blue:$4F/$FF; Alpha:$FF/$FF);
  DARKSLATEGREY       : TColor = (Red:$2F/$FF; Green:$4F/$FF; Blue:$4F/$FF; Alpha:$FF/$FF);
  DARKTURQUOISE       : TColor = (Red:$00/$FF; Green:$CE/$FF; Blue:$D1/$FF; Alpha:$FF/$FF);
  DARKVIOLET          : TColor = (Red:$94/$FF; Green:$00/$FF; Blue:$D3/$FF; Alpha:$FF/$FF);
  DEEPPINK            : TColor = (Red:$FF/$FF; Green:$14/$FF; Blue:$93/$FF; Alpha:$FF/$FF);
  DEEPSKYBLUE         : TColor = (Red:$00/$FF; Green:$BF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  DIMGRAY             : TColor = (Red:$69/$FF; Green:$69/$FF; Blue:$69/$FF; Alpha:$FF/$FF);
  DIMGREY             : TColor = (Red:$69/$FF; Green:$69/$FF; Blue:$69/$FF; Alpha:$FF/$FF);
  DODGERBLUE          : TColor = (Red:$1E/$FF; Green:$90/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  FIREBRICK           : TColor = (Red:$B2/$FF; Green:$22/$FF; Blue:$22/$FF; Alpha:$FF/$FF);
  FLORALWHITE         : TColor = (Red:$FF/$FF; Green:$FA/$FF; Blue:$F0/$FF; Alpha:$FF/$FF);
  FORESTGREEN         : TColor = (Red:$22/$FF; Green:$8B/$FF; Blue:$22/$FF; Alpha:$FF/$FF);
  FUCHSIA             : TColor = (Red:$FF/$FF; Green:$00/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  GAINSBORO           : TColor = (Red:$DC/$FF; Green:$DC/$FF; Blue:$DC/$FF; Alpha:$FF/$FF);
  GHOSTWHITE          : TColor = (Red:$F8/$FF; Green:$F8/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  GOLD                : TColor = (Red:$FF/$FF; Green:$D7/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  GOLDENROD           : TColor = (Red:$DA/$FF; Green:$A5/$FF; Blue:$20/$FF; Alpha:$FF/$FF);
  GRAY                : TColor = (Red:$80/$FF; Green:$80/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  GREEN               : TColor = (Red:$00/$FF; Green:$80/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  GREENYELLOW         : TColor = (Red:$AD/$FF; Green:$FF/$FF; Blue:$2F/$FF; Alpha:$FF/$FF);
  GREY                : TColor = (Red:$80/$FF; Green:$80/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  HONEYDEW            : TColor = (Red:$F0/$FF; Green:$FF/$FF; Blue:$F0/$FF; Alpha:$FF/$FF);
  HOTPINK             : TColor = (Red:$FF/$FF; Green:$69/$FF; Blue:$B4/$FF; Alpha:$FF/$FF);
  INDIANRED           : TColor = (Red:$CD/$FF; Green:$5C/$FF; Blue:$5C/$FF; Alpha:$FF/$FF);
  INDIGO              : TColor = (Red:$4B/$FF; Green:$00/$FF; Blue:$82/$FF; Alpha:$FF/$FF);
  IVORY               : TColor = (Red:$FF/$FF; Green:$FF/$FF; Blue:$F0/$FF; Alpha:$FF/$FF);
  KHAKI               : TColor = (Red:$F0/$FF; Green:$E6/$FF; Blue:$8C/$FF; Alpha:$FF/$FF);
  LAVENDER            : TColor = (Red:$E6/$FF; Green:$E6/$FF; Blue:$FA/$FF; Alpha:$FF/$FF);
  LAVENDERBLUSH       : TColor = (Red:$FF/$FF; Green:$F0/$FF; Blue:$F5/$FF; Alpha:$FF/$FF);
  LAWNGREEN           : TColor = (Red:$7C/$FF; Green:$FC/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  LEMONCHIFFON        : TColor = (Red:$FF/$FF; Green:$FA/$FF; Blue:$CD/$FF; Alpha:$FF/$FF);
  LIGHTBLUE           : TColor = (Red:$AD/$FF; Green:$D8/$FF; Blue:$E6/$FF; Alpha:$FF/$FF);
  LIGHTCORAL          : TColor = (Red:$F0/$FF; Green:$80/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  LIGHTCYAN           : TColor = (Red:$E0/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  LIGHTGOLDENRODYELLOW: TColor = (Red:$FA/$FF; Green:$FA/$FF; Blue:$D2/$FF; Alpha:$FF/$FF);
  LIGHTGRAY           : TColor = (Red:$D3/$FF; Green:$D3/$FF; Blue:$D3/$FF; Alpha:$FF/$FF);
  LIGHTGREEN          : TColor = (Red:$90/$FF; Green:$EE/$FF; Blue:$90/$FF; Alpha:$FF/$FF);
  LIGHTGREY           : TColor = (Red:$D3/$FF; Green:$D3/$FF; Blue:$D3/$FF; Alpha:$FF/$FF);
  LIGHTPINK           : TColor = (Red:$FF/$FF; Green:$B6/$FF; Blue:$C1/$FF; Alpha:$FF/$FF);
  LIGHTSALMON         : TColor = (Red:$FF/$FF; Green:$A0/$FF; Blue:$7A/$FF; Alpha:$FF/$FF);
  LIGHTSEAGREEN       : TColor = (Red:$20/$FF; Green:$B2/$FF; Blue:$AA/$FF; Alpha:$FF/$FF);
  LIGHTSKYBLUE        : TColor = (Red:$87/$FF; Green:$CE/$FF; Blue:$FA/$FF; Alpha:$FF/$FF);
  LIGHTSLATEGRAY      : TColor = (Red:$77/$FF; Green:$88/$FF; Blue:$99/$FF; Alpha:$FF/$FF);
  LIGHTSLATEGREY      : TColor = (Red:$77/$FF; Green:$88/$FF; Blue:$99/$FF; Alpha:$FF/$FF);
  LIGHTSTEELBLUE      : TColor = (Red:$B0/$FF; Green:$C4/$FF; Blue:$DE/$FF; Alpha:$FF/$FF);
  LIGHTYELLOW         : TColor = (Red:$FF/$FF; Green:$FF/$FF; Blue:$E0/$FF; Alpha:$FF/$FF);
  LIME                : TColor = (Red:$00/$FF; Green:$FF/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  LIMEGREEN           : TColor = (Red:$32/$FF; Green:$CD/$FF; Blue:$32/$FF; Alpha:$FF/$FF);
  LINEN               : TColor = (Red:$FA/$FF; Green:$F0/$FF; Blue:$E6/$FF; Alpha:$FF/$FF);
  MAGENTA             : TColor = (Red:$FF/$FF; Green:$00/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  MAROON              : TColor = (Red:$80/$FF; Green:$00/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  MEDIUMAQUAMARINE    : TColor = (Red:$66/$FF; Green:$CD/$FF; Blue:$AA/$FF; Alpha:$FF/$FF);
  MEDIUMBLUE          : TColor = (Red:$00/$FF; Green:$00/$FF; Blue:$CD/$FF; Alpha:$FF/$FF);
  MEDIUMORCHID        : TColor = (Red:$BA/$FF; Green:$55/$FF; Blue:$D3/$FF; Alpha:$FF/$FF);
  MEDIUMPURPLE        : TColor = (Red:$93/$FF; Green:$70/$FF; Blue:$DB/$FF; Alpha:$FF/$FF);
  MEDIUMSEAGREEN      : TColor = (Red:$3C/$FF; Green:$B3/$FF; Blue:$71/$FF; Alpha:$FF/$FF);
  MEDIUMSLATEBLUE     : TColor = (Red:$7B/$FF; Green:$68/$FF; Blue:$EE/$FF; Alpha:$FF/$FF);
  MEDIUMSPRINGGREEN   : TColor = (Red:$00/$FF; Green:$FA/$FF; Blue:$9A/$FF; Alpha:$FF/$FF);
  MEDIUMTURQUOISE     : TColor = (Red:$48/$FF; Green:$D1/$FF; Blue:$CC/$FF; Alpha:$FF/$FF);
  MEDIUMVIOLETRED     : TColor = (Red:$C7/$FF; Green:$15/$FF; Blue:$85/$FF; Alpha:$FF/$FF);
  MIDNIGHTBLUE        : TColor = (Red:$19/$FF; Green:$19/$FF; Blue:$70/$FF; Alpha:$FF/$FF);
  MINTCREAM           : TColor = (Red:$F5/$FF; Green:$FF/$FF; Blue:$FA/$FF; Alpha:$FF/$FF);
  MISTYROSE           : TColor = (Red:$FF/$FF; Green:$E4/$FF; Blue:$E1/$FF; Alpha:$FF/$FF);
  MOCCASIN            : TColor = (Red:$FF/$FF; Green:$E4/$FF; Blue:$B5/$FF; Alpha:$FF/$FF);
  NAVAJOWHITE         : TColor = (Red:$FF/$FF; Green:$DE/$FF; Blue:$AD/$FF; Alpha:$FF/$FF);
  NAVY                : TColor = (Red:$00/$FF; Green:$00/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  OLDLACE             : TColor = (Red:$FD/$FF; Green:$F5/$FF; Blue:$E6/$FF; Alpha:$FF/$FF);
  OLIVE               : TColor = (Red:$80/$FF; Green:$80/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  OLIVEDRAB           : TColor = (Red:$6B/$FF; Green:$8E/$FF; Blue:$23/$FF; Alpha:$FF/$FF);
  ORANGE              : TColor = (Red:$FF/$FF; Green:$A5/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  ORANGERED           : TColor = (Red:$FF/$FF; Green:$45/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  ORCHID              : TColor = (Red:$DA/$FF; Green:$70/$FF; Blue:$D6/$FF; Alpha:$FF/$FF);
  PALEGOLDENROD       : TColor = (Red:$EE/$FF; Green:$E8/$FF; Blue:$AA/$FF; Alpha:$FF/$FF);
  PALEGREEN           : TColor = (Red:$98/$FF; Green:$FB/$FF; Blue:$98/$FF; Alpha:$FF/$FF);
  PALETURQUOISE       : TColor = (Red:$AF/$FF; Green:$EE/$FF; Blue:$EE/$FF; Alpha:$FF/$FF);
  PALEVIOLETRED       : TColor = (Red:$DB/$FF; Green:$70/$FF; Blue:$93/$FF; Alpha:$FF/$FF);
  PAPAYAWHIP          : TColor = (Red:$FF/$FF; Green:$EF/$FF; Blue:$D5/$FF; Alpha:$FF/$FF);
  PEACHPUFF           : TColor = (Red:$FF/$FF; Green:$DA/$FF; Blue:$B9/$FF; Alpha:$FF/$FF);
  PERU                : TColor = (Red:$CD/$FF; Green:$85/$FF; Blue:$3F/$FF; Alpha:$FF/$FF);
  PINK                : TColor = (Red:$FF/$FF; Green:$C0/$FF; Blue:$CB/$FF; Alpha:$FF/$FF);
  PLUM                : TColor = (Red:$DD/$FF; Green:$A0/$FF; Blue:$DD/$FF; Alpha:$FF/$FF);
  POWDERBLUE          : TColor = (Red:$B0/$FF; Green:$E0/$FF; Blue:$E6/$FF; Alpha:$FF/$FF);
  PURPLE              : TColor = (Red:$80/$FF; Green:$00/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  REBECCAPURPLE       : TColor = (Red:$66/$FF; Green:$33/$FF; Blue:$99/$FF; Alpha:$FF/$FF);
  RED                 : TColor = (Red:$FF/$FF; Green:$00/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  ROSYBROWN           : TColor = (Red:$BC/$FF; Green:$8F/$FF; Blue:$8F/$FF; Alpha:$FF/$FF);
  ROYALBLUE           : TColor = (Red:$41/$FF; Green:$69/$FF; Blue:$E1/$FF; Alpha:$FF/$FF);
  SADDLEBROWN         : TColor = (Red:$8B/$FF; Green:$45/$FF; Blue:$13/$FF; Alpha:$FF/$FF);
  SALMON              : TColor = (Red:$FA/$FF; Green:$80/$FF; Blue:$72/$FF; Alpha:$FF/$FF);
  SANDYBROWN          : TColor = (Red:$F4/$FF; Green:$A4/$FF; Blue:$60/$FF; Alpha:$FF/$FF);
  SEAGREEN            : TColor = (Red:$2E/$FF; Green:$8B/$FF; Blue:$57/$FF; Alpha:$FF/$FF);
  SEASHELL            : TColor = (Red:$FF/$FF; Green:$F5/$FF; Blue:$EE/$FF; Alpha:$FF/$FF);
  SIENNA              : TColor = (Red:$A0/$FF; Green:$52/$FF; Blue:$2D/$FF; Alpha:$FF/$FF);
  SILVER              : TColor = (Red:$C0/$FF; Green:$C0/$FF; Blue:$C0/$FF; Alpha:$FF/$FF);
  SKYBLUE             : TColor = (Red:$87/$FF; Green:$CE/$FF; Blue:$EB/$FF; Alpha:$FF/$FF);
  SLATEBLUE           : TColor = (Red:$6A/$FF; Green:$5A/$FF; Blue:$CD/$FF; Alpha:$FF/$FF);
  SLATEGRAY           : TColor = (Red:$70/$FF; Green:$80/$FF; Blue:$90/$FF; Alpha:$FF/$FF);
  SLATEGREY           : TColor = (Red:$70/$FF; Green:$80/$FF; Blue:$90/$FF; Alpha:$FF/$FF);
  SNOW                : TColor = (Red:$FF/$FF; Green:$FA/$FF; Blue:$FA/$FF; Alpha:$FF/$FF);
  SPRINGGREEN         : TColor = (Red:$00/$FF; Green:$FF/$FF; Blue:$7F/$FF; Alpha:$FF/$FF);
  STEELBLUE           : TColor = (Red:$46/$FF; Green:$82/$FF; Blue:$B4/$FF; Alpha:$FF/$FF);
  TAN                 : TColor = (Red:$D2/$FF; Green:$B4/$FF; Blue:$8C/$FF; Alpha:$FF/$FF);
  TEAL                : TColor = (Red:$00/$FF; Green:$80/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  THISTLE             : TColor = (Red:$D8/$FF; Green:$BF/$FF; Blue:$D8/$FF; Alpha:$FF/$FF);
  TOMATO              : TColor = (Red:$FF/$FF; Green:$63/$FF; Blue:$47/$FF; Alpha:$FF/$FF);
  TURQUOISE           : TColor = (Red:$40/$FF; Green:$E0/$FF; Blue:$D0/$FF; Alpha:$FF/$FF);
  VIOLET              : TColor = (Red:$EE/$FF; Green:$82/$FF; Blue:$EE/$FF; Alpha:$FF/$FF);
  WHEAT               : TColor = (Red:$F5/$FF; Green:$DE/$FF; Blue:$B3/$FF; Alpha:$FF/$FF);
  WHITE               : TColor = (Red:$FF/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  WHITESMOKE          : TColor = (Red:$F5/$FF; Green:$F5/$FF; Blue:$F5/$FF; Alpha:$FF/$FF);
  YELLOW              : TColor = (Red:$FF/$FF; Green:$FF/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  YELLOWGREEN         : TColor = (Red:$9A/$FF; Green:$CD/$FF; Blue:$32/$FF; Alpha:$FF/$FF);
  BLANK               : TColor = (Red:$00;     Green:$00;     Blue:$00;     Alpha:$00);
  WHITE2              : TColor = (Red:$F5/$FF; Green:$F5/$FF; Blue:$F5/$FF; Alpha:$FF/$FF);
  RED22               : TColor = (Red:$7E/$FF; Green:$32/$FF; Blue:$3F/$FF; Alpha:255/$FF);
  COLORKEY            : TColor = (Red:$FF/$FF; Green:$00;     Blue:$FF/$FF; Alpha:$FF/$FF);
  OVERLAY1            : TColor = (Red:$00/$FF; Green:$20/$FF; Blue:$29/$FF; Alpha:$B4/$FF);
  OVERLAY2            : TColor = (Red:$01/$FF; Green:$1B/$FF; Blue:$01/$FF; Alpha:255/$FF);
  DIMWHITE            : TColor = (Red:$10/$FF; Green:$10/$FF; Blue:$10/$FF; Alpha:$10/$FF);
  DARKSLATEBROWN      : TColor = (Red:30/255; Green:31/255; Blue:30/255; Alpha:1);

{ --- WINDOW ---------------------------------------------------------------- }
const
  DISPLAY_DEFAULT_DPI = 96;

{ --- VIEWPORT -------------------------------------------------------------- }
type
  { TViewport }
  TViewport = record
    Bitmap: Int64;
    Active: Boolean;
    Pos: TRectangle;
    Half: TVector;
    Angle: Single;
    Center: TVector;
  end;

{ --- INPUT ----------------------------------------------------------------- }
const
  MAX_AXES = 3;
  MAX_STICKS = 16;
  MAX_BUTTONS = 32;

  MOUSE_BUTTON_LEFT = 1;
  MOUSE_BUTTON_RIGHT = 2;
  MOUSE_BUTTON_MIDDLE = 3;

const
  // Keyboard Constants
  KEY_A = 1;
  KEY_B = 2;
  KEY_C = 3;
  KEY_D = 4;
  KEY_E = 5;
  KEY_F = 6;
  KEY_G = 7;
  KEY_H = 8;
  KEY_I = 9;
  KEY_J = 10;
  KEY_K = 11;
  KEY_L = 12;
  KEY_M = 13;
  KEY_N = 14;
  KEY_O = 15;
  KEY_P = 16;
  KEY_Q = 17;
  KEY_R = 18;
  KEY_S = 19;
  KEY_T = 20;
  KEY_U = 21;
  KEY_V = 22;
  KEY_W = 23;
  KEY_X = 24;
  KEY_Y = 25;
  KEY_Z = 26;
  KEY_0 = 27;
  KEY_1 = 28;
  KEY_2 = 29;
  KEY_3 = 30;
  KEY_4 = 31;
  KEY_5 = 32;
  KEY_6 = 33;
  KEY_7 = 34;
  KEY_8 = 35;
  KEY_9 = 36;
  KEY_PAD_0 = 37;
  KEY_PAD_1 = 38;
  KEY_PAD_2 = 39;
  KEY_PAD_3 = 40;
  KEY_PAD_4 = 41;
  KEY_PAD_5 = 42;
  KEY_PAD_6 = 43;
  KEY_PAD_7 = 44;
  KEY_PAD_8 = 45;
  KEY_PAD_9 = 46;
  KEY_F1 = 47;
  KEY_F2 = 48;
  KEY_F3 = 49;
  KEY_F4 = 50;
  KEY_F5 = 51;
  KEY_F6 = 52;
  KEY_F7 = 53;
  KEY_F8 = 54;
  KEY_F9 = 55;
  KEY_F10 = 56;
  KEY_F11 = 57;
  KEY_F12 = 58;
  KEY_ESCAPE = 59;
  KEY_TILDE = 60;
  KEY_MINUS = 61;
  KEY_EQUALS = 62;
  KEY_BACKSPACE = 63;
  KEY_TAB = 64;
  KEY_OPENBRACE = 65;
  KEY_CLOSEBRACE = 66;
  KEY_ENTER = 67;
  KEY_SEMICOLON = 68;
  KEY_QUOTE = 69;
  KEY_BACKSLASH = 70;
  KEY_BACKSLASH2 = 71;
  KEY_COMMA = 72;
  KEY_FULLSTOP = 73;
  KEY_SLASH = 74;
  KEY_SPACE = 75;
  KEY_INSERT = 76;
  KEY_DELETE = 77;
  KEY_HOME = 78;
  KEY_END = 79;
  KEY_PGUP = 80;
  KEY_PGDN = 81;
  KEY_LEFT = 82;
  KEY_RIGHT = 83;
  KEY_UP = 84;
  KEY_DOWN = 85;
  KEY_PAD_SLASH = 86;
  KEY_PAD_ASTERISK = 87;
  KEY_PAD_MINUS = 88;
  KEY_PAD_PLUS = 89;
  KEY_PAD_DELETE = 90;
  KEY_PAD_ENTER = 91;
  KEY_PRINTSCREEN = 92;
  KEY_PAUSE = 93;
  KEY_ABNT_C1 = 94;
  KEY_YEN = 95;
  KEY_KANA = 96;
  KEY_CONVERT = 97;
  KEY_NOCONVERT = 98;
  KEY_AT = 99;
  KEY_CIRCUMFLEX = 100;
  KEY_COLON2 = 101;
  KEY_KANJI = 102;
  KEY_PAD_EQUALS = 103;
  KEY_BACKQUOTE = 104;
  KEY_SEMICOLON2 = 105;
  KEY_COMMAND = 106;
  KEY_BACK = 107;
  KEY_VOLUME_UP = 108;
  KEY_VOLUME_DOWN = 109;
  KEY_SEARCH = 110;
  KEY_DPAD_CENTER = 111;
  KEY_BUTTON_X = 112;
  KEY_BUTTON_Y = 113;
  KEY_DPAD_UP = 114;
  KEY_DPAD_DOWN = 115;
  KEY_DPAD_LEFT = 116;
  KEY_DPAD_RIGHT = 117;
  KEY_SELECT = 118;
  KEY_START = 119;
  KEY_BUTTON_L1 = 120;
  KEY_BUTTON_R1 = 121;
  KEY_BUTTON_L2 = 122;
  KEY_BUTTON_R2 = 123;
  KEY_BUTTON_A = 124;
  KEY_BUTTON_B = 125;
  KEY_THUMBL = 126;
  KEY_THUMBR = 127;
  KEY_UNKNOWN = 128;
  KEY_MODIFIERS = 215;
  KEY_LSHIFT = 215;
  KEY_RSHIFT = 216;
  KEY_LCTRL = 217;
  KEY_RCTRL = 218;
  KEY_ALT = 219;
  KEY_ALTGR = 220;
  KEY_LWIN = 221;
  KEY_RWIN = 222;
  KEY_MENU = 223;
  KEY_SCROLLLOCK = 224;
  KEY_NUMLOCK = 225;
  KEY_CAPSLOCK = 226;
  KEY_MAX = 227;
  KEYMOD_SHIFT = $0001;
  KEYMOD_CTRL = $0002;
  KEYMOD_ALT = $0004;
  KEYMOD_LWIN = $0008;
  KEYMOD_RWIN = $0010;
  KEYMOD_MENU = $0020;
  KEYMOD_COMMAND = $0040;
  KEYMOD_SCROLOCK = $0100;
  KEYMOD_NUMLOCK = $0200;
  KEYMOD_CAPSLOCK = $0400;
  KEYMOD_INALTSEQ = $0800;
  KEYMOD_ACCENT1 = $1000;
  KEYMOD_ACCENT2 = $2000;
  KEYMOD_ACCENT3 = $4000;
  KEYMOD_ACCENT4 = $8000;

const
  // sticks
  JOY_STICK_LS = 0;
  JOY_STICK_RS = 1;
  JOY_STICK_LT = 2;
  JOY_STICK_RT = 3;

  // axes
  JOY_AXES_X = 0;
  JOY_AXES_Y = 1;
  JOY_AXES_Z = 2;

  // buttons
  JOY_BTN_A = 0;
  JOY_BTN_B = 1;
  JOY_BTN_X = 2;
  JOY_BTN_Y = 3;
  JOY_BTN_RB = 4;
  JOY_BTN_LB = 5;
  JOY_BTN_RT = 6;
  JOY_BTN_LT = 7;
  JOY_BTN_BACK = 8;
  JOY_BTN_START = 9;
  JOY_BTN_RDPAD = 10;
  JOY_BTN_LDPAD = 11;
  JOY_BTN_DDPAD = 12;
  JOY_BTN_UDPAD = 13;

type
  { TJoystick }
  TJoystick = record
    Name: string;
    Sticks: Integer;
    Buttons: Integer;
    StickName: array [0 .. MAX_STICKS - 1] of string;
    Axes: array [0 .. MAX_STICKS - 1] of Integer;
    AxesName: array [0 .. MAX_STICKS - 1, 0 .. MAX_AXES - 1] of string;
    Pos: array [0 .. MAX_STICKS - 1, 0 .. MAX_AXES - 1] of Single;
    Button: array [0 .. MAX_BUTTONS - 1] of Boolean;
    ButtonName: array [0 .. MAX_BUTTONS - 1] of string;
    procedure Setup(aNum: Integer);
    function GetPos(aStick: Integer; aAxes: Integer): Single;
    function GetButton(aButton: Integer): Boolean;
  end;

{ --- RENDERING ------------------------------------------------------------- }
const
  BLEND_ZERO = 0;
  BLEND_ONE = 1;
  BLEND_ALPHA = 2;
  BLEND_INVERSE_ALPHA = 3;
  BLEND_SRC_COLOR = 4;
  BLEND_DEST_COLOR = 5;
  BLEND_INVERSE_SRC_COLOR = 6;
  BLEND_INVERSE_DEST_COLOR = 7;
  BLEND_CONST_COLOR = 8;
  BLEND_INVERSE_CONST_COLOR = 9;
  BLEND_ADD = 0;
  BLEND_SRC_MINUS_DEST = 1;
  BLEND_DEST_MINUS_SRC = 2;

type
  { TBlendMode }
  TBlendMode = (bmPreMultipliedAlpha, bmNonPreMultipliedAlpha, bmAdditiveAlpha, bmCopySrcToDest, bmMultiplySrcAndDest);

  { TBlendModeColor }
  TBlendModeColor = (bcColorNormal, bcColorAvgSrcDest);

{ --- BITMAP ---------------------------------------------------------------- }
type
  { TBitmap }
  TBitmap = record
    Handle: PALLEGRO_BITMAP;
    Width: Single;
    Height: Single;
    Locked: Boolean;
    LockedRegion: TRectangle;
    Filename: string;
  end;

  { TBitmapData }
  PBitmapData = ^TBitmapData;
  TBitmapData = record
    Memory: Pointer;
    Format: Integer;
    Pitch: Integer;
    PixelSize: Integer;
  end;

{ --- FONT ------------------------------------------------------------------ }
type
  { TFont }
  TFont = record
    Handle: PALLEGRO_FONT;
    Filename: string;
    Size: Cardinal;
  end;

{ --- AUDIO ----------------------------------------------------------------- }
const
  // audio
  AUDIO_CHANNEL_COUNT   = 16;
  AUDIO_PAN_NONE        = -1000.0;

type
  { TSample }
  TSample = record
    Handle: PALLEGRO_SAMPLE;
  end;

  { TSampleID }
  PSampleID = ^TSampleID;
  TSampleID = record
    Index: Integer;
    Id: Integer;
  end;

{ --- GAME ------------------------------------------------------------------ }
type
  { TGame }
  TGame = class
  private
    constructor Create; virtual;
  protected
    FEvent: ALLEGRO_EVENT;
    FQueue: PALLEGRO_EVENT_QUEUE;
    FTerminated: Boolean;
    FCosTable: array [0 .. 360] of Single;
    FSinTable: array [0 .. 360] of Single;
    FIDCounter: Int64;
    // Window
    FWindow: record
      Handle: PALLEGRO_DISPLAY;
      Ready: Boolean;
      Trans: ALLEGRO_TRANSFORM;
      Size: TVector;
      TransScale: Single;
      TransSize: TRectangle;
      UpScale: Single;
      Fullscreen: Boolean;
      Viewport: Int64;
    end;
    // Audio
    FAudio: record
      Voice: PALLEGRO_VOICE;
      Mixer: PALLEGRO_MIXER;
    end;
    // Timing
    FTimer: record
      LNow: Double;
      Passed: Double;
      Last: Double;
      Accumulator: Double;
      FrameAccumulator: Double;
      DeltaTime: Double;
      FrameCount: Cardinal;
      FrameRate: Cardinal;
      UpdateSpeed: Single;
    end;
    // Input
    FInput: record
      MouseState: ALLEGRO_MOUSE_STATE;
      KeyboardState: ALLEGRO_KEYBOARD_STATE;
      KeyCode: Integer;
      MouseButtons: array [0 .. 256] of Boolean;
      KeyButtons: array [0 .. 256] of Boolean;
      JoyButtons: array [0 .. 256] of Boolean;
      JoyStick: TJoystick;
    end;
    // Hud
    FHud: record
      TextItemPadWidth: Integer;
      Pos: TVector;
    end;
    // Music
    FMusic: record
      Handle: PALLEGRO_AUDIO_STREAM;
    end;
    // Log
    FLog: record
      FormatSettings : TFormatSettings;
      Filename: string;
      Text: Text;
      Buffer: array[Word] of Byte;
      Open: Boolean;
    end;
    FFontList: TDictionary<Int64, TFont>;
    FBitmapList: TDictionary<Int64, TBitmap>;
    FViewportList: TDictionary<Int64, TViewport>;
    FSampleList: TDictionary<Int64, TSample>;
    procedure Startup;
    procedure Shutdown;
    procedure UpdateTiming;
    function GenID: Int64;
    procedure FixupWindow;
    function TransformScale(aFullscreen: Boolean): Single;
    procedure ResizeForDPI;
    procedure LoadDefaultIcon(aWnd: HWND);
    class function  HasConsoleOutput: Boolean;
    procedure OpenLog;
    procedure CloseLog;
  public
    destructor Destroy; override;

    // Log
    procedure Log(const aMsg: string; const aArgs: array of const; aWriteToConsole: Boolean=False);

    // Console
    class procedure ConsolePrint(const aMsg: string; const aArgs: array of const);
    class procedure ConsolePrintLn(const aMsg: string; const aArgs: array of const);

    // Math
    procedure Randomize;
    function  RandomRange(aMin, aMax: Integer): Integer; overload;
    function  RandomRange(aMin, aMax: Single): Single; overload;
    function  RandomBool: Boolean;
    function  GetRandomSeed: Integer;
    procedure SetRandomSeed(aValue: Integer);
    function  AngleCos(aAngle: Integer): Single;
    function  AngleSin(aAngle: Integer): Single;
    function  AngleDifference(aSrcAngle: Single; aDestAngle: Single): Single;
    procedure AngleRotatePos(aAngle: Single; var aX: Single; var aY: Single);
    function  ClipValue(var aValue: Single; aMin: Single; aMax: Single; aWrap: Boolean): Single; overload;
    function  ClipValue(var aValue: Integer; aMin: Integer; aMax: Integer; aWrap: Boolean): Integer; overload;
    function  SameSign(aValue1: Integer; aValue2: Integer): Boolean; overload;
    function  SameSign(aValue1: Single; aValue2: Single): Boolean; overload;
    function  SameValue(aA: Double; aB: Double; aEpsilon: Double = 0): Boolean; overload;
    function  SameValue(aA: Single; aB: Single; aEpsilon: Single = 0): Boolean; overload;
    function  Point(aX: Integer; aY: Integer): TPointi; overload;
    function  Point(aX: Single; aY: Single): TPointf; overload;
    function  Vector(aX: Single; aY: Single): TVector;
    function  Rectangle(aX: Single; aY: Single; aWidth: Single; aHeight: Single): TRectangle;
    procedure SmoothMove(var aValue: Single; aAmount: Single; aMax: Single; aDrag: Single);
    function Lerp(aFrom: Double; aTo: Double; aTime: Double): Double;

    // Collision
    function PointInRectangle(aPoint: TVector; aRect: TRectangle): Boolean;
    function PointInCircle(aPoint, aCenter: TVector; aRadius: Single): Boolean;
    function PointInTriangle(aPoint, aP1, aP2, aP3: TVector): Boolean;
    function CirclesOverlap(aCenter1: TVector; aRadius1: Single; aCenter2: TVector; aRadius2: Single): Boolean;
    function CircleInRectangle(aCenter: TVector; aRadius: Single; aRect: TRectangle): Boolean;
    function RectanglesOverlap(aRect1: TRectangle; aRect2: TRectangle): Boolean;
    function RectangleIntersection(aRect1, aRect2: TRectangle): TRectangle;
    function LineIntersection(aX1, aY1, aX2, aY2, aX3, aY3, aX4, aY4: Integer; var aX: Integer; var aY: Integer): TLineIntersection;
    function RadiusOverlap(aRadius1, aX1, aY1, aRadius2, aX2, aY2, aShrinkFactor: Single): Boolean;

    // Color
    function MakeColor(aRed: Byte; aGreen: Byte; aBlue: Byte; aAlpha: Byte): TColor; overload;
    function MakeColor(aRed: Single; aGreen: Single; aBlue: Single; aAlpha: Single): TColor; overload;
    function MakeColor(const aName: string): TColor; overload;
    function FadeColor(var aFrom: TColor; aTo: TColor; aPos: Single): TColor;
    function ColorEqual(aColor1: TColor; aColor2: TColor): Boolean;

    // Timing
    function  GetTime: Double;
    procedure ResetTiming;
    procedure SetUpdateSpeed(aSpeed: Single);
    function  GetUpdateSpeed: Single;
    function  GetDeltaTime: Double;
    function  GetFrameRate: Cardinal;
    function  FrameSpeed(var aTimer: Single; aSpeed: Single): Boolean;
    function  FrameElapsed(var aTimer: Single; aFrames: Single): Boolean;

    // Window
    function  OpenWindow(aWidth: Integer; aHeight: Integer; aTitle: string; aFullscreen: Boolean=False): Boolean;
    procedure CloseWindow;
    function  IsWindowOpen: Boolean;
    procedure SetWindowTitle(const aTitle: string);
    procedure ClearWindow(aColor: TColor);
    procedure ShowWindow;
    procedure ToggleFullscreenWindow;
    function  IsWindowFullscreen: Boolean;
    procedure SetWindowTarget(aBitmap: Int64);
    procedure ResetWindowTarget;
    procedure SetWindowViewport(aViewport: Int64);
    procedure GetWindowViewportSize(aX: PInteger; aY: PInteger; aWidth: PInteger; aHeight: PInteger); overload;
    procedure GetWindowViewportSize(var aSize: TRectangle); overload;
    procedure GetWindowSize(aWidth: System.PInteger; aHeight: System.PInteger; aAspectRatio: System.PSingle=nil);
    procedure ResetWindowTransform;
    procedure SetWindowTransformPosition(aX: Integer; aY: Integer);
    procedure SetWindowTransformAngle(aAngle: Single);
    function  SaveWindow(const aFilename: string): Boolean;

    // Viewport
    function  CreateViewport(aX: Integer; aY: Integer; aWidth: Integer; aHeight: Integer): Int64;
    procedure DestroyViewport(var aViewport: Int64);
    procedure DestroyAllViewports;
    procedure SetViewportActive(aViewport: Int64; aActive: Boolean);
    function  GetViewportActive(aViewport: Int64): Boolean;
    procedure SetViewportPosition(aViewport: Int64; aX: Integer; aY: Integer);
    procedure GetViewportSize(aViewport: Int64; aX: PInteger; aY: PInteger; aWidth: PInteger; aHeight: PInteger);
    procedure SetViewportAngle(aViewport: Int64; aAngle: Single);
    function  GetViewportAngle(aViewport: Int64): Single;
    procedure AlignViewport(aViewport: Int64; var aX: Single; var aY: Single); overload;
    procedure AlignViewport(aViewport: Int64; var aPos: TVector); overload;
    procedure ResetViewport;

    // Input
    procedure ClearInput;
    function  KeyboardPressed(aKey: Integer): Boolean;
    function  KeyboardReleased(aKey: Integer): Boolean;
    function  KeyboardDown(aKey: Integer): Boolean;
    function  KeyboardGetPressed: Integer;
    function  MousePressed(aButton: Integer): Boolean;
    function  MouseReleased(aButton: Integer): Boolean;
    function  MouseDown(aButton: Integer): Boolean;
    procedure MouseGetInfo(aX: PInteger; aY: PInteger; aWheel: PInteger); overload;
    procedure MouseGetInfo(var aPos: TVector); overload;
    procedure MouseSetPos(aX: Integer; aY: Integer);
    procedure MouseShowCursor(aShow: Boolean);
    function  JoystickPressed(aButton: Integer): Boolean;
    function  JoystickReleased(aButton: Integer): Boolean;
    function  JoystickDown(aButton: Integer): Boolean;
    function  JoystickGetPos(aStick: Integer; aAxes: Integer): Single;

    // Rendering
    procedure DrawLine(aX1, aY1, aX2, aY2: Single; aColor: TColor; aThickness: Single);
    procedure DrawRectangle(aX, aY, aWidth, aHeight, aThickness: Single; aColor: TColor);
    procedure DrawFilledRectangle(aX, aY, aWidth, aHeight: Single; aColor: TColor);
    procedure DrawCircle(aX, aY, aRadius, aThickness: Single;  aColor: TColor);
    procedure DrawFilledCircle(aX, aY, aRadius: Single; aColor: TColor);
    procedure DrawPolygon(aVertices: System.PSingle; aVertexCount: Integer; aThickness: Single; aColor: TColor);
    procedure DrawFilledPolygon(aVertices: System.PSingle; aVertexCount: Integer; aColor: TColor);
    procedure DrawTriangle(aX1, aY1, aX2, aY2, aX3, aY3, aThickness: Single; aColor: TColor);
    procedure DrawFilledTriangle(aX1, aY1, aX2, aY2, aX3, aY3: Single; aColor: TColor);
    procedure SetBlender(aOperation: Integer; aSource: Integer; aDestination: Integer);
    procedure GetBlender(aOperation: PInteger; aSource: PInteger; aDestination: PInteger);
    procedure SetBlendColor(aColor: TColor);
    function  GetBlendColor: TColor;
    procedure SetBlendMode(aMode: TBlendMode);
    procedure SetBlendModeColor(aMode: TBlendModeColor; aColor: TColor);
    procedure RestoreDefaultBlendMode;

    // Font
    function  LoadFont(aSize: Cardinal): Int64; overload;
    function  LoadFont(aSize: Cardinal; const aFilename: string): Int64; overload;
    function  LoadFont(aSize: Cardinal; aMemory: Pointer; aLength: Int64): Int64; overload;
    procedure UnloadFont(var aFont: Int64);
    procedure UnloadAllFonts;
    procedure PrintText(aFont: Int64; aX: Single; aY: Single; aColor: TColor; aAlign: THAlign; const aMsg: string; const aArgs: array of const); overload;
    procedure PrintText(aFont: Int64; aX: Single; var aY: Single; aLineSpace: Single; aColor: TColor; aAlign: THAlign; const aMsg: string; const aArgs: array of const); overload;
    procedure PrintText(aFont: Int64; aX: Single; aY: Single; aColor: TColor; aAngle: Single; const aMsg: string; const aArgs: array of const); overload;
    function  GetTextWidth(aFont: Int64; const aMsg: string; const aArgs: array of const): Single;
    function  GetLineHeight(aFont: Int64): Single;

    // Bitmap
    function  AllocBitmap(aWidth: Integer; aHeight: Integer): Int64;
    function  LoadBitmap(const aFilename: string; aColorKey: PColor): Int64;
    procedure UnloadBitmap(var aBitmap: Int64);
    procedure UnloadAllBitmaps;
    procedure GetBitmapSize(aBitmap: Int64; var aSize: TVector); overload;
    procedure GetBitmapSize(aBitmap: Int64; aWidth: PSingle; aHeight: PSingle); overload;
    procedure LockBitmap(aBitmap: Int64; aRegion: PRectangle; aData: PBitmapData=nil);
    procedure UnlockBitmap(aBitmap: Int64);
    function  GetBitmapPixel(aBitmap: Int64; aX: Integer; aY: Integer): TColor;
    procedure SetBitmapPixel(aBitmap: Int64; aX: Integer; aY: Integer; aColor: TColor);
    procedure DrawBitmap(aBitmap: Int64; aX, aY: Single; aRegion: PRectangle; aCenter: PVector;  aScale: PVector; aAngle: Single; aColor: TColor; aHFlip: Boolean; aVFlip: Boolean); overload;
    procedure DrawBitmap(aBitmap: Int64; aX, aY, aScale, aAngle: Single; aColor: TColor; aHAlign: THAlign; aVAlign: TVAlign; aHFlip: Boolean=False; aVFlip: Boolean=False); overload;
    procedure DrawTiledBitmap(aBitmap: Int64; aDeltaX: Single; aDeltaY: Single);

    // Hud
    procedure HudPos(aX: Integer; aY: Integer);
    procedure HudLineSpace(aLineSpace: Integer);
    procedure HudTextItemPadWidth(aWidth: Integer);
    procedure HudText(aFont: Int64; aColor: TColor; aAlign: THAlign; const aMsg: string; const aArgs: array of const);
    function  HudTextItem(const aKey: string; const aValue: string; const aSeperator: string='-'): string;

    // Archive
    function Mount(const aNewDir: string; const aMountPoint: string; aAppendToPath: Boolean): Boolean;
    function Unmount(const aOldDir: string): Boolean;

    // Audio
    procedure PauseAudio(aPause: Boolean);
    procedure ClearAudio;
    procedure LoadMusic(const aFilename: string);
    procedure UnloadMusic;
    procedure PlayMusic(aVolume: Single; aLoop: Boolean);
    procedure StopMusic;
    function  GetMusicLooping: Boolean;
    procedure SetMusicLooping(aLoop: Boolean);
    function  GetMusicPlaying: Boolean;
    procedure SetMusicPlaying(aPlay: Boolean);
    procedure SetMusicVolume(aVolume: Single);
    function  GetMusicVolume: Single;
    procedure SeekMusic(aTime: Single);
    procedure RewindMusic(aTime: Single);
    function  ReserveSamples(aCount: Integer): Boolean;
    function  LoadSample(const aFilename: string): Int64;
    procedure UnloadSample(var aSample: Int64);
    procedure UnloadAllSamples;
    procedure PlaySample(aSample: Int64; aVolume: Single; aPan: Single; aSpeed: Single; aLoop: Boolean; aId: PSampleID);
    procedure StopSample(aID: TSampleID);
    procedure StopAllSamples;
    function  IsSamplePlaying(aID: TSampleID): Boolean;

    // Game
    procedure SetTerminated(aTerminated: Boolean);
    function  GetTerminated: Boolean;
    procedure OnStartup; virtual;
    procedure OnShutdown; virtual;
    procedure OnClearFrame; virtual;
    procedure OnUpdateFrame(aDeltaTime: Double); virtual;
    procedure OnRenderFrame; virtual;
    procedure OnRenderHUD; virtual;
    procedure OnShowFrame; virtual;
    procedure Run;
  end;

  { TGameClass }
  TGameClass = class of TGame;

var
  Game: TGame = nil;

// Routines
procedure RunGame(aGame: TGameClass);
{$ENDREGION}

implementation

{$REGION '=== MEMORYDLLLOADER ============================================================'}

{ --------------------------------------------------------------------------- }

{ *
  * Memory DLL loading code
  * ------------------------
  *
  * Original C Code
  * Memory DLL loading code
  * Version 0.0.4
  *
  * Copyright (c) 2004-2015 by Joachim Bauch / mail@joachim-bauch.de
  * http://www.joachim-bauch.de
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 2.0 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is MemoryModule.c
  *
  * The Initial Developer of the Original Code is Joachim Bauch.
  *
  * Portions created by Joachim Bauch are Copyright (C) 2004-2015
  * Joachim Bauch. All Rights Reserved.
  *
  * ================== MemoryModule "Conversion to Delphi" ==================
  *
  * Copyright (c) 2015 by Fr0sT / https://github.com/Fr0sT-Brutal
  *
  * Initially based on the code by:
  *   Copyright (c) 2005 - 2006 by Martin Offenwanger / coder@dsplayer.de / http://www.dsplayer.de
  *   Carlo Pasolini / cdpasop@hotmail.it / http://pasotech.altervista.org
  *
  * NOTE
  *   This code is Delphi translation of original C code taken from https://github.com/fancycode/MemoryModule
  *     (commit dc173ca from Mar 1, 2015).
  * }
type
  TMemoryModule = Pointer;

  {$IF NOT DECLARED(IMAGE_BASE_RELOCATION)}
  type
  {$ALIGN 4}
  IMAGE_BASE_RELOCATION = record
    VirtualAddress: DWORD;
    SizeOfBlock: DWORD;
  end;
  {$ALIGN ON}
  PIMAGE_BASE_RELOCATION = ^IMAGE_BASE_RELOCATION;
  {$IFEND}
  {$IF NOT DECLARED(PIMAGE_DATA_DIRECTORY)}
  type PIMAGE_DATA_DIRECTORY = ^IMAGE_DATA_DIRECTORY;
  {$IFEND}
  {$IF NOT DECLARED(PIMAGE_SECTION_HEADER)}
  type PIMAGE_SECTION_HEADER = ^IMAGE_SECTION_HEADER;
  {$IFEND}
  {$IF NOT DECLARED(PIMAGE_EXPORT_DIRECTORY)}
  type PIMAGE_EXPORT_DIRECTORY = ^IMAGE_EXPORT_DIRECTORY;
  {$IFEND}
  {$IF NOT DECLARED(PIMAGE_DOS_HEADER)}
  type PIMAGE_DOS_HEADER = ^IMAGE_DOS_HEADER;
  {$IFEND}
  {$IF NOT DECLARED(PIMAGE_NT_HEADERS)}
  type PIMAGE_NT_HEADERS = ^IMAGE_NT_HEADERS;
  {$IFEND}
  {$IF NOT DECLARED(PUINT_PTR)}
  type PUINT_PTR = ^UINT_PTR;
  {$IFEND}

const
  IMAGE_REL_BASED_ABSOLUTE = 0;
  IMAGE_REL_BASED_HIGHLOW = 3;
  IMAGE_REL_BASED_DIR64 = 10;

{$IFDEF CPUX64}
type
  PIMAGE_TLS_DIRECTORY = PIMAGE_TLS_DIRECTORY64;

const
  IMAGE_ORDINAL_FLAG = IMAGE_ORDINAL_FLAG64;
{$ENDIF}

const
  IMAGE_SIZEOF_BASE_RELOCATION = SizeOf(IMAGE_BASE_RELOCATION);
  {$IFDEF CPUX64}
  HOST_MACHINE = IMAGE_FILE_MACHINE_AMD64;
  {$ELSE}
  HOST_MACHINE = IMAGE_FILE_MACHINE_I386;
  {$ENDIF}

type
  TMemoryModuleRec = record
    Headers: PIMAGE_NT_HEADERS;
    CodeBase: Pointer;
    Modules: array of HMODULE;
    NumModules: Integer;
    Initialized: Boolean;
    IsRelocated: Boolean;
    PageSize: DWORD;
  end;

  PMemoryModule = ^TMemoryModuleRec;

  TDllEntryProc = function(hinstDLL: HINST; fdwReason: DWORD; lpReserved: Pointer): BOOL; stdcall;

  TSectionFinalizeData = record
    Address: Pointer;
    AlignedAddress: Pointer;
    Size: SIZE_T;
    Characteristics: DWORD;
    Last: Boolean;
  end;

function GetProcAddress_Internal(hModule: HMODULE; lpProcName: LPCSTR): FARPROC; stdcall; external kernel32 name 'GetProcAddress';
function LoadLibraryA_Internal(lpLibFileName: LPCSTR): HMODULE; stdcall; external kernel32 name 'LoadLibraryA';
function FreeLibrary_Internal(hLibModule: HMODULE): BOOL; stdcall; external kernel32 name 'FreeLibrary';

procedure Abort;
begin
  raise TObject.Create;
end;

function StrComp(const Str1, Str2: PAnsiChar): Integer;
var
  P1, P2: PAnsiChar;
begin
  P1 := Str1;
  P2 := Str2;
  while True do
  begin
    if (P1^ <> P2^) or (P1^ = #0) then
      Exit(Ord(P1^) - Ord(P2^));
    Inc(P1);
    Inc(P2);
  end;
end;

{$IF NOT DECLARED(IMAGE_ORDINAL)}
function IMAGE_ORDINAL(Ordinal: NativeUInt): Word; inline;
begin
  Result := Ordinal and $FFFF;
end;
{$IFEND}

{$IF NOT DECLARED(IMAGE_SNAP_BY_ORDINAL)}
function IMAGE_SNAP_BY_ORDINAL(Ordinal: NativeUInt): Boolean; inline;
begin
  Result := ((Ordinal and IMAGE_ORDINAL_FLAG) <> 0);
end;
{$IFEND}

function GET_HEADER_DICTIONARY(Module: PMemoryModule; Idx: Integer): PIMAGE_DATA_DIRECTORY;
begin
  Result := PIMAGE_DATA_DIRECTORY(@(Module.Headers.OptionalHeader.DataDirectory[Idx]));
end;

function ALIGN_DOWN(Address: Pointer; Alignment: DWORD): Pointer;
begin
  Result := Pointer(UIntPtr(Address) and not (Alignment - 1));
end;

function CopySections(data: Pointer; old_headers: PIMAGE_NT_HEADERS; module: PMemoryModule): Boolean;
var
  i, Size: Integer;
  CodeBase: Pointer;
  dest: Pointer;
  Section: PIMAGE_SECTION_HEADER;
begin
  CodeBase := Module.CodeBase;
  Section := PIMAGE_SECTION_HEADER(IMAGE_FIRST_SECTION(Module.Headers{$IFNDEF FPC}^{$ENDIF}));
  for i := 0 to Module.Headers.FileHeader.NumberOfSections - 1 do
  begin
    // Section doesn't contain data in the dll itself, but may define
    // uninitialized Data
    if Section.SizeOfRawData = 0 then
    begin
      Size := Old_headers.OptionalHeader.SectionAlignment;
      if Size > 0 then
      begin
        dest := VirtualAlloc(PByte(CodeBase) + Section.VirtualAddress,
                             Size,
                             MEM_COMMIT,
                             PAGE_READWRITE);
        if dest = nil then
          Exit(False);
        // Always use position from file to support alignments smaller
        // than page Size.
        dest := PByte(CodeBase) + Section.VirtualAddress;
        Section.Misc.PhysicalAddress := DWORD(dest);
        ZeroMemory(dest, Size);
      end;
      // Section is empty
      Inc(Section);
      Continue;
    end; // if
    // commit memory block and copy Data from dll
    dest := VirtualAlloc(PByte(CodeBase) + Section.VirtualAddress,
                         Section.SizeOfRawData,
                         MEM_COMMIT,
                         PAGE_READWRITE);
    if dest = nil then
      Exit(False);
    // Always use position from file to support alignments smaller
    // than page Size.
    dest := PByte(CodeBase) + Section.VirtualAddress;
    CopyMemory(dest, PByte(Data) + Section.PointerToRawData, Section.SizeOfRawData);
    Section.Misc.PhysicalAddress := DWORD(dest);
    Inc(Section);
  end; // for
  Result := True;
end;

// Protection flags for memory pages (Executable, Readable, Writeable)
const
  ProtectionFlags: array[Boolean, Boolean, Boolean] of DWORD =
  (
    (
        // not executable
        (PAGE_NOACCESS, PAGE_WRITECOPY),
        (PAGE_READONLY, PAGE_READWRITE)
    ),
    (
        // executable
        (PAGE_EXECUTE, PAGE_EXECUTE_WRITECOPY),
        (PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE)
    )
);

function GetRealSectionSize(Module: PMemoryModule; Section: PIMAGE_SECTION_HEADER): DWORD;
begin
  Result := Section.SizeOfRawData;
  if Result = 0 then
    if (Section.Characteristics and IMAGE_SCN_CNT_INITIALIZED_DATA) <> 0 then
      Result := Module.Headers.OptionalHeader.SizeOfInitializedData
    else if (Section.Characteristics and IMAGE_SCN_CNT_UNINITIALIZED_DATA) <> 0 then
      Result := Module.Headers.OptionalHeader.SizeOfUninitializedData;
end;

function FinalizeSection(Module: PMemoryModule; const SectionData: TSectionFinalizeData): Boolean;
var
  protect, oldProtect: DWORD;
  executable, readable, writeable: Boolean;
begin
  if SectionData.Size = 0 then
    Exit(True);
  if (SectionData.Characteristics and IMAGE_SCN_MEM_DISCARDABLE) <> 0 then
  begin
    // Section is not needed any more and can safely be freed
    if (SectionData.Address = SectionData.AlignedAddress) and
       ( SectionData.Last or
         (Module.Headers.OptionalHeader.SectionAlignment = Module.PageSize) or
         (SectionData.Size mod Module.PageSize = 0)
       ) then
         // Only allowed to decommit whole pages
         VirtualFree(SectionData.Address, SectionData.Size, MEM_DECOMMIT);
    Exit(True);
  end;
  // determine protection flags based on Characteristics
  executable := (SectionData.Characteristics and IMAGE_SCN_MEM_EXECUTE) <> 0;
  readable   := (SectionData.Characteristics and IMAGE_SCN_MEM_READ) <> 0;
  writeable  := (SectionData.Characteristics and IMAGE_SCN_MEM_WRITE) <> 0;
  protect := ProtectionFlags[executable][readable][writeable];
  if (SectionData.Characteristics and IMAGE_SCN_MEM_NOT_CACHED) <> 0 then
    protect := protect or PAGE_NOCACHE;
  // change memory access flags
  Result := VirtualProtect(SectionData.Address, SectionData.Size, protect, oldProtect);
end;

function FinalizeSections(Module: PMemoryModule): Boolean;
var
  i: Integer;
  Section: PIMAGE_SECTION_HEADER;
  imageOffset: UIntPtr;
  SectionData: TSectionFinalizeData;
  sectionAddress, AlignedAddress: Pointer;
  sectionSize: DWORD;
begin
  Section := PIMAGE_SECTION_HEADER(IMAGE_FIRST_SECTION(Module.Headers{$IFNDEF FPC}^{$ENDIF}));
  {$IFDEF CPUX64}
  imageOffset := (NativeUInt(Module.CodeBase) and $ffffffff00000000);
  {$ELSE}
  imageOffset := 0;
  {$ENDIF}
  SectionData.Address := Pointer(UIntPtr(Section.Misc.PhysicalAddress) or imageOffset);
  SectionData.AlignedAddress := ALIGN_DOWN(SectionData.Address, Module.PageSize);
  SectionData.Size := GetRealSectionSize(Module, Section);
  SectionData.Characteristics := Section.Characteristics;
  SectionData.Last := False;
  Inc(Section);
  // loop through all sections and change access flags
  for i := 1 to Module.Headers.FileHeader.NumberOfSections - 1 do
  begin
    sectionAddress := Pointer(UIntPtr(Section.Misc.PhysicalAddress) or imageOffset);
    AlignedAddress := ALIGN_DOWN(SectionData.Address, Module.PageSize);
    sectionSize := GetRealSectionSize(Module, Section);
    // Combine access flags of all sections that share a page
    // TODO(fancycode): We currently share flags of a trailing large Section
    //   with the page of a first small Section. This should be optimized.
    if (SectionData.AlignedAddress = AlignedAddress) or
       (PByte(SectionData.Address) + SectionData.Size > PByte(AlignedAddress)) then
    begin
      // Section shares page with previous
      if (Section.Characteristics and IMAGE_SCN_MEM_DISCARDABLE = 0) or
         (SectionData.Characteristics and IMAGE_SCN_MEM_DISCARDABLE = 0) then
        SectionData.Characteristics := (SectionData.Characteristics or Section.Characteristics) and not IMAGE_SCN_MEM_DISCARDABLE
      else
        SectionData.Characteristics := SectionData.Characteristics or Section.Characteristics;
      SectionData.Size := PByte(sectionAddress) + sectionSize - PByte(SectionData.Address);
      Inc(Section);
      Continue;
    end;
    if not FinalizeSection(Module, SectionData) then
      Exit(False);
    SectionData.Address := sectionAddress;
    SectionData.AlignedAddress := AlignedAddress;
    SectionData.Size := sectionSize;
    SectionData.Characteristics := Section.Characteristics;
    Inc(Section);
  end; // for
  SectionData.Last := True;
  if not FinalizeSection(Module, SectionData) then
    Exit(False);
  Result := True;
end;

function ExecuteTLS(Module: PMemoryModule): Boolean;
var
  CodeBase: Pointer;
  directory: PIMAGE_DATA_DIRECTORY;
  tls: PIMAGE_TLS_DIRECTORY;
  callback: PPointer; // =^PIMAGE_TLS_CALLBACK;
  // TLS callback pointers are VA's (ImageBase included) so if the module resides at
  // the other ImageBage they become invalid. This routine relocates them to the
  // actual ImageBase.
  // The case seem to happen with DLLs only and they rarely use TLS callbacks.
  // Moreover, they probably don't work at all when using DLL dynamically which is
  // the case in our code.
  function FixPtr(OldPtr: Pointer): Pointer;
  begin
    Result := Pointer(NativeUInt(OldPtr) - Module.Headers.OptionalHeader.ImageBase + NativeUInt(CodeBase));
  end;
begin
  Result := True;
  CodeBase := Module.CodeBase;
  directory := GET_HEADER_DICTIONARY(Module, IMAGE_DIRECTORY_ENTRY_TLS);
  if directory.VirtualAddress = 0 then
    Exit;
  tls := PIMAGE_TLS_DIRECTORY(PByte(CodeBase) + directory.VirtualAddress);
  // Delphi syntax is quite awkward when dealing with proc pointers so we have to
  // use casts to untyped pointers
  callback := Pointer(tls.AddressOfCallBacks);
  if callback <> nil then
  begin
    callback := FixPtr(callback);
    while callback^ <> nil do
    begin
      PIMAGE_TLS_CALLBACK(FixPtr(callback^))(CodeBase, DLL_PROCESS_ATTACH, nil);
      Inc(callback);
    end;
  end;
end;

function PerformBaseRelocation(Module: PMemoryModule; Delta: NativeInt): Boolean;
var
  i: Cardinal;
  CodeBase: Pointer;
  directory: PIMAGE_DATA_DIRECTORY;
  relocation: PIMAGE_BASE_RELOCATION;
  dest: Pointer;
  relInfo: ^UInt16;
  patchAddrHL: PDWORD;
  {$IFDEF CPUX64}
  patchAddr64: PULONGLONG;
  {$ENDIF}
  relType, offset: Integer;
begin
  CodeBase := Module.CodeBase;
  directory := GET_HEADER_DICTIONARY(Module, IMAGE_DIRECTORY_ENTRY_BASERELOC);
  if directory.Size = 0 then
    Exit(Delta = 0);
  relocation := PIMAGE_BASE_RELOCATION(PByte(CodeBase) + directory.VirtualAddress);
  while relocation.VirtualAddress > 0 do
  begin
    dest := Pointer(PByte(CodeBase) + relocation.VirtualAddress);
    relInfo := Pointer(PByte(relocation) + IMAGE_SIZEOF_BASE_RELOCATION);
    for i := 0 to Trunc(((relocation.SizeOfBlock - IMAGE_SIZEOF_BASE_RELOCATION) / 2)) - 1 do
    begin
      // the upper 4 bits define the type of relocation
      relType := relInfo^ shr 12;
      // the lower 12 bits define the offset
      offset := relInfo^ and $FFF;
      case relType of
        IMAGE_REL_BASED_ABSOLUTE:
          // skip relocation
          ;
        IMAGE_REL_BASED_HIGHLOW:
          begin
            // change complete 32 bit address
            patchAddrHL := Pointer(PByte(dest) + offset);
            Inc(patchAddrHL^, Delta);
          end;
        {$IFDEF CPUX64}
        IMAGE_REL_BASED_DIR64:
          begin
            patchAddr64 := Pointer(PByte(dest) + offset);
            Inc(patchAddr64^, Delta);
          end;
        {$ENDIF}
      end;
      Inc(relInfo);
    end; // for
    // advance to next relocation block
    relocation := PIMAGE_BASE_RELOCATION(PByte(relocation) + relocation.SizeOfBlock);
  end; // while
  Result := True;
end;

function BuildImportTable(Module: PMemoryModule): Boolean; stdcall;
var
  CodeBase: Pointer;
  directory: PIMAGE_DATA_DIRECTORY;
  importDesc: PIMAGE_IMPORT_DESCRIPTOR;
  thunkRef: PUINT_PTR;
  funcRef: ^FARPROC;
  handle: HMODULE;
  thunkData: PIMAGE_IMPORT_BY_NAME;
begin
  CodeBase := Module.CodeBase;
  Result := True;
  directory := GET_HEADER_DICTIONARY(Module, IMAGE_DIRECTORY_ENTRY_IMPORT);
  if directory.Size = 0 then
    Exit(True);
  importDesc := PIMAGE_IMPORT_DESCRIPTOR(PByte(CodeBase) + directory.VirtualAddress);
  while (not IsBadReadPtr(importDesc, SizeOf(IMAGE_IMPORT_DESCRIPTOR))) and (importDesc.Name <> 0) do
  begin
    handle := LoadLibraryA_Internal(PAnsiChar(PByte(CodeBase) + importDesc.Name));
    if handle = 0 then
    begin
      SetLastError(ERROR_MOD_NOT_FOUND);
      Result := False;
      Break;
    end;
    try
      SetLength(Module.Modules, Module.NumModules + 1);
    except
      FreeLibrary_Internal(handle);
      SetLastError(ERROR_OUTOFMEMORY);
      Result := False;
      Break;
    end;
    Module.Modules[Module.NumModules] := handle;
    Inc(Module.NumModules);
    if importDesc.OriginalFirstThunk <> 0 then
    begin
      thunkRef := Pointer(PByte(CodeBase) + importDesc.OriginalFirstThunk);
      funcRef := Pointer(PByte(CodeBase) + importDesc.FirstThunk);
    end
    else
    begin
      // no hint table
      thunkRef := Pointer(PByte(CodeBase) + importDesc.FirstThunk);
      funcRef := Pointer(PByte(CodeBase) + importDesc.FirstThunk);
    end;
    while thunkRef^ <> 0 do
    begin
      if IMAGE_SNAP_BY_ORDINAL(thunkRef^) then
        funcRef^ := GetProcAddress_Internal(handle, PAnsiChar(IMAGE_ORDINAL(thunkRef^)))
      else
      begin
        thunkData := PIMAGE_IMPORT_BY_NAME(PByte(CodeBase) + thunkRef^);
        funcRef^ := GetProcAddress_Internal(handle, PAnsiChar(@(thunkData.Name)));
      end;
      if funcRef^ = nil then
      begin
        Result := False;
        Break;
      end;
      Inc(funcRef);
      Inc(thunkRef);
    end; // while
    if not Result then
    begin
      FreeLibrary_Internal(handle);
      SetLastError(ERROR_PROC_NOT_FOUND);
      Break;
    end;
    Inc(importDesc);
  end; // while
end;

procedure MemoryFreeLibrary(Module: TMemoryModule); stdcall;
var
  i: Integer;
  DllEntry: TDllEntryProc;
  mmodule: PMemoryModule;
begin
  if Module = nil then Exit;
  mmodule := PMemoryModule(Module);
  if mmodule.Initialized then
  begin
    // notify library about detaching from process
    @DllEntry := Pointer(PByte(mmodule.CodeBase) + mmodule.Headers.OptionalHeader.AddressOfEntryPoint);
    DllEntry(HINST(mmodule.CodeBase), DLL_PROCESS_DETACH, nil);
  end;
  if Length(mmodule.Modules) <> 0 then
  begin
    // free previously opened libraries
    for i := 0 to mmodule.NumModules - 1 do
      if mmodule.Modules[i] <> 0 then
        FreeLibrary_Internal(mmodule.Modules[i]);
    SetLength(mmodule.Modules, 0);
  end;
  if mmodule.CodeBase <> nil then
    // release memory of library
    VirtualFree(mmodule.CodeBase, 0, MEM_RELEASE);
  HeapFree(GetProcessHeap(), 0, mmodule);
end;

function MemoryLoadLibary(Data: Pointer): TMemoryModule; stdcall;
var
  dos_header: PIMAGE_DOS_HEADER;
  old_header: PIMAGE_NT_HEADERS;
  code, Headers: Pointer;
  locationdelta: NativeUInt;
  sysInfo: SYSTEM_INFO;
  DllEntry: TDllEntryProc;
  successfull: Boolean;
  Module: PMemoryModule;
begin
  Result := nil; Module := nil;
  try
    dos_header := PIMAGE_DOS_HEADER(Data);
    if (dos_header.e_magic <> IMAGE_DOS_SIGNATURE) then
    begin
      SetLastError(ERROR_BAD_EXE_FORMAT);
      Exit;
    end;
    // old_header = (PIMAGE_NT_HEADERS)&((const unsigned char * )(Data))[dos_header->e_lfanew];
    old_header := PIMAGE_NT_HEADERS(PByte(Data) + dos_header._lfanew);
    if old_header.Signature <> IMAGE_NT_SIGNATURE then
    begin
      SetLastError(ERROR_BAD_EXE_FORMAT);
      Exit;
    end;
    {$IFDEF CPUX64}
    if old_header.FileHeader.Machine <> IMAGE_FILE_MACHINE_AMD64 then
    {$ELSE}
    if old_header.FileHeader.Machine <> IMAGE_FILE_MACHINE_I386 then
    {$ENDIF}
    begin
      SetLastError(ERROR_BAD_EXE_FORMAT);
      Exit;
    end;
    if (old_header.OptionalHeader.SectionAlignment and 1) <> 0 then
    begin
      // Only support section alignments that are a multiple of 2
      SetLastError(ERROR_BAD_EXE_FORMAT);
      Exit;
    end;
    // reserve memory for image of library
    // XXX: is it correct to commit the complete memory region at once?
    //      calling DllEntry raises an exception if we don't...
    code := VirtualAlloc(Pointer(old_header.OptionalHeader.ImageBase),
                         old_header.OptionalHeader.SizeOfImage,
                         MEM_RESERVE or MEM_COMMIT,
                         PAGE_READWRITE);
    if code = nil then
    begin
      // try to allocate memory at arbitrary position
      code := VirtualAlloc(nil,
                           old_header.OptionalHeader.SizeOfImage,
                           MEM_RESERVE or MEM_COMMIT,
                           PAGE_READWRITE);
      if code = nil then
      begin
        SetLastError(ERROR_OUTOFMEMORY);
        Exit;
      end;
    end;
    Module := PMemoryModule(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, SizeOf(TMemoryModuleRec)));
    if Module = nil then
    begin
      VirtualFree(code, 0, MEM_RELEASE);
      SetLastError(ERROR_OUTOFMEMORY);
      Exit;
    end;
    // memory is zeroed by HeapAlloc
    Module.CodeBase := code;
    GetNativeSystemInfo({$IFDEF FPC}@{$ENDIF}sysInfo);
    Module.PageSize := sysInfo.dwPageSize;
    // commit memory for Headers
    Headers := VirtualAlloc(code,
                            old_header.OptionalHeader.SizeOfHeaders,
                            MEM_COMMIT,
                            PAGE_READWRITE);
    // copy PE header to code
    CopyMemory(Headers, dos_header, old_header.OptionalHeader.SizeOfHeaders);
    // result->Headers = (PIMAGE_NT_HEADERS)&((const unsigned char *)(Headers))[dos_header->e_lfanew];
    Module.Headers := PIMAGE_NT_HEADERS(PByte(Headers) + dos_header._lfanew);
    // copy sections from DLL file block to new memory location
    if not CopySections(Data, old_header, Module) then
      Abort;
    // adjust base address of imported data
    locationdelta := NativeUInt(code) - old_header.OptionalHeader.ImageBase;
    if locationdelta <> 0 then
      Module.IsRelocated := PerformBaseRelocation(Module, locationdelta)
    else
      Module.IsRelocated := True;
    // load required dlls and adjust function table of imports
    if not BuildImportTable(Module) then
      Abort;
    // mark memory pages depending on Section Headers and release
    // sections that are marked as "discardable"
    if not FinalizeSections(Module) then
      Abort;
    // TLS callbacks are executed BEFORE the main loading
    if not ExecuteTLS(Module) then
      Abort;
    // get entry point of loaded library
    if Module.Headers.OptionalHeader.AddressOfEntryPoint <> 0 then
    begin
      @DllEntry := Pointer(PByte(code) + Module.Headers.OptionalHeader.AddressOfEntryPoint);
      // notify library about attaching to process
      successfull := DllEntry(HINST(code), DLL_PROCESS_ATTACH, nil);
      if not successfull then
      begin
        SetLastError(ERROR_DLL_INIT_FAILED);
        Abort;
      end;
      Module.Initialized := True;
    end;
    Result := Module;
  except
    // cleanup
    MemoryFreeLibrary(Module);
    Exit;
  end;
end;

function MemoryGetProcAddress(Module: TMemoryModule; const Name: PAnsiChar): Pointer; stdcall;
var
  CodeBase: Pointer;
  Idx: Integer;
  i: DWORD;
  nameRef: PDWORD;
  ordinal: PWord;
  exportDir: PIMAGE_EXPORT_DIRECTORY;
  directory: PIMAGE_DATA_DIRECTORY;
  temp: PDWORD;
  mmodule: PMemoryModule;
begin
  Result := nil;
  mmodule := PMemoryModule(Module);
  CodeBase := mmodule.CodeBase;
  directory := GET_HEADER_DICTIONARY(mmodule, IMAGE_DIRECTORY_ENTRY_EXPORT);

  // no export table found
  if directory.Size = 0 then
  begin
    SetLastError(ERROR_PROC_NOT_FOUND);
    Exit;
  end;

  exportDir := PIMAGE_EXPORT_DIRECTORY(PByte(CodeBase) + directory.VirtualAddress);
  // DLL doesn't export anything
  if (exportDir.NumberOfNames = 0) or (exportDir.NumberOfFunctions = 0) then
  begin
    SetLastError(ERROR_PROC_NOT_FOUND);
    Exit;
  end;

  // search function name in list of exported names
  nameRef := Pointer(PByte(CodeBase) + exportDir.AddressOfNames);
  ordinal := Pointer(PByte(CodeBase) + exportDir.AddressOfNameOrdinals);
  Idx := -1;
  for i := 0 to exportDir.NumberOfNames - 1 do
  begin
    if StrComp(Name, PAnsiChar(PByte(CodeBase) + nameRef^)) = 0 then
    begin
      Idx := ordinal^;
      Break;
    end;
    Inc(nameRef);
    Inc(ordinal);
  end;

  // exported symbol not found
  if (Idx = -1) then
  begin
    SetLastError(ERROR_PROC_NOT_FOUND);
    Exit;
  end;

  // name <-> ordinal number don't match
  if (DWORD(Idx) > exportDir.NumberOfFunctions) then
  begin
    SetLastError(ERROR_PROC_NOT_FOUND);
    Exit;
  end;

  // AddressOfFunctions contains the RVAs to the "real" functions     {}
  temp := Pointer(PByte(CodeBase) + exportDir.AddressOfFunctions + Idx*4);
  Result := Pointer(PByte(CodeBase) + temp^);
end;
{$ENDREGION}

{$REGION '=== SPARK ======================================================================'}
// Routines
function SingleInstance: Boolean;
var
  LFilename: string;
  LText: System.Text;
  LOk: Boolean;
  LIOResult: Integer;
begin
  Result := False;
  LFilename := ChangeFileExt(ParamStr(0), cLOGExt);
  if not  FileExists(LFilename) then
    Result := True;
  {$I-}
  AssignFile(LText, LFilename);
  Reset(LText);
  LIOResult := IOResult;
  LOk :=  Boolean(LIOResult = 0);
  {$I+}
  if LOk then
  begin
    CloseFile(LText);
    Result := True;
  end;
end;

procedure RunGame(aGame: TGameClass);
var
  LGame: TGame;
begin
  if not SingleInstance then
  begin
    TGame.ConsolePrintLn('An instance of this application is already running, terminating!', []);
    Exit;
  end;

  LGame := aGame.Create;
  try
    LGame.Run;
  finally
    FreeAndNil(LGame);
  end;
end;

{ --- MATH ------------------------------------------------------------------ }
{ TVector }
constructor TVector.Create(aX: Single; aY: Single);
begin
  Assign(aX, aY);
  Z := 0;
end;

procedure TVector.Assign(aX: Single; aY: Single);
begin
  X := aX;
  Y := aY;
end;

procedure TVector.Assign(aX: Single; aY: Single; aZ: Single);
begin
  X := aX;
  Y := aY;
  Z := aZ;
end;

procedure TVector.Clear;
begin
  X := 0;
  Y := 0;
  Z := 0;
end;

procedure TVector.Assign(aVector: TVector);
begin
  X := aVector.X;
  Y := aVector.Y;
end;

procedure TVector.Add(aVector: TVector);
begin
  X := X + aVector.X;
  Y := Y + aVector.Y;
end;

procedure TVector.Subtract(aVector: TVector);
begin
  X := X - aVector.X;
  Y := Y - aVector.Y;
end;

procedure TVector.Multiply(aVector: TVector);
begin
  X := X * aVector.X;
  Y := Y * aVector.Y;
end;

procedure TVector.Divide(aVector: TVector);
begin
  X := X / aVector.X;
  Y := Y / aVector.Y;

end;

function TVector.Magnitude: Single;
begin
  Result := Sqrt((X * X) + (Y * Y));
end;

function TVector.MagnitudeTruncate(aMaxMagitude: Single): TVector;
var
  LMaxMagSqrd: Single;
  LVecMagSqrd: Single;
  LTruc: Single;
begin
  Result.Assign(X, Y);
  LMaxMagSqrd := aMaxMagitude * aMaxMagitude;
  LVecMagSqrd := Result.Magnitude;
  if LVecMagSqrd > LMaxMagSqrd then
  begin
    LTruc := (aMaxMagitude / Sqrt(LVecMagSqrd));
    Result.X := Result.X * LTruc;
    Result.Y := Result.Y * LTruc;
  end;
end;

function TVector.Distance(aVector: TVector): Single;
var
  LDirVec: TVector;
begin
  LDirVec.X := X - aVector.X;
  LDirVec.Y := Y - aVector.Y;
  Result := LDirVec.Magnitude;
end;

procedure TVector.Normalize;
var
  LLen, LOOL: Single;
begin
  LLen := self.Magnitude;
  if LLen <> 0 then
  begin
    LOOL := 1.0 / LLen;
    X := X * LOOL;
    Y := Y * LOOL;
  end;
end;

function TVector.Angle(aVector: TVector): Single;
var
  LXOY: Single;
  LR: TVector;
begin
  LR.Assign(self);
  LR.Subtract(aVector);
  LR.Normalize;

  if LR.Y = 0 then
  begin
    LR.Y := 0.001;
  end;

  LXOY := LR.X / LR.Y;

  Result := ArcTan(LXOY) * RAD2DEG;
  if LR.Y < 0 then
    Result := Result + 180.0;

end;

procedure TVector.Thrust(aAngle: Single; aSpeed: Single);
var
  LA: Single;

begin
  LA := aAngle + 90.0;

  Game.ClipValue(LA, 0, 360, True);

  X := X + Game.AngleCos(Round(LA)) * -(aSpeed);
  Y := Y + Game.AngleSin(Round(LA)) * -(aSpeed);
end;

function TVector.MagnitudeSquared: Single;
begin
  Result := (X * X) + (Y * Y);
end;

function TVector.DotProduct(aVector: TVector): Single;
begin
  Result := (X * aVector.X) + (Y * aVector.Y);
end;

procedure TVector.Scale(aValue: Single);
begin
  X := X * aValue;
  Y := Y * aValue;
end;

procedure TVector.DivideBy(aValue: Single);
begin
  X := X / aValue;
  Y := Y / aValue;
end;

function TVector.Project(aVector: TVector): TVector;
var
  LDP: Single;
begin
  LDP := self.DotProduct(aVector);
  Result.X := (LDP / (aVector.X * aVector.X + aVector.Y * aVector.Y)) * aVector.X;
  Result.Y := (LDP / (aVector.X * aVector.X + aVector.Y * aVector.Y)) * aVector.Y;
end;

procedure TVector.Negate;
begin
  X := -X;
  Y := -Y;
end;

{ TRectangle }
constructor TRectangle.Create(aX: Single; aY: Single; aWidth: Single; aHeight: Single);
begin
  Assign(aX, aY, aWidth, aHeight);
end;

procedure TRectangle.Assign(aX: Single; aY: Single; aWidth: Single; aHeight: Single);
begin
  X := aX;
  Y := aY;
  Width := aWidth;
  Height := aHeight;
end;

function TRectangle.Intersect(aRect: TRectangle): Boolean;
var
  LR1R, LR1B: Single;
  LR2R, LR2B: Single;
begin
  LR1R := X - (Width - 1);
  LR1B := Y - (Height - 1);
  LR2R := aRect.X - (aRect.Width - 1);
  LR2B := aRect.Y - (aRect.Height - 1);

  Result := (X < LR2R) and (LR1R > aRect.X) and (Y < LR2B) and (LR1B > aRect.Y);
end;

{ --- INPUT ----------------------------------------------------------------- }
{ TJoystick }
procedure TJoystick.Setup(aNum: Integer);
var
  LJoyCount: Integer;
  LJoy: PALLEGRO_JOYSTICK;
  LJoyState: ALLEGRO_JOYSTICK_STATE;
  LI, LJ: Integer;
begin
  LJoyCount := al_get_num_joysticks;
  if (aNum < 0) or (aNum > LJoyCount - 1) then
    Exit;

  LJoy := al_get_joystick(aNum);
  if LJoy = nil then
  begin
    Sticks := 0;
    Buttons := 0;
    Exit;
  end;

  Name := string(al_get_joystick_name(LJoy));

  al_get_joystick_state(LJoy, @LJoyState);

  Sticks := al_get_joystick_num_sticks(LJoy);
  if (Sticks > MAX_STICKS) then
    Sticks := MAX_STICKS;

  for LI := 0 to Sticks - 1 do
  begin
    StickName[LI] := string(al_get_joystick_stick_name(LJoy, LI));
    Axes[LI] := al_get_joystick_num_axes(LJoy, LI);
    for LJ := 0 to Axes[LI] - 1 do
    begin
      Pos[LI, LJ] := LJoyState.stick[LI].axis[LJ];
      AxesName[LI, LJ] := string(al_get_joystick_axis_name(LJoy, LI, LJ));
    end;
  end;

  Buttons := al_get_joystick_num_buttons(LJoy);
  if (Buttons > MAX_BUTTONS) then
    Buttons := MAX_BUTTONS;

  for LI := 0 to Buttons - 1 do
  begin
    ButtonName[LI] := string(al_get_joystick_button_name(LJoy, LI));
    Button[LI] := Boolean(LJoyState.Button[LI] >= 16384);
  end
end;

function TJoystick.GetPos(aStick: Integer; aAxes: Integer): Single;
begin
  Result := Pos[aStick, aAxes];
end;

function TJoystick.GetButton(aButton: Integer): Boolean;
begin
  Result := Button[aButton];
end;

{ --- GAME ------------------------------------------------------------------ }
{ TGame }
procedure TGame.Startup;
begin
  // init log
  FLog.Filename := '';
  FillChar(FLog.Buffer, SizeOf(FLog.Buffer), 0);
  FLog.Open := False;
  OpenLog;

  // init math
  Randomize;
  for var I := 0 to 360 do
  begin
    FCosTable[I] := cos((I * PI / 180.0));
    FSinTable[I] := sin((I * PI / 180.0));
  end;

  // init allegro
  al_init;

  // init devices
  al_install_joystick;
  al_install_keyboard;
  al_install_mouse;
  al_install_touch_input;
  al_install_haptic;
  al_install_audio;

  // init addons
  al_init_acodec_addon;
  al_init_font_addon;
  al_init_image_addon;
  al_init_native_dialog_addon;
  al_init_primitives_addon;
  al_init_ttf_addon;
  al_init_video_addon;

  // init event queues
  FQueue := al_create_event_queue;
  al_register_event_source(FQueue, al_get_joystick_event_source);
  al_register_event_source(FQueue, al_get_keyboard_event_source);
  al_register_event_source(FQueue, al_get_mouse_event_source);
  al_register_event_source(FQueue, al_get_touch_input_event_source);
  al_register_event_source(FQueue, al_get_touch_input_mouse_emulation_event_source);

  // init audio
  if al_is_audio_installed then
  begin
    FAudio.Voice := al_create_voice(44100, ALLEGRO_AUDIO_DEPTH_INT16,  ALLEGRO_CHANNEL_CONF_2);
    FAudio.Mixer := al_create_mixer(44100, ALLEGRO_AUDIO_DEPTH_FLOAT32,  ALLEGRO_CHANNEL_CONF_2);
    al_set_default_mixer(FAudio.Mixer);
    al_attach_mixer_to_voice(FAudio.Mixer, FAudio.Voice);
    al_reserve_samples(AUDIO_CHANNEL_COUNT);
  end;

  // init timing
  SetUpdateSpeed(60);
  FTimer.Last := GetTime;

  // init lists
  FFontList := TDictionary<Int64, TFont>.Create;
  FBitmapList := TDictionary<Int64, TBitmap>.Create;
  FViewportList := TDictionary<Int64, TViewport>.Create;
  FSampleList := TDictionary<Int64, TSample>.Create;

  // init input
  FInput.Joystick.Setup(0);
  ClearInput;

  // init hud
  FHud.TextItemPadWidth := 10;
  FHud.Pos.Assign(3, 3, 0);

  // init physfs
  al_set_physfs_file_interface;
  PHYSFS_init(nil);

  // init window
  FWindow.Viewport := ID_NIL;
end;

procedure TGame.Shutdown;
begin
  // shutdown physfs
  PHYSFS_deinit;

  // destroy lists
  FreeAndNil(FSampleList);
  FreeAndNil(FViewportList);
  FreeAndNil(FBitmapList);
  FreeAndNil(FFontList);

  // shutdown audio
  if al_is_audio_installed then
  begin
    al_stop_samples;
    al_detach_mixer(FAudio.Mixer);
    al_destroy_mixer(FAudio.Mixer);
    al_destroy_voice(FAudio.Voice);
    al_uninstall_audio;
  end;

  // shutdown event queues
  if al_is_event_source_registered(FQueue, al_get_touch_input_mouse_emulation_event_source) then
  begin
    al_unregister_event_source(FQueue, al_get_touch_input_mouse_emulation_event_source);
  end;

  if al_is_event_source_registered(FQueue, al_get_touch_input_event_source) then
  begin
    al_unregister_event_source(FQueue, al_get_touch_input_event_source);
  end;

  if al_is_event_source_registered(FQueue, al_get_keyboard_event_source) then
  begin
    al_unregister_event_source(FQueue, al_get_keyboard_event_source);
  end;

  if al_is_event_source_registered(FQueue, al_get_mouse_event_source) then
  begin
    al_unregister_event_source(FQueue, al_get_mouse_event_source);
  end;

  if al_is_event_source_registered(FQueue, al_get_joystick_event_source) then
  begin
    al_unregister_event_source(FQueue, al_get_joystick_event_source);
  end;

  // shutdown devices
  if al_is_haptic_installed then
  begin
    al_uninstall_haptic;
  end;

  if al_is_touch_input_installed then
  begin
    al_uninstall_touch_input;
  end;

  if al_is_mouse_installed then
  begin
    al_uninstall_mouse;
  end;

  if al_is_keyboard_installed then
  begin
    al_uninstall_keyboard;
  end;

  if al_is_joystick_installed then
  begin
    al_uninstall_joystick;
  end;

  if al_is_system_installed then
  begin
    al_uninstall_system;
  end;

  // shutdown log
  CloseLog;
end;

procedure TGame.UpdateTiming;
begin
  FTimer.LNow := GetTime;
  FTimer.Passed := FTimer.LNow - FTimer.Last;
  FTimer.Last := FTimer.LNow;

  // process framerate
  Inc(FTimer.FrameCount);
  FTimer.FrameAccumulator := FTimer.FrameAccumulator + FTimer.Passed + EPSILON;
  if FTimer.FrameAccumulator >= 1 then
  begin
    FTimer.FrameAccumulator := 0;
    FTimer.FrameRate := FTimer.FrameCount;
    FTimer.FrameCount := 0;
  end;

  // process variable update
  FTimer.Accumulator := FTimer.Accumulator + FTimer.Passed;
  while (FTimer.Accumulator >= FTimer.DeltaTime) do
  begin
    OnUpdateFrame(FTimer.DeltaTime);
    FTimer.Accumulator := FTimer.Accumulator - FTimer.DeltaTime;
  end;
end;

function TGame.GenID: Int64;
begin
  Inc(FIDCounter);
  Result := FIDCounter;
end;

procedure TGame.FixupWindow;
begin
  var LWW: Integer := al_get_display_width(FWindow.Handle);
  var LWH: Integer := al_get_display_height(FWindow.Handle);
  al_resize_display(FWindow.Handle, LWW+1, LWH+1);
  al_resize_display(FWindow.Handle, LWW, LWH);
end;

function TGame.TransformScale(aFullscreen: Boolean): Single;
var
  LScreenX, LScreenY: Integer;
  LScaleX, LScaleY: Single;
  LClipX, LClipY: Single;
  LScale: Single;
begin
  Result := 1;
  if FWindow.Handle = nil then Exit;

  LScreenX := al_get_display_width(FWindow.Handle);
  LScreenY := al_get_display_height(FWindow.Handle);

  if aFullscreen then
    begin
      LScaleX := LScreenX / FWindow.Size.X;
      LScaleY := LScreenY / FWindow.Size.Y;
      LScale := min(LScaleX, LScaleY);
      LClipX := (LScreenX - LScale * FWindow.Size.X) / 2;
      LClipY := (LScreenY - LScale * FWindow.Size.Y) / 2;
      al_build_transform(@FWindow.Trans, LClipX, LClipY, LScale, LScale, 0);
      al_use_transform(@FWindow.Trans);
      al_set_clipping_rectangle(Round(LClipX), Round(LClipY), Round(LScreenX - 2 * LClipX), Round(LScreenY - 2 * LClipY));
      FWindow.TransSize.X := LClipX;
      FWindow.TransSize.Y := LClipY;
      FWindow.TransSize.Width := LScreenX - 2 * LClipX;
      FWindow.TransSize.Height := LScreenY - 2 * LClipY;
      Result := LScale;
      FWindow.TransScale := LScale;
    end
  else
    begin
      al_identity_transform(@FWindow.Trans);
      al_use_transform(@FWindow.Trans);
      al_set_clipping_rectangle(0, 0, Round(LScreenX), Round(LScreenY));
      FWindow.TransSize.X := 0;
      FWindow.TransSize.Y := 0;
      FWindow.TransSize.Width := LScreenX;
      FWindow.TransSize.Height := LScreenY;
      FWindow.TransScale := 1;
      ResizeForDPI;
    end;
end;

procedure TGame.ResizeForDPI;
begin
  var LDpi: Integer := GetDpiForWindow(al_get_win_window_handle(FWindow.Handle));
  var LSX,LSY: Integer;
  LSX := MulDiv(Round(FWindow.Size.X), LDPI, DISPLAY_DEFAULT_DPI);
  LSY := MulDiv(Round(FWindow.Size.Y), LDpi, DISPLAY_DEFAULT_DPI);

  var LWH: HWND := al_get_win_window_handle(FWindow.Handle);
  var LWX: Integer := (GetSystemMetrics(SM_CXFULLSCREEN) - LSX) div 2;
  var LWY: Integer := (GetSystemMetrics(SM_CYFULLSCREEN) - LSY) div 2;
  al_set_window_position(FWindow.Handle, LWX, LWY);
  al_resize_display(FWindow.Handle, LSX, LSY);

  var LScale: Single := min(LSX / FWindow.Size.x, LSY / FWindow.Size.Y);
  al_set_clipping_rectangle(0, 0, LSX, LSY);
  FWindow.TransSize.X := 0;
  FWindow.TransSize.Y := 0;
  FWindow.TransSize.Width := LSX;
  FWindow.TransSize.Height := LSY;
  FWindow.TransScale := LScale;
  FWindow.UpScale := LScale;
  al_build_transform(@FWindow.Trans, 0, 0, LScale, LScale, 0);
  al_use_transform(@FWindow.Trans);

  SetWindowLong(LWH, GWL_STYLE, GetWindowLong(LWH, GWL_STYLE) and (not WS_SIZEBOX) and (not WS_MAXIMIZEBOX));
  FixupWindow;
end;

procedure TGame.LoadDefaultIcon(aWnd: HWND);
var
  LHnd: THandle;
  LIco: TIcon;
begin
  LHnd := GetModuleHandle(nil);
  if LHnd <> 0 then
  begin
    if FindResource(LHnd, 'MAINICON', RT_GROUP_ICON) <> 0 then
    begin
      LIco := TIcon.Create;
      LIco.LoadFromResourceName(LHnd, 'MAINICON');
      SendMessage(aWnd, WM_SETICON, ICON_BIG, LIco.Handle);
      FreeAndNil(LIco);
    end;
  end;
end;

class function  TGame.HasConsoleOutput: Boolean;
var
  LStdout: THandle;
begin
  LStdout := GetStdHandle(Std_Output_Handle);
  Win32Check(LStdout <> Invalid_Handle_Value);
  Result := Boolean(LStdout <> 0);
end;

procedure TGame.OpenLog;
begin
  CloseLog;

  FLog.FormatSettings.DateSeparator := '/';
  FLog.FormatSettings.TimeSeparator := ':';
  FLog.FormatSettings.ShortDateFormat := 'DD-MM-YYY HH:NN:SS';
  FLog.FormatSettings.ShortTimeFormat := 'HH:NN:SS';

  FLog.Filename := ChangeFileExt(ParamStr(0), cLogExt);

  AssignFile(FLog.Text, FLog.Filename);
  ReWrite(FLog.Text);
  SetTextBuf(FLog.Text, FLog.Buffer);
  FLog.Open := True;
end;

procedure TGame.CloseLog;
begin
  if not FLog.Open then Exit;
  CloseFile(FLog.Text);
  FLog.Open := False;
end;

constructor TGame.Create;
begin
  inherited;
  if Game <> nil then
    raise Exception.Create('An instance of TGame is already active!');
  Game := Self;
  Startup;
end;

destructor TGame.Destroy;
begin
  Shutdown;
  Game := nil;
  inherited;
end;

// Log
procedure TGame.Log(const aMsg: string; const aArgs: array of const; aWriteToConsole: Boolean=False);
var
  LLine: string;
begin
  // get line
  LLine := Format(aMsg, aArgs);

  // write to console
  if HasConsoleOutput then
  begin
    if aWriteToConsole then
      WriteLn(LLine);
  end;

  // write to logfile
  {$I-}
  LLine := Format('%s %s', [DateTimeToStr(Now, FLog.FormatSettings), LLine]);
  Writeln(FLog.Text, LLine);
  Flush(FLog.Text);
  {$I+}
end;

// Console
class procedure TGame.ConsolePrint(const aMsg: string; const aArgs: array of const);
begin
  if not HasConsoleOutput then Exit;
  Write(Format(aMsg, aArgs));
end;

class procedure TGame.ConsolePrintLn(const aMsg: string; const aArgs: array of const);
begin
  if not HasConsoleOutput then Exit;
  WriteLn(Format(aMsg, aArgs));
end;

procedure TGame.Randomize;
begin
  System.Randomize;
end;

function TGame.RandomRange(aMin, aMax: Integer): Integer;
begin
  Result := System.Math.RandomRange(aMin, aMax + 1);
end;

function TGame.RandomRange(aMin, aMax: Single): Single;
var
  LN: Single;
begin
  LN := System.Math.RandomRange(0, MaxInt) / MaxInt;
  Result := aMin + (LN * (aMax - aMin));
end;

function TGame.RandomBool: Boolean;
begin
  Result := Boolean(System.Math.RandomRange(0, 2) = 1);
end;

function TGame.GetRandomSeed: Integer;
begin
  Result := RandSeed;
end;

procedure TGame.SetRandomSeed(aValue: Integer);
begin
  RandSeed := aValue;
end;

function TGame.AngleCos(aAngle: Integer): Single;
begin
  Result := 0;
  if (aAngle < 0) or (aAngle > 360) then Exit;
  Result := FCosTable[aAngle];
end;

function TGame.AngleSin(aAngle: Integer): Single;
begin
  Result := 0;
  if (aAngle < 0) or (aAngle > 360) then Exit;
  Result := FSinTable[aAngle];
end;

function TGame.AngleDifference(aSrcAngle: Single; aDestAngle: Single): Single;
var
  LC: Single;
begin
  LC := aDestAngle - aSrcAngle -
    (Floor((aDestAngle - aSrcAngle) / 360.0) * 360.0);

  if LC >= (360.0 / 2) then
  begin
    LC := LC - 360.0;
  end;
  Result := LC;
end;

procedure TGame.AngleRotatePos(aAngle: Single; var aX: Single; var aY: Single);
var
  LNX, LNY: Single;
  LIA: Integer;
begin
  ClipValue(aAngle, 0, 359, True);

  LIA := Round(aAngle);

  LNX := aX * FCosTable[LIA] - aY * FSinTable[LIA];
  LNY := aY * FCosTable[LIA] + aX * FSinTable[LIA];

  aX := LNX;
  aY := LNY;
end;

function TGame.ClipValue(var aValue: Single; aMin: Single; aMax: Single; aWrap: Boolean): Single;
begin
  if aWrap then
    begin
      if (aValue > aMax) then
      begin
        aValue := aMin + Abs(aValue - aMax);
        if aValue > aMax then
          aValue := aMax;
      end
      else if (aValue < aMin) then
      begin
        aValue := aMax - Abs(aValue - aMin);
        if aValue < aMin then
          aValue := aMin;
      end
    end
  else
    begin
      if aValue < aMin then
        aValue := aMin
      else if aValue > aMax then
        aValue := aMax;
    end;

  Result := aValue;

end;

function TGame.ClipValue(var aValue: Integer; aMin: Integer; aMax: Integer; aWrap: Boolean): Integer;
begin
  if aWrap then
    begin
      if (aValue > aMax) then
      begin
        aValue := aMin + Abs(aValue - aMax);
        if aValue > aMax then
          aValue := aMax;
      end
      else if (aValue < aMin) then
      begin
        aValue := aMax - Abs(aValue - aMin);
        if aValue < aMin then
          aValue := aMin;
      end
    end
  else
    begin
      if aValue < aMin then
        aValue := aMin
      else if aValue > aMax then
        aValue := aMax;
    end;

  Result := aValue;
end;

function TGame.SameSign(aValue1: Integer; aValue2: Integer): Boolean;
begin
  if Sign(aValue1) = Sign(aValue2) then
    Result := True
  else
    Result := False;
end;

function TGame.SameSign(aValue1: Single; aValue2: Single): Boolean;
begin
  if Sign(aValue1) = Sign(aValue2) then
    Result := True
  else
    Result := False;
end;

function TGame.SameValue(aA: Double; aB: Double; aEpsilon: Double = 0): Boolean;
begin
  Result := System.Math.SameValue(aA, aB, aEpsilon);
end;

function TGame.SameValue(aA: Single; aB: Single; aEpsilon: Single = 0): Boolean;
begin
  Result := System.Math.SameValue(aA, aB, aEpsilon);
end;

function TGame.Point(aX: Integer; aY: Integer): TPointi;
begin
  Result.X := aX;
  Result.Y := aY;
end;

function TGame.Point(aX: Single; aY: Single): TPointf;
begin
  Result.X := aX;
  Result.Y := aY;
end;

function TGame.Vector(aX: Single; aY: Single): TVector;
begin
  Result.X := aX;
  Result.Y := aY;
  Result.Z := 0;
end;

function TGame.Rectangle(aX: Single; aY: Single; aWidth: Single; aHeight: Single): TRectangle;
begin
  Result.X := aX;
  Result.Y := aY;
  Result.Width := aWidth;
  Result.Height := aHeight;
end;

procedure TGame.SmoothMove(var aValue: Single; aAmount: Single; aMax: Single; aDrag: Single);
var
  LAmt: Single;
begin
  LAmt := aAmount;

  if LAmt > 0 then
  begin
    aValue := aValue + LAmt;
    if aValue > aMax then
      aValue := aMax;
  end else if LAmt < 0 then
  begin
    aValue := aValue + LAmt;
    if aValue < -aMax then
      aValue := -aMax;
  end else
  begin
    if aValue > 0 then
    begin
      aValue := aValue - aDrag;
      if aValue < 0 then
        aValue := 0;
    end else if aValue < 0 then
    begin
      aValue := aValue + aDrag;
      if aValue > 0 then
        aValue := 0;
    end;
  end;
end;

function TGame.Lerp(aFrom: Double; aTo: Double; aTime: Double): Double;
begin
  if aTime <= 0.5 then
    Result := aFrom + (aTo - aFrom) * aTime
  else
    Result := aTo - (aTo - aFrom) * (1.0 - aTime);
end;

// Collision
function TGame.PointInRectangle(aPoint: TVector; aRect: TRectangle): Boolean;
begin
  if ((aPoint.x >= aRect.x) and (aPoint.x <= (aRect.x + aRect.width)) and
    (aPoint.y >= aRect.y) and (aPoint.y <= (aRect.y + aRect.height))) then
    Result := True
  else
    Result := False;
end;

function TGame.PointInCircle(aPoint: TVector; aCenter: TVector; aRadius: Single): Boolean;
begin
  Result := CirclesOverlap(aPoint, 0, aCenter, aRadius);
end;

function TGame.PointInTriangle(aPoint: TVector; aP1: TVector; aP2: TVector; aP3: TVector): Boolean;
var
  LAlpha, LBeta, LGamma: Single;
begin
  LAlpha := ((aP2.y - aP3.y) * (aPoint.x - aP3.x) + (aP3.x - aP2.x) *
    (aPoint.y - aP3.y)) / ((aP2.y - aP3.y) * (aP1.x - aP3.x) + (aP3.x - aP2.x) *
    (aP1.y - aP3.y));

  LBeta := ((aP3.y - aP1.y) * (aPoint.x - aP3.x) + (aP1.x - aP3.x) *
    (aPoint.y - aP3.y)) / ((aP2.y - aP3.y) * (aP1.x - aP3.x) + (aP3.x - aP2.x) *
    (aP1.y - aP3.y));

  LGamma := 1.0 - LAlpha - LBeta;

  if ((LAlpha > 0) and (LBeta > 0) and (LGamma > 0)) then
    Result := True
  else
    Result := False;
end;

function TGame.CirclesOverlap(aCenter1: TVector; aRadius1: Single; aCenter2: TVector; aRadius2: Single): Boolean;
var
  LDX, LDY, LDistance: Single;
begin
  LDX := aCenter2.x - aCenter1.x; // X distance between centers
  LDY := aCenter2.y - aCenter1.y; // Y distance between centers

  LDistance := sqrt(LDX * LDX + LDY * LDY); // Distance between centers

  if (LDistance <= (aRadius1 + aRadius2)) then
    Result := True
  else
    Result := False;
end;

function TGame.CircleInRectangle(aCenter: TVector; aRadius: Single; aRect: TRectangle): Boolean;
var
  LDX, LDY: Single;
  LCornerDistanceSq: Single;
  LRecCenterX: Integer;
  LRecCenterY: Integer;
begin
  LRecCenterX := Round(aRect.x + aRect.width / 2);
  LRecCenterY := Round(aRect.y + aRect.height / 2);

  LDX := abs(aCenter.x - LRecCenterX);
  LDY := abs(aCenter.y - LRecCenterY);

  if (LDX > (aRect.width / 2.0 + aRadius)) then
  begin
    Result := False;
    Exit;
  end;

  if (LDY > (aRect.height / 2.0 + aRadius)) then
  begin
    Result := False;
    Exit;
  end;

  if (LDX <= (aRect.width / 2.0)) then
  begin
    Result := True;
    Exit;
  end;
  if (LDY <= (aRect.height / 2.0)) then
  begin
    Result := True;
    Exit;
  end;

  LCornerDistanceSq := (LDX - aRect.width / 2.0) * (LDX - aRect.width / 2.0) +
    (LDY - aRect.height / 2.0) * (LDY - aRect.height / 2.0);

  Result := Boolean(LCornerDistanceSq <= (aRadius * aRadius));
end;

function TGame.RectanglesOverlap(aRect1: TRectangle; aRect2: TRectangle): Boolean;
var
  LDX, LDY: Single;
begin
  LDX := abs((aRect1.x + aRect1.width / 2) - (aRect2.x + aRect2.width / 2));
  LDY := abs((aRect1.y + aRect1.height / 2) - (aRect2.y + aRect2.height / 2));

  if ((LDX <= (aRect1.width / 2 + aRect2.width / 2)) and
    ((LDY <= (aRect1.height / 2 + aRect2.height / 2)))) then
    Result := True
  else
    Result := False;
end;

function TGame.RectangleIntersection(aRect1, aRect2: TRectangle): TRectangle;
var
  LDXX, LDYY: Single;
begin
  Result.Assign(0, 0, 0, 0);

  if RectanglesOverlap(aRect1, aRect2) then
  begin
    LDXX := abs(aRect1.x - aRect2.x);
    LDYY := abs(aRect1.y - aRect2.y);

    if (aRect1.x <= aRect2.x) then
    begin
      if (aRect1.y <= aRect2.y) then
      begin
        Result.x := aRect2.x;
        Result.y := aRect2.y;
        Result.width := aRect1.width - LDXX;
        Result.height := aRect1.height - LDYY;
      end
      else
      begin
        Result.x := aRect2.x;
        Result.y := aRect1.y;
        Result.width := aRect1.width - LDXX;
        Result.height := aRect2.height - LDYY;
      end
    end
    else
    begin
      if (aRect1.y <= aRect2.y) then
      begin
        Result.x := aRect1.x;
        Result.y := aRect2.y;
        Result.width := aRect2.width - LDXX;
        Result.height := aRect1.height - LDYY;
      end
      else
      begin
        Result.x := aRect1.x;
        Result.y := aRect1.y;
        Result.width := aRect2.width - LDXX;
        Result.height := aRect2.height - LDYY;
      end
    end;

    if (aRect1.width > aRect2.width) then
    begin
      if (Result.width >= aRect2.width) then
        Result.width := aRect2.width;
    end
    else
    begin
      if (Result.width >= aRect1.width) then
        Result.width := aRect1.width;
    end;

    if (aRect1.height > aRect2.height) then
    begin
      if (Result.height >= aRect2.height) then
        Result.height := aRect2.height;
    end
    else
    begin
      if (Result.height >= aRect1.height) then
        Result.height := aRect1.height;
    end
  end;
end;

function TGame.LineIntersection(aX1, aY1, aX2, aY2, aX3, aY3, aX4, aY4: Integer; var aX: Integer; var aY: Integer): TLineIntersection;
var
  LAX, LBX, LCX, LAY, LBY, LCY, LD, LE, LF, LNum: Integer;
  LOffset: Integer;
  LX1Lo, LX1Hi, LY1Lo, LY1Hi: Integer;
begin
  Result := liNone;

  LAX := aX2 - aX1;
  LBX := aX3 - aX4;

  if (LAX < 0) then // X bound box test
  begin
    LX1Lo := aX2;
    LX1Hi := aX1;
  end
  else
  begin
    LX1Hi := aX2;
    LX1Lo := aX1;
  end;

  if (LBX > 0) then
  begin
    if (LX1Hi < aX4) or (aX3 < LX1Lo) then
      Exit;
  end
  else
  begin
    if (LX1Hi < aX3) or (aX4 < LX1Lo) then
      Exit;
  end;

  LAY := aY2 - aY1;
  LBY := aY3 - aY4;

  if (LAY < 0) then // Y bound box test
  begin
    LY1Lo := aY2;
    LY1Hi := aY1;
  end
  else
  begin
    LY1Hi := aY2;
    LY1Lo := aY1;
  end;

  if (LBY > 0) then
  begin
    if (LY1Hi < aY4) or (aY3 < LY1Lo) then
      Exit;
  end
  else
  begin
    if (LY1Hi < aY3) or (aY4 < LY1Lo) then
      Exit;
  end;

  LCX := aX1 - aX3;
  LCY := aY1 - aY3;
  LD := LBY * LCX - LBX * LCY; // alpha numerator
  LF := LAY * LBX - LAX * LBY; // both denominator

  if (LF > 0) then // alpha tests
  begin
    if (LD < 0) or (LD > LF) then
      Exit;
  end
  else
  begin
    if (LD > 0) or (LD < LF) then
      Exit
  end;

  LE := LAX * LCY - LAY * LCX; // beta numerator
  if (LF > 0) then // beta tests
  begin
    if (LE < 0) or (LE > LF) then
      Exit;
  end
  else
  begin
    if (LE > 0) or (LE < LF) then
      Exit;
  end;

  // compute intersection coordinates

  if (LF = 0) then
  begin
    Result := liParallel;
    Exit;
  end;

  LNum := LD * LAX; // numerator
  // if SameSigni(num, f) then
  if Sign(LNum) = Sign(LF) then

    LOffset := LF div 2
  else
    LOffset := -LF div 2;
  aX := aX1 + (LNum + LOffset) div LF; // intersection x

  LNum := LD * LAY;
  // if SameSigni(num, f) then
  if Sign(LNum) = Sign(LF) then
    LOffset := LF div 2
  else
    LOffset := -LF div 2;

  aY := aY1 + (LNum + LOffset) div LF; // intersection y

  Result := liTrue;
end;

function TGame.RadiusOverlap(aRadius1: Single; aX1: Single; aY1: Single; aRadius2: Single; aX2: Single; aY2: Single; aShrinkFactor: Single): Boolean;

var
  LDist: Single;
  LR1, LR2: Single;
  LV1, LV2: TVector;
begin
  LR1 := aRadius1 * aShrinkFactor;
  LR2 := aRadius2 * aShrinkFactor;

  LV1.x := aX1;
  LV1.y := aY1;
  LV2.x := aX2;
  LV2.y := aY2;

  LDist := LV1.distance(LV2);

  if (LDist < LR1) or (LDist < LR2) then
    Result := True
  else
    Result := False;
end;


// Color
function TGame.MakeColor(aRed: Byte; aGreen: Byte; aBlue: Byte; aAlpha: Byte): TColor;
var
  LColor: ALLEGRO_COLOR absolute Result;
begin
  LColor := al_map_rgba(aRed, aGreen, aBlue, aAlpha);
  Result.Red := LColor.r;
  Result.Green := LColor.g;
  Result.Blue := LColor.b;
  Result.Alpha := LColor.a;
end;

function TGame.MakeColor(aRed: Single; aGreen: Single; aBlue: Single; aAlpha: Single): TColor;
var
  LColor: ALLEGRO_COLOR absolute Result;
begin
  LColor := al_map_rgba_f(aRed, aGreen, aBlue, aAlpha);
  Result.Red := LColor.r;
  Result.Green := LColor.g;
  Result.Blue := LColor.b;
  Result.Alpha := LColor.a;
end;

function TGame.MakeColor(const aName: string): TColor;
var
  LMarshaller: TMarshaller;
  LColor: ALLEGRO_COLOR absolute Result;
begin
  LColor := al_color_name(LMarshaller.AsAnsi(aName).ToPointer);
  Result.Red := LColor.r;
  Result.Green := LColor.g;
  Result.Blue := LColor.b;
  Result.Alpha := LColor.a;
end;

function TGame.FadeColor(var aFrom: TColor; aTo: TColor; aPos: Single): TColor;
var
  LColor: TColor;
begin
  // clip to ranage 0.0 - 1.0
  if aPos < 0 then
    aPos := 0
  else if aPos > 1.0 then
    aPos := 1.0;

  // fade colors
  LColor.Alpha := aFrom.Alpha + ((aTo.Alpha - aFrom.Alpha) * aPos);
  LColor.Blue := aFrom.Blue + ((aTo.Blue - aFrom.Blue) * aPos);
  LColor.Green := aFrom.Green + ((aTo.Green - aFrom.Green) * aPos);
  LColor.Red := aFrom.Red + ((aTo.Red - aFrom.Red) * aPos);
  Result := MakeColor(LColor.Red, LColor.Green, LColor.Blue, LColor.Alpha);
  aFrom.Red := LColor.Red;
  aFrom.Green := LColor.Green;
  aFrom.Blue := LColor.Blue;
  aFrom.Alpha := LColor.Alpha;
end;

function TGame.ColorEqual(aColor1: TColor; aColor2: TColor): Boolean;
begin
  if (aColor1.Red = aColor2.Red) and (aColor1.Green = aColor2.Green) and
    (aColor1.Blue = aColor2.Blue) and (aColor1.Alpha = aColor2.Alpha) then
    Result := True
  else
    Result := False;
end;

function  TGame.GetTime: Double;
begin
   Result := al_get_time;
end;

procedure TGame.ResetTiming;
begin
  FTimer.LNow := 0;
  FTimer.Passed := 0;
  FTimer.Last := 0;

  FTimer.Accumulator := 0;
  FTimer.FrameAccumulator := 0;

  FTimer.DeltaTime := 0;

  FTimer.FrameCount := 0;
  FTimer.FrameRate := 0;

  SetUpdateSpeed(FTimer.UpdateSpeed);

  FTimer.Last := GetTime;
end;

procedure TGame.SetUpdateSpeed(aSpeed: Single);
begin
  FTimer.UpdateSpeed := aSpeed;
  FTimer.DeltaTime := 1.0 / FTimer.UpdateSpeed;
end;

function  TGame.GetUpdateSpeed: Single;
begin
  Result := FTimer.UpdateSpeed;
end;

function  TGame.GetDeltaTime: Double;
begin
  Result := FTimer.DeltaTime;
end;

function  TGame.GetFrameRate: Cardinal;
begin
  Result := FTimer.FrameRate;
end;

function  TGame.FrameSpeed(var aTimer: Single; aSpeed: Single): Boolean;
begin
  Result := False;
  aTimer := aTimer + (aSpeed / FTimer.UpdateSpeed);
  if aTimer >= 1.0 then
  begin
    aTimer := 0;
    Result := True;
  end;
end;

function  TGame.FrameElapsed(var aTimer: Single; aFrames: Single): Boolean;
begin
  Result := False;
  aTimer := aTimer + FTimer.DeltaTime;
  if aTimer > aFrames then
  begin
    aTimer := 0;
    Result := True;
  end;
end;

// Window
function  TGame.OpenWindow(aWidth: Integer; aHeight: Integer; aTitle: string; aFullscreen: Boolean): Boolean;
var
  LMarshaller: TMarshaller;
begin
  Result := False;
  if FWindow.Handle <> nil then Exit;
  al_set_new_display_flags(ALLEGRO_OPENGL_3_0 or ALLEGRO_RESIZABLE or ALLEGRO_PROGRAMMABLE_PIPELINE);
  al_set_new_display_option(ALLEGRO_COMPATIBLE_DISPLAY, 1, ALLEGRO_REQUIRE);
  al_set_new_display_option(ALLEGRO_VSYNC, 1, ALLEGRO_SUGGEST);
  al_set_new_display_option(ALLEGRO_CAN_DRAW_INTO_BITMAP, 1, ALLEGRO_REQUIRE);
  al_set_new_display_option(ALLEGRO_SAMPLE_BUFFERS, 1, ALLEGRO_SUGGEST);
  al_set_new_display_option(ALLEGRO_SAMPLES, 8, ALLEGRO_SUGGEST);
  al_set_new_window_title(LMarshaller.AsUtf8(aTitle).ToPointer);
  FWindow.Handle := al_create_display(aWidth, aHeight);
  if FWindow.Handle = nil then Exit;
  LoadDefaultIcon(al_get_win_window_handle(FWindow.Handle));
  al_register_event_source(FQueue, al_get_display_event_source(FWindow.Handle));
  FWindow.Size.X := aWidth;
  FWindow.Size.Y := aHeight;
  FWindow.Fullscreen := aFullscreen;
  TransformScale(aFullscreen);
end;

procedure TGame.CloseWindow;
begin
  if FWindow.Handle = nil then Exit;
  DestroyAllViewports;
  UnloadAllFonts;
  UnloadAllBitmaps;
  al_destroy_display(FWindow.Handle);
end;

procedure TGame.SetWindowTitle(const aTitle: string);
var
  LMarshaller: TMarshaller;
begin
  if FWindow.Handle = nil then Exit;
  al_set_window_title(FWindow.Handle, LMarshaller.AsUtf8(aTitle).ToPointer);
end;

function  TGame.IsWindowOpen: Boolean;
begin
  Result := Boolean(FWindow.Handle <> nil);
end;

procedure TGame.ClearWindow(aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FWindow.Handle = nil then Exit;
  al_clear_to_color(LColor);
end;

procedure TGame.ShowWindow;
begin
  if FWindow.Handle = nil then Exit;
  al_flip_display;
end;

procedure TGame.ToggleFullscreenWindow;
var
  LFlags: Integer;
  LFullscreen: Boolean;
  LMX, LMY: Integer;

  function IsOnPrimaryMonitor: Boolean;
  begin
    Result := Screen.MonitorFromWindow(al_get_win_window_handle(FWindow.Handle), mdPrimary).Primary
  end;

begin
  if FWindow.Handle = nil then Exit;
  MouseGetInfo(@LMX, @LMY, nil);
  LFlags := al_get_display_flags(FWindow.Handle);
  LFullscreen := Boolean(LFlags and ALLEGRO_FULLSCREEN_WINDOW = ALLEGRO_FULLSCREEN_WINDOW);
  LFullscreen := not LFullscreen;

  // we can only go fullscreen on primrary monitor
  if LFullscreen and (not IsOnPrimaryMonitor) then Exit;
  //if LFullscreen then Exit;


  al_set_display_flag(FWindow.Handle, ALLEGRO_FULLSCREEN_WINDOW, LFullscreen);
  TransformScale(LFullscreen);
  FWindow.Fullscreen := LFullscreen;
  //if not FFullscreen then ResizeForDPI;
  MouseSetPos(LMX, LMY);
  MouseShowCursor(True);
  //Piro.ResetTiming;
end;

function  TGame.IsWindowFullscreen: Boolean;
begin
  Result := FWindow.Fullscreen;
end;

procedure TGame.SetWindowTarget(aBitmap: Int64);
var
  LBitmap: TBitmap;
begin
  if aBitmap = ID_NIL then Exit;
  if not FBitmapList.TryGetValue(aBitmap, LBitmap) then Exit;
  if LBitmap.Handle = nil then Exit;
  al_set_target_bitmap(LBitmap.Handle);
end;

procedure TGame.ResetWindowTarget;
begin
  if FWindow.Handle = nil then Exit;
  al_set_target_backbuffer(FWindow.Handle);
end;

// TODO: handle case where viewport object is destroyed
// while still being active, FViewport will then be
// invalid. A possible solution would be to have a parent
// in TViewport and if its destroyed then let parent know
// so it can take appropriet action
// UPDATE: now what I do is if the current view is about
// to be destroyed, if its active, it call SetViewport(ID_NIL)
// to deactivate before its released to set the viewport
// back to full screen.
procedure TGame.SetWindowViewport(aViewport: Int64);
begin
  if FWindow.Handle = nil then Exit;

  if aViewport <> ID_NIL then
    begin
      // check if same as current
      if FWindow.Viewport = aViewport then
        Exit
      else
      // setting a new viewport when one is current
      begin
        // set to not active to show it
        if FWindow.Viewport <> ID_NIL then
        begin
          SetViewportActive(FWindow.Viewport, False);
        end;
      end;

      FWindow.Viewport := aViewport;
      SetViewportActive(FWindow.Viewport, True);
    end
  else
    begin
      if FWindow.Viewport <> ID_NIL then
      begin
        SetViewportActive(FWindow.Viewport, False);
        FWindow.Viewport := ID_NIL;
      end;
    end;
end;

procedure TGame.GetWindowViewportSize(aX: PInteger; aY: PInteger; aWidth: PInteger; aHeight: PInteger);
begin
  if FWindow.Handle = nil then Exit;

  if FWindow.Viewport <> ID_NIL then
    begin
      GetViewportSize(FWindow.Viewport, aX, aY, aWidth, aHeight);
    end
  else
    begin
      if aX <> nil then
        aX^ := 0;
      if aY <> nil then
        aY^ := 0;
      GetWindowSize(aWidth, aHeight);
    end;
end;

procedure TGame.GetWindowViewportSize(var aSize: TRectangle);
var
  LVX,LVY,LVW,LVH: Integer;
begin
  GetWindowViewportSize(@LVX, @LVY, @LVW, @LVH);
  aSize.X := LVX;
  aSize.Y := LVY;
  aSize.Width := LVW;
  aSize.Height := LVH;
end;

procedure TGame.GetWindowSize(aWidth: System.PInteger; aHeight: System.PInteger; aAspectRatio: System.PSingle);
begin
  if FWindow.Handle = nil then  Exit;
  if aWidth <> nil then
    aWidth^ := Round(FWindow.Size.X);

  if aHeight <> nil then
    aHeight^ := Round(FWindow.Size.Y);

  if aAspectRatio <> nil then
    aAspectRatio^ := FWindow.Size.X / FWindow.Size.Y;
end;

procedure TGame.ResetWindowTransform;
begin
  if FWindow.Handle = nil then Exit;
  al_use_transform(@FWindow.Trans);
end;

procedure TGame.SetWindowTransformPosition(aX: Integer; aY: Integer);
var
  LTrans: ALLEGRO_TRANSFORM;
begin
  if FWindow.Handle = nil then Exit;
  al_copy_transform(@LTrans, al_get_current_transform);
  al_translate_transform(@LTrans, aX, aY);
  al_use_transform(@LTrans);
end;
procedure TGame.SetWindowTransformAngle(aAngle: Single);
var
  LTrans: ALLEGRO_TRANSFORM;
  LX, LY: Integer;
begin
  if FWindow.Handle = nil then Exit;
  LX := al_get_display_width(FWindow.Handle);
  LY := al_get_display_height(FWindow.Handle);

  al_copy_transform(@FWindow.Trans, al_get_current_transform);
  al_translate_transform(@FWindow.Trans, -(LX div 2), -(LY div 2));
  al_rotate_transform(@LTrans, aAngle * DEG2RAD);
  al_translate_transform(@LTrans, 0, 0);
  al_translate_transform(@LTrans, LX div 2, LY div 2);
  al_use_transform(@LTrans);
end;

function TGame.SaveWindow(const aFilename: string): Boolean;
var
  LBackbuffer: PALLEGRO_BITMAP;
  LScreenshot: PALLEGRO_BITMAP;
  LVX, LVY, LVW, LVH: Integer;
  LFilename: string;
  LMarshallar: TMarshaller;
begin
  Result := False;

  if FWindow.Handle = nil then Exit;

  // get viewport size
  LVX := Round(FWindow.TransSize.X);
  LVY := Round(FWindow.TransSize.Y);
  LVW := Round(FWindow.TransSize.Width);
  LVH := Round(FWindow.TransSize.Height);

  // create LScreenshot bitmpat
  al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR or ALLEGRO_MAG_LINEAR);
  LScreenshot := al_create_bitmap(LVW, LVH);

  // exit if failed to create LScreenshot bitmap
  if LScreenshot = nil then Exit;

  // get LBackbuffer
  LBackbuffer := al_get_backbuffer(FWindow.Handle);

  // set target to LScreenshot bitmap
  al_set_target_bitmap(LScreenshot);

  // draw viewport area of LBackbuffer to LScreenshot bitmap
  al_draw_bitmap_region(LBackbuffer, LVX, LVY, LVW, LVH, 0, 0, 0);

  // restore LBackbuffer target
  al_set_target_bitmap(LBackbuffer);

  // make sure filename is a PNG file
  LFilename := aFilename;
  LFilename := ChangeFileExt(LFilename, cPngExt);

  // save screen bitmap to PNG filename
  Result := al_save_bitmap(LMarshallar.AsAnsi(LFilename).ToPointer, LScreenshot);

  // destroy LScreenshot bitmap
  al_destroy_bitmap(LScreenshot);
end;

// Viewport
function TGame.CreateViewport(aX: Integer; aY: Integer; aWidth: Integer; aHeight: Integer): Int64;
var
  LViewport: TViewport;
begin
  Result := ID_NIL;
  LViewport.Bitmap := AllocBitmap(aWidth, aHeight);
  if LViewport.Bitmap = ID_NIL then Exit;
  LViewport.Pos.X := aX;
  LViewport.Pos.Y := aY;
  LViewport.Pos.Width := aWidth;
  LViewport.Pos.Height := aHeight;
  LViewport.Half.X := aWidth/2;
  LViewport.Half.Y := aHeight/2;
  LViewport.Center.Assign(0.5, 0.5);
  LViewport.Active := False;
  Result := GenID;
  FViewportList.Add(Result, LViewport);
end;

procedure TGame.DestroyViewport(var aViewport: Int64);
var
  LViewport: TViewport;
begin
  if not FViewportList.TryGetValue(aViewport, LViewport) then Exit;
  if LViewport.Bitmap = ID_NIL then Exit;
  if LViewport.Active then
  begin
    // this fixes the is issue where if the active viewport is destroyed
    // while active, then just pass ID_NIL to Display.SetViewport to restore
    // the fullscreen viewport instead
    SetWindowViewport(ID_NIL);
  end;
  SetViewportActive(aViewport, False);
  UnloadBitmap(LViewport.Bitmap);
  FViewportList.Remove(aViewport);
  aViewport := ID_NIL;
end;

procedure TGame.DestroyAllViewports;
var
  LItem: Int64;
  LViewport: Int64;
begin
  for LItem in FViewportList.Keys do
  begin
    LViewport := LItem;
    DestroyViewport(LViewport);
  end;
  FViewportList.Clear;
end;

procedure TGame.SetViewportActive(aViewport: Int64; aActive: Boolean);
var
  LViewport: TViewport;
begin
  if not FViewportList.TryGetValue(aViewport, LViewport) then Exit;
  if LViewport.Bitmap = ID_NIL then Exit;

  if aActive then
    begin
      if LViewport.Active then Exit;
      SetWindowTarget(LViewport.Bitmap);
    end
  else
    begin
      if not LViewport.Active then Exit;
      ResetWindowTarget;
      DrawBitmap(LViewport.Bitmap, LViewport.Pos.X+LViewport.Half.X, LViewport.Pos.Y+LViewport.Half.Y, nil, @LViewport.Center, nil, LViewport.Angle, WHITE, False, False);
    end;

  LViewport.Active := aActive;
  FViewportList.Items[aViewport] := LViewport;
end;

function  TGame.GetViewportActive(aViewport: Int64): Boolean;
var
  LViewport: TViewport;
begin
  Result := False;
  if not FViewportList.TryGetValue(aViewport, LViewport) then Exit;
  Result := LViewport.Active;
end;

procedure TGame.SetViewportPosition(aViewport: Int64; aX: Integer; aY: Integer);
var
  LViewport: TViewport;
begin
  if not FViewportList.TryGetValue(aViewport, LViewport) then Exit;
  LViewport.Pos.X := aX;
  LViewport.Pos.Y := aY;
  FViewportList.Items[aViewport] := LViewport;
end;

procedure TGame.GetViewportSize(aViewport: Int64; aX: PInteger; aY: PInteger; aWidth: PInteger; aHeight: PInteger);
var
  LViewport: TViewport;
begin
  if not FViewportList.TryGetValue(aViewport, LViewport) then Exit;
  if LViewport.Bitmap = ID_NIL then Exit;

  if aX <> nil then
    aX^ := Round(LViewport.Pos.X);
  if aY <>nil then
    aY^ := Round(LViewport.Pos.Y);
  if aWidth <> nil then
    aWidth^ := Round(LViewport.Pos.Width);
  if aHeight <> nil then
    aHeight^ := Round(LViewport.Pos.Height);
end;

procedure TGame.SetViewportAngle(aViewport: Int64; aAngle: Single);
var
  LViewport: TViewport;
begin
  if not FViewportList.TryGetValue(aViewport, LViewport) then Exit;
  LViewport.Angle := aAngle;
  //gEngine.Math.ClipValue(FAngle, 0, 359, True);
  if LViewport.Angle > 359 then
    begin
      while LViewport.Angle > 359 do
      begin
        LViewport.Angle := LViewport.Angle - 359;
      end;
    end
  else
  if LViewport.Angle < 0 then
    begin
      while LViewport.Angle < 0 do
      begin
        LViewport.Angle := LViewport.Angle + 359;
      end;
    end;
  FViewportList.Items[aViewport] := LViewport;
end;

function  TGame.GetViewportAngle(aViewport: Int64): Single;
var
  LViewport: TViewport;
begin
  Result := 0;
  if not FViewportList.TryGetValue(aViewport, LViewport) then Exit;
  Result := LViewport.Angle;
end;

procedure TGame.AlignViewport(aViewport: Int64; var aX: Single; var aY: Single);
var
  LViewport: TViewport;
begin
  if not FViewportList.TryGetValue(aViewport, LViewport) then Exit;
  aX := LViewport.Pos.X + aX;
  aY := LViewport.Pos.Y + aY;
end;

procedure TGame.AlignViewport(aViewport: Int64; var aPos: TVector);
var
  LViewport: TViewport;
begin
  if not FViewportList.TryGetValue(aViewport, LViewport) then Exit;
  aPos.X := LViewport.Pos.X + aPos.X;
  aPos.Y := LViewport.Pos.Y + aPos.Y;
end;

procedure TGame.ResetViewport;
begin
  if FWindow.Handle = nil then Exit;
  if FWindow.Viewport <> ID_NIL then
  begin
    SetViewportActive(FWindow.Viewport, False);
  end;
end;

// Input
procedure TGame.ClearInput;
begin
  FillChar(FInput.MouseButtons, SizeOf(FInput.MouseButtons), False);
  FillChar(FInput.KeyButtons, SizeOf(FInput.KeyButtons), False);
  FillChar(FInput.JoyButtons, SizeOf(FInput.JoyButtons), False);

  if FWindow.Handle <> nil then
  begin
    al_clear_keyboard_state(FWindow.Handle);
  end;
end;

function TGame.KeyboardPressed(aKey: Integer): Boolean;
begin
  Result := False;
  if not InRange(aKey, 0, 255) then  Exit;
  if KeyboardDown(aKey) and (not FInput.KeyButtons[aKey]) then
  begin
    FInput.KeyButtons[aKey] := True;
    Result := True;
  end
  else if (not KeyboardDown(aKey)) and (FInput.KeyButtons[aKey]) then
  begin
    FInput.KeyButtons[aKey] := False;
    Result := False;
  end;
end;

function TGame.KeyboardReleased(aKey: Integer): Boolean;
begin
  Result := False;
  if not InRange(aKey, 0, 255) then Exit;
  if KeyboardDown(aKey) and (not FInput.KeyButtons[aKey]) then
  begin
    FInput.KeyButtons[aKey] := True;
    Result := False;
  end
  else if (not KeyboardDown(aKey)) and (FInput.KeyButtons[aKey]) then
  begin
    FInput.KeyButtons[aKey] := False;
    Result := True;
  end;
end;

function TGame.KeyboardDown(aKey: Integer): Boolean;
begin
  Result := False;
  if not InRange(aKey, 0, 255) then Exit;
  Result := al_key_down(@FInput.KeyboardState, aKey);
end;

function TGame.KeyboardGetPressed: Integer;
begin
  Result := FInput.KeyCode;
end;

function TGame.MousePressed(aButton: Integer): Boolean;
begin
  Result := False;
  if not InRange(aButton, MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE) then Exit;

  if MouseDown(aButton) and (not FInput.MouseButtons[aButton]) then
  begin
    FInput.MouseButtons[aButton] := True;
    Result := True;
  end
  else if (not MouseDown(aButton)) and (FInput.MouseButtons[aButton]) then
  begin
    FInput.MouseButtons[aButton] := False;
    Result := False;
  end;
end;

function TGame.MouseReleased(aButton: Integer): Boolean;
begin
  Result := False;
  if not InRange(aButton, MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE) then Exit;

  if MouseDown(aButton) and (not FInput.MouseButtons[aButton]) then
  begin
    FInput.MouseButtons[aButton] := True;
    Result := False;
  end
  else if (not MouseDown(aButton)) and (FInput.MouseButtons[aButton]) then
  begin
    FInput.MouseButtons[aButton] := False;
    Result := True;
  end;

end;

function TGame.MouseDown(aButton: Integer): Boolean;
var
  LState: ALLEGRO_MOUSE_STATE;
begin
  Result := False;
  if not InRange(aButton, MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE) then Exit;
  al_get_mouse_state(@LState);
  Result := al_mouse_button_down(@LState, aButton);
end;

procedure TGame.MouseGetInfo(var aPos: TVector);
var
  LX, LY, LZ: Integer;
begin
  MouseGetInfo(@LX, @LY, @LZ);
  aPos.x := LX;
  aPos.y := LY;
  aPos.z := LZ;
end;

procedure TGame.MouseGetInfo(aX: PInteger; aY: PInteger; aWheel: PInteger);
var
  LState: ALLEGRO_MOUSE_STATE;
  LMX, LMY, LMW: Integer;
  LVX, LVY: Integer;
begin

  LVX := Round(FWindow.TransSize.x);
  LVY := Round(FWindow.TransSize.y);

  al_get_mouse_state(@LState);
  LMX := al_get_mouse_state_axis(@LState, 0);
  LMY := al_get_mouse_state_axis(@LState, 1);
  LMW := al_get_mouse_state_axis(@LState, 2);

  var LDpi: Integer := GetDpiForWindow(al_get_win_window_handle(FWindow.Handle));
  if (LDpi <> DISPLAY_DEFAULT_DPI) then
  begin
    LMX := Round((LMX - LVX) / FWindow.TransScale);
    LMY := Round((LMY - LVY) / FWindow.TransScale);
  end;

  if aX <> nil then
  begin
    aX^ := LMX;
  end;

  if aY <> nil then
  begin
    aY^ := LMY;
  end;

  if aWheel <> nil then
  begin
    aWheel^ := LMW;
  end;

end;

procedure TGame.MouseSetPos(aX: Integer; aY: Integer);
var
  LMX, LMY: Integer;
  LVX, LVY: Integer;
begin
  LMX := aX;
  LMY := aY;

  LVX := Round(FWindow.TransSize.x);
  LVY := Round(FWindow.TransSize.y);

  var LDpi: Integer := GetDpiForWindow(al_get_win_window_handle(FWindow.Handle));
  if (LDpi <> DISPLAY_DEFAULT_DPI) then
  begin
    LMX := Round(LMX * FWindow.TransScale) + LVX;
    LMY := Round(LMY * FWindow.TransScale) + LVY;
  end;

  al_set_mouse_xy(FWindow.Handle, LMX, LMY);
end;

procedure TGame.MouseShowCursor(aShow: Boolean);
begin
end;

function TGame.JoystickGetPos(aStick: Integer; aAxes: Integer): Single;
begin
  Result := FInput.Joystick.Pos[aStick, aAxes];
end;

function TGame.JoystickDown(aButton: Integer): Boolean;
begin
  Result := FInput.Joystick.Button[aButton];
end;

function TGame.JoystickPressed(aButton: Integer): Boolean;
begin
  Result := False;
  if not InRange(aButton, 0, MAX_BUTTONS) then Exit;

  if JoystickDown(aButton) and (not FInput.JoyButtons[aButton]) then
  begin
    FInput.JoyButtons[aButton] := True;
    Result := True;
  end
  else if (not JoystickDown(aButton)) and (FInput.JoyButtons[aButton]) then
  begin
    FInput.JoyButtons[aButton] := False;
    Result := False;
  end;
end;

function TGame.JoystickReleased(aButton: Integer): Boolean;
begin
  Result := False;
  if not InRange(aButton, 0, MAX_BUTTONS) then Exit;

  if JoystickDown(aButton) and (not FInput.JoyButtons[aButton]) then
  begin
    FInput.JoyButtons[aButton] := True;
    Result := False;
  end
  else if (not JoystickDown(aButton)) and (FInput.JoyButtons[aButton]) then
  begin
    FInput.JoyButtons[aButton] := False;
    Result := True;
  end;
end;

// Rendering
procedure TGame.DrawLine(aX1, aY1, aX2, aY2: Single; aColor: TColor; aThickness: Single);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FWindow.Handle = nil then Exit;
  al_draw_line(aX1, aY1, aX2, aY2, LColor, aThickness);
end;

procedure TGame.DrawRectangle(aX, aY, aWidth, aHeight, aThickness: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FWindow.Handle = nil then Exit;
  al_draw_rectangle(aX, aY, aX + aWidth, aY + aHeight, LColor, aThickness);
end;

procedure TGame.DrawFilledRectangle(aX, aY, aWidth, aHeight: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FWindow.Handle = nil then Exit;
  al_draw_filled_rectangle(aX, aY, aX + aWidth, aY + aHeight, LColor);
end;

procedure TGame.DrawCircle(aX, aY, aRadius, aThickness: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FWindow.Handle = nil then Exit;
  al_draw_circle(aX, aY, aRadius, LColor, aThickness);
end;

procedure TGame.DrawFilledCircle(aX, aY, aRadius: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FWindow.Handle = nil then Exit;
  al_draw_filled_circle(aX, aY, aRadius, LColor);
end;

procedure TGame.DrawPolygon(aVertices: System.PSingle; aVertexCount: Integer; aThickness: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FWindow.Handle = nil then Exit;
  al_draw_polygon(WinApi.Windows.PSingle(aVertices), aVertexCount, ALLEGRO_LINE_JOIN_ROUND, LColor, aThickness, 1.0);
end;

procedure TGame.DrawFilledPolygon(aVertices: System.PSingle; aVertexCount: Integer; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FWindow.Handle = nil then Exit;
  al_draw_filled_polygon(WinApi.Windows.PSingle(aVertices), aVertexCount, LColor);
end;

procedure TGame.DrawTriangle(aX1, aY1, aX2, aY2, aX3, aY3, aThickness: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FWindow.Handle = nil then Exit;
  al_draw_triangle(aX1, aY1, aX2, aY2, aX3, aY3, LColor, aThickness);
end;

procedure TGame.DrawFilledTriangle(aX1, aY1, aX2, aY2, aX3, aY3: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FWindow.Handle = nil then Exit;
  al_draw_filled_triangle(aX1, aY1, aX2, aY2, aX3, aY3, LColor);
end;

procedure TGame.SetBlender(aOperation: Integer; aSource: Integer; aDestination: Integer);
begin
  if FWindow.Handle = nil then Exit;
  al_set_blender(aOperation, aSource, aDestination);
end;

procedure TGame.GetBlender(aOperation: PInteger; aSource: PInteger; aDestination: PInteger);
begin
  if FWindow.Handle = nil then Exit;
  al_get_blender(aOperation, aSource, aDestination);
end;

procedure TGame.SetBlendColor(aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if FWindow.Handle = nil then Exit;
  al_set_blend_color(LColor);
end;

function TGame.GetBlendColor: TColor;
var
  LResult: ALLEGRO_COLOR absolute Result;
begin
  Result := BLANK;
  if FWindow.Handle = nil then Exit;
  LResult := al_get_blend_color;
end;

procedure TGame.SetBlendMode(aMode: TBlendMode);
begin
  if FWindow.Handle = nil then Exit;

  case aMode of
    bmPreMultipliedAlpha:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_INVERSE_ALPHA);
      end;
    bmNonPreMultipliedAlpha:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_ALPHA, ALLEGRO_INVERSE_ALPHA);
      end;
    bmAdditiveAlpha:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_ONE);
      end;
    bmCopySrcToDest:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_ZERO);
      end;
    bmMultiplySrcAndDest:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_DEST_COLOR, ALLEGRO_ZERO)
      end;
  end;
end;

procedure TGame.SetBlendModeColor(aMode: TBlendModeColor; aColor: TColor);
begin
  if FWindow.Handle = nil then Exit;
  case aMode of
    bcColorNormal:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_ONE);
        al_set_blend_color(al_map_rgba_f(aColor.red, aColor.green, aColor.blue, aColor.alpha));
      end;
    bcColorAvgSrcDest:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR);
        al_set_blend_color(al_map_rgba_f(aColor.red, aColor.green, aColor.blue, aColor.alpha));
      end;
  end;
end;

procedure TGame.RestoreDefaultBlendMode;
begin
  if FWindow.Handle = nil then  Exit;
  al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_INVERSE_ALPHA);
  al_set_blend_color(al_map_rgba(255, 255, 255, 255));
end;

// Font
function  TGame.LoadFont(aSize: Cardinal): Int64;
var
  LStream: TResourceStream;
begin
  LStream := TResourceStream.Create(HInstance, 'DEFAULTFONT', RT_RCDATA);
  try
    Result := LoadFont(aSize, LStream.Memory, LStream.Size);
  finally
    FreeAndNil(LStream);
  end;
end;

function  TGame.LoadFont(aSize: Cardinal; const aFilename: string): Int64;
var
  LMarshaller: TMarshaller;
  LFont: TFont;
begin
  Result := ID_NIL;
  if aFilename.IsEmpty then Exit;
  al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR or ALLEGRO_MAG_LINEAR or ALLEGRO_MIPMAP or ALLEGRO_VIDEO_BITMAP);
  LFont.Handle := al_load_font(LMarshaller.AsUtf8(aFilename).ToPointer, -aSize, 0);
  if LFont.Handle = nil then Exit;
  LFont.Filename := aFilename;
  LFont.Size := aSize;
  Result := GenID;
  FFontList.Add(Result, LFont);
end;

function TGame.LoadFont(aSize: Cardinal; aMemory: Pointer; aLength: Int64): Int64;
var
  LMemFile: PALLEGRO_FILE;
  LFont: TFont;
begin
  Result := ID_NIL;
  LMemFile := al_open_memfile(aMemory, aLength, 'rb');
  if LMemFile = nil then Exit;
  al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR or ALLEGRO_MAG_LINEAR or ALLEGRO_MIPMAP or ALLEGRO_VIDEO_BITMAP);
  LFont.Handle := al_load_ttf_font_f(LMemFile, '', -aSize, 0);
  if LFont.Handle = nil then
  begin
    al_fclose(LMemFile);
    Exit;
  end;
  LFont.Filename := '';
  LFont.Size := aSize;
  Result := GenID;
  FFontList.Add(Result, LFont);
end;

procedure TGame.UnloadFont(var aFont: Int64);
var
  LFont: TFont;
begin
  if not FFontList.TryGetValue(aFont, LFont) then Exit;
  if LFont.Handle = nil then Exit;
  al_destroy_font(LFont.Handle);
  FFontlist.Remove(aFont);
  aFont := ID_NIL;
end;

procedure TGame.UnloadAllFonts;
var
  LFont: TFont;
begin
  for LFont in FFontList.Values do
  begin
    if LFont.Handle <> nil then
    begin
      al_destroy_font(LFont.Handle);
    end;
  end;
  FFontList.Clear;
end;

procedure TGame.PrintText(aFont: Int64; aX: Single; aY: Single; aColor: TColor; aAlign: THAlign; const aMsg: string; const aArgs: array of const);
var
  LUstr: PALLEGRO_USTR;
  LText: string;
  LColor: ALLEGRO_COLOR absolute aColor;
  LFont: TFont;
begin
  if not FFontList.TryGetValue(aFont, LFont) then Exit;
  if LFont.Handle = nil then Exit;
  LText := Format(aMsg, aArgs);
  if LText.IsEmpty then  Exit;
  LUstr := al_ustr_new_from_utf16(PUInt16(PChar(LText)));
  al_draw_ustr(LFont.Handle, LColor, aX, aY, Ord(aAlign) or ALLEGRO_ALIGN_INTEGER, LUstr);
  al_ustr_free(LUstr);
end;

procedure TGame.PrintText(aFont: Int64; aX: Single; var aY: Single; aLineSpace: Single; aColor: TColor; aAlign: THAlign; const aMsg: string; const aArgs: array of const);
begin
  PrintText(aFont, aX, aY, aColor, aAlign, aMsg, aArgs);
  aY := aY + GetLineHeight(aFont) + aLineSpace;
end;

procedure TGame.PrintText(aFont: Int64; aX: Single; aY: Single; aColor: TColor; aAngle: Single; const aMsg: string; const aArgs: array of const);
var
  LUstr: PALLEGRO_USTR;
  LText: string;
  LFX, LFY: Single;
  LTR: ALLEGRO_TRANSFORM;
  LColor: ALLEGRO_COLOR absolute aColor;
  LTrans: ALLEGRO_TRANSFORM;
  LFont: TFont;
begin
  if not FFontList.TryGetValue(aFont, LFont) then Exit;
  if LFont.Handle = nil then Exit;
  LText := Format(aMsg, aArgs);
  if LText.IsEmpty then Exit;
  LFX := GetTextWidth(aFont, LText, []) / 2;
  LFY := GetLineHeight(aFont) / 2;
  al_identity_transform(@LTR);
  al_translate_transform(@LTR, -LFX, -LFY);
  al_rotate_transform(@LTR, aAngle * DEG2RAD);
  AngleRotatePos(aAngle, LFX, LFY);
  al_translate_transform(@LTR, aX + LFX, aY + LFY);
  LTrans := FWindow.Trans;
  al_compose_transform(@LTR, @LTrans);
  al_use_transform(@LTR);
  LUstr := al_ustr_new_from_utf16(PUInt16(PChar(LText)));
  al_draw_ustr(LFont.Handle, LColor, 0, 0, ALLEGRO_ALIGN_LEFT or ALLEGRO_ALIGN_INTEGER, LUstr);
  al_ustr_free(LUstr);
  LTrans := FWindow.Trans;
  al_use_transform(@LTrans);
end;

function  TGame.GetTextWidth(aFont: Int64; const aMsg: string; const aArgs: array of const): Single;
var
  LUstr: PALLEGRO_USTR;
  LText: string;
  LFont: TFont;
begin
  Result := 0;
  if not FFontList.TryGetValue(aFont, LFont) then Exit;
  if LFont.Handle = nil then Exit;
  LText := Format(aMsg, aArgs);
  if LText.IsEmpty then  Exit;
  LUstr := al_ustr_new_from_utf16(PUInt16(PChar(LText)));
  Result := al_get_ustr_width(LFont.Handle, LUstr);
  al_ustr_free(LUstr);
end;

function  TGame.GetLineHeight(aFont: Int64): Single;
var
  LFont: TFont;
begin
  Result := 0;
  if not FFontList.TryGetValue(aFont, LFont) then Exit;
  if LFont.Handle = nil then Exit;
  Result := al_get_font_line_height(LFont.Handle);
end;

// Bitmap
function  TGame.AllocBitmap(aWidth: Integer; aHeight: Integer): Int64;
var
  LBitmap: TBitmap;
begin
  Result := ID_NIL;
  al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR or ALLEGRO_MAG_LINEAR or ALLEGRO_MIPMAP or ALLEGRO_VIDEO_BITMAP);
  LBitmap.Handle := al_create_bitmap(aWidth, aHeight);
  if LBitmap.Handle = nil then Exit;
  LBitmap.Width := al_get_bitmap_width(LBitmap.Handle);
  LBitmap.Height := al_get_bitmap_height(LBitmap.Handle);
  LBitmap.Filename := '';
  Result := GenID;
  FBitmapList.Add(Result, LBitmap);
end;

function  TGame.LoadBitmap(const aFilename: string; aColorKey: PColor): Int64;
var
  LMarsheller: TMarshaller;
  LColorKey: PALLEGRO_COLOR absolute aColorKey;
  LBitmap: TBitmap;
begin
  Result := ID_NIL;
  if aFilename.IsEmpty then Exit;
  if not al_filename_exists(LMarsheller.AsUtf8(aFilename).ToPointer) then Exit;
  al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR or ALLEGRO_MAG_LINEAR or ALLEGRO_VIDEO_BITMAP);
  LBitmap.Handle := al_load_bitmap(LMarsheller.AsAnsi(aFilename).ToPointer);
  if LBitmap.Handle = nil then Exit;
  LBitmap.Width := al_get_bitmap_width(LBitmap.Handle);
  LBitmap.Height := al_get_bitmap_height(LBitmap.Handle);
  // apply colorkey
  if aColorKey <> nil then
    al_convert_mask_to_alpha(LBitmap.Handle, LColorKey^);
  LBitmap.Filename := aFilename;
  Result := GenID;
  FBitmapList.Add(Result, LBitmap);
end;

procedure TGame.UnloadBitmap(var aBitmap: Int64);
var
  LBitmap: TBitmap;
begin
  if not FBitmapList.TryGetValue(aBitmap, LBitmap) then Exit;
  if LBitmap.Handle = nil then Exit;
  al_destroy_bitmap(LBitmap.Handle);
  FBitmapList.Remove(aBitmap);
  aBitmap := ID_NIL;
end;

procedure TGame.UnloadAllBitmaps;
var
  LBitmap: TBitmap;
begin
  for LBitmap in FBitmapList.Values do
  begin
    if LBitmap.Handle <> nil then
    begin
       al_destroy_bitmap(LBitmap.Handle);
    end;
  end;
  FBitmapList.Clear;
end;

procedure TGame.GetBitmapSize(aBitmap: Int64; var aSize: TVector);
var
  LBitmap: TBitmap;
begin
  if not FBitmapList.TryGetValue(aBitmap, LBitmap) then Exit;
  if LBitmap.Handle = nil then Exit;
  aSize.X := LBitmap.Width;
  aSize.Y := LBitmap.Height;
end;

procedure TGame.GetBitmapSize(aBitmap: Int64; aWidth: PSingle; aHeight: PSingle);
var
  LBitmap: TBitmap;
begin
  if not FBitmapList.TryGetValue(aBitmap, LBitmap) then Exit;
  if LBitmap.Handle = nil then Exit;
  if aWidth <> nil then aWidth^ := LBitmap.Width;
  if aHeight <> nil then aHeight^ := LBitmap.Height;
end;

procedure TGame.LockBitmap(aBitmap: Int64; aRegion: PRectangle; aData: PBitmapData=nil);
var
  LLock: PALLEGRO_LOCKED_REGION;
  LBitmap: TBitmap;
begin
  if not FBitmapList.TryGetValue(aBitmap, LBitmap) then Exit;
  if LBitmap.Handle = nil then Exit;

  LLock := nil;

  if not LBitmap.Locked then
  begin
    if aRegion <> nil then
      begin
        LLock := al_lock_bitmap_region(LBitmap.Handle, Round(aRegion.X), Round(aRegion.Y), Round(aRegion.Width), Round(aRegion.Height), ALLEGRO_PIXEL_FORMAT_ANY, ALLEGRO_LOCK_READWRITE);
        LBitmap.LockedRegion.X := aRegion.X;
        LBitmap.LockedRegion.Y := aRegion.Y;
        LBitmap.LockedRegion.Width := aRegion.Width;
        LBitmap.LockedRegion.Height := aRegion.Height;
      end
    else
      begin
        LLock := al_lock_bitmap(LBitmap.Handle, ALLEGRO_PIXEL_FORMAT_ANY, ALLEGRO_LOCK_READWRITE);
        LBitmap.LockedRegion.X := 0;
        LBitmap.LockedRegion.Y := 0;
        LBitmap.LockedRegion.Width := LBitmap.Width;
        LBitmap.LockedRegion.Height := LBitmap.Height;
      end;
    LBitmap.Locked := True;
    //Display.SetTarget(FHandle);
  end;

  if LLock <> nil then
  begin
    if aData <> nil then
    begin
      aData.Memory := LLock.data;
      aData.Format := LLock.format;
      aData.Pitch := LLock.pitch;
      aData.PixelSize := LLock.pixel_size;
    end;
  end;

end;

procedure TGame.UnlockBitmap(aBitmap: Int64);
var
  LBitmap: TBitmap;
begin
  if not FBitmapList.TryGetValue(aBitmap, LBitmap) then Exit;
  if LBitmap.Handle = nil then Exit;
  if LBitmap.Locked then
  begin
    al_unlock_bitmap(LBitmap.Handle);
    LBitmap.Locked := False;
    LBitmap.LockedRegion.X := 0;
    LBitmap.LockedRegion.Y := 0;
    LBitmap.LockedRegion.Width := 0;
    LBitmap.LockedRegion.Height := 0;
  end;
end;

function  TGame.GetBitmapPixel(aBitmap: Int64; aX: Integer; aY: Integer): TColor;
var
  LX,LY: Integer;
  LResult: ALLEGRO_COLOR absolute Result;
  LBitmap: TBitmap;
begin
  if not FBitmapList.TryGetValue(aBitmap, LBitmap) then Exit;
  if LBitmap.Handle = nil then Exit;

  LX := Round(aX + LBitmap.LockedRegion.X);
  LY := Round(aY + LBitmap.lockedRegion.Y);
  LResult := al_get_pixel(LBitmap.Handle, LX, LY);
end;

procedure TGame.SetBitmapPixel(aBitmap: Int64; aX: Integer; aY: Integer; aColor: TColor);
var
  LX,LY: Integer;
  LColor: ALLEGRO_COLOR absolute aColor;
  LBitmap: TBitmap;
begin
  if not FBitmapList.TryGetValue(aBitmap, LBitmap) then Exit;
  if LBitmap.Handle = nil then Exit;

  LX := Round(aX + LBitmap.LockedRegion.X);
  LY := Round(aY + LBitmap.lockedRegion.Y);
  al_put_pixel(LX, LY, LColor);
end;

procedure TGame.DrawBitmap(aBitmap: Int64; aX, aY: Single; aRegion: PRectangle; aCenter: PVector;  aScale: PVector; aAngle: Single; aColor: TColor; aHFlip: Boolean; aVFlip: Boolean);
var
  LA: Single;
  LRG: TRectangle;
  LCP: TVector;
  LSC: TVector;
  LC: ALLEGRO_COLOR absolute aColor;
  LFlags: Integer;
  LBitmap: TBitmap;
begin
  if not FBitmapList.TryGetValue(aBitmap, LBitmap) then Exit;
  if LBitmap.Handle = nil then Exit;

  // angle
  LA := aAngle * DEG2RAD;

  // region
  if Assigned(aRegion) then
    begin
      LRG.X := aRegion.X;
      LRG.Y := aRegion.Y;
      LRG.Width := aRegion.Width;
      LRG.Height := aRegion.Height;
    end
  else
    begin
      LRG.X := 0;
      LRG.Y := 0;
      LRG.Width := LBitmap.Width;
      LRG.Height := LBitmap.Height;
    end;

  if LRG.X < 0 then
    LRG.X := 0;
  if LRG.X > LBitmap.Width - 1 then
    LRG.X := LBitmap.Width - 1;

  if LRG.Y < 0 then
    LRG.Y := 0;
  if LRG.Y > LBitmap.Height - 1 then
    LRG.Y := LBitmap.Height - 1;

  if LRG.Width < 0 then
    LRG.Width := 0;
  if LRG.Width > LBitmap.Width then
    LRG.Width := LRG.Width;

  if LRG.Height < 0 then
    LRG.Height := 0;
  if LRG.Height > LBitmap.Height then
    LRG.Height := LRG.Height;

  // center
  if Assigned(aCenter) then
    begin
      LCP.X := (LRG.Width * aCenter.X);
      LCP.Y := (LRG.Height * aCenter.Y);
    end
  else
    begin
      LCP.X := 0;
      LCP.Y := 0;
    end;

  // scale
  if Assigned(aScale) then
    begin
      LSC.X := aScale.X;
      LSC.Y := aScale.Y;
    end
  else
    begin
      LSC.X := 1;
      LSC.Y := 1;
    end;

  // flags
  LFlags := 0;
  if aHFlip then LFlags := LFlags or ALLEGRO_FLIP_HORIZONTAL;
  if aVFlip then LFlags := LFlags or ALLEGRO_FLIP_VERTICAL;

  // render
  al_draw_tinted_scaled_rotated_bitmap_region(LBitmap.Handle, LRG.X, LRG.Y, LRG.Width, LRG.Height, LC, LCP.X, LCP.Y, aX, aY, LSC.X, LSC.Y, LA, LFlags);
end;

procedure TGame.DrawBitmap(aBitmap: Int64; aX, aY, aScale, aAngle: Single; aColor: TColor; aHAlign: THAlign; aVAlign: TVAlign; aHFlip: Boolean=False; aVFlip: Boolean=False);
var
  LCenter: TVector;
  LScale: TVector;
  LBitmap: TBitmap;
begin
  if not FBitmapList.TryGetValue(aBitmap, LBitmap) then Exit;
  if LBitmap.Handle = nil then Exit;

  LCenter.X := 0;
  LCenter.Y := 0;

  LScale.X := aScale;
  LScale.Y := aScale;

  case aHAlign of
    haLeft  : LCenter.X := 0;
    haCenter: LCenter.X := 0.5;
    haRight : LCenter.X := 1;
  end;

  case aVAlign of
    vaTop   : LCenter.Y := 0;
    vaCenter: LCenter.Y := 0.5;
    vaBottom: LCenter.Y := 1;
  end;

  DrawBitmap(aBitmap, aX, aY, nil, @LCenter, @LScale, aAngle, aColor, aHFlip, aVFlip);
end;

procedure TGame.DrawTiledBitmap(aBitmap: Int64; aDeltaX: Single; aDeltaY: Single);
var
  LW,LH    : Integer;
  LOX,LOY  : Integer;
  LPX,LPY  : Single;
  LFX,LFY  : Single;
  LTX,LTY  : Integer;
  LVPW,LVPH: Integer;
  LVR,LVB  : Integer;
  LIX,LIY  : Integer;
var
  LBitmap: TBitmap;
begin
  if not FBitmapList.TryGetValue(aBitmap, LBitmap) then Exit;
  if LBitmap.Handle = nil then Exit;

  GetWindowViewportSize(nil, nil, @LVPW, @LVPH);

  LW := Round(LBitmap.Width);
  LH := Round(LBitmap.Height);

  LOX := -LW+1;
  LOY := -LH+1;

  LPX := aDeltaX;
  LPY := aDeltaY;

  LFX := LPX-floor(LPX);
  LFY := LPY-floor(LPY);

  LTX := floor(LPX)-LOX;
  LTY := floor(LPY)-LOY;

  if (LTX>=0) then LTX := LTX mod LW + LOX else LTX := LW - -LTX mod LW + LOX;
  if (LTY>=0) then LTY := LTY mod LH + LOY else LTY := LH - -LTY mod LH + LOY;

  LVR := LVPW;
  LVB := LVPH;
  LIY := LTY;

  while LIY<LVB do
  begin
    LIX := LTX;
    while LIX<LVR do
    begin
      al_draw_bitmap(LBitmap.Handle, LIX+LFX, LIY+LFY, 0);
      LIX := LIX+LW;
    end;
   LIY := LIY+LH;
  end;
end;

// Hud
procedure TGame.HudPos(aX: Integer; aY: Integer);
begin
  FHud.Pos.Assign(aX, aY);
end;

procedure TGame.HudLineSpace(aLineSpace: Integer);
begin
  FHud.Pos.Z := aLineSpace;
end;

procedure TGame.HudTextItemPadWidth(aWidth: Integer);
begin
  FHud.TextItemPadWidth := aWidth;
end;

  procedure TGame.HudText(aFont: Int64; aColor: TColor; aAlign: THAlign; const aMsg: string; const aArgs: array of const);
begin
  PrintText(aFont, FHud.Pos.X, FHud.Pos.Y, FHud.Pos.Z, aColor, aAlign, aMsg, aArgs);
end;

function  TGame.HudTextItem(const aKey: string; const aValue: string; const aSeperator: string='-'): string;
begin
  Result := Format('%s %s %s', [aKey.PadRight(FHud.TextItemPadWidth), aSeperator, aValue]);
end;

// Archive
function TGame.Mount(const aNewDir: string; const aMountPoint: string; aAppendToPath: Boolean): Boolean;
var
  LAppendToPath: Integer;
begin
  if aAppendToPath then
    LAppendToPath := 1
  else
    LAppendToPath := 0;
  Result := Boolean(PHYSFS_mount(PAnsiChar(AnsiString(aNewDir)), PAnsiChar(AnsiString(aMountPoint)), LAppendToPath) <> 0);
end;

function TGame.Unmount(const aOldDir: string): Boolean;
begin
  Result := Boolean(PHYSFS_unmount(PAnsiChar(AnsiString(aOldDir))) <> 0);
end;

// Audio
procedure TGame.PauseAudio(aPause: Boolean);
begin
  if not al_is_audio_installed then Exit;
  al_set_mixer_playing(FAudio.Mixer, not aPause);
end;

procedure TGame.ClearAudio;
begin
  UnloadAllSamples;
  UnloadMusic;
end;

procedure TGame.LoadMusic(const aFilename: string);
var
  LMarshaller: TMarshaller;
begin
  if not al_is_audio_installed then Exit;
  if aFilename.IsEmpty then Exit;
  if not al_filename_exists(LMarshaller.AsUtf8(aFilename).ToPointer) then Exit;
  UnloadMusic;
  FMusic.Handle := al_load_audio_stream(LMarshaller.AsUtf8(aFilename).ToPointer, 4, 2048);
  if FMusic.Handle = nil then Exit;
  //al_register_event_source(FQueue, al_get_audio_stream_event_source(FMusic.Handle));
  al_set_audio_stream_playmode(FMusic.Handle, ALLEGRO_PLAYMODE_ONCE);
  al_attach_audio_stream_to_mixer(FMusic.Handle, FAudio.Mixer);
  //al_attach_audio_stream_to_mixer(FMusic.Handle, al_get_default_mixer());
  al_set_audio_stream_playing(FMusic.Handle, False);
end;

procedure TGame.UnloadMusic;
begin
  if not al_is_audio_installed then Exit;
  if FMusic.Handle <> nil then
  begin
    al_set_audio_stream_playing(FMusic.Handle, False);
    al_drain_audio_stream(FMusic.Handle);
    al_detach_audio_stream(FMusic.Handle);
    al_destroy_audio_stream(FMusic.Handle);
    FMusic.Handle := nil;
  end;
end;

procedure TGame.PlayMusic(aVolume: Single; aLoop: Boolean);
begin
  if not al_is_audio_installed then Exit;
  if FMusic.Handle = nil then Exit;
  StopMusic;
  SetMusicLooping(aLoop);
  SetMusicVolume(aVolume);
  al_rewind_audio_stream(FMusic.Handle);
  SetMusicPlaying(True);
end;

procedure TGame.StopMusic;
begin
  if not al_is_audio_installed then Exit;
  if FMusic.Handle = nil then Exit;
  al_set_audio_stream_playing(FMusic.Handle, False);
  al_rewind_audio_stream(FMusic.Handle);
end;

function  TGame.GetMusicLooping: Boolean;
var
  LMode: ALLEGRO_PLAYMODE;
begin
  Result := False;
  if not al_is_audio_installed then Exit;
  if FMusic.Handle = nil then Exit;

  LMode := al_get_audio_stream_playmode(FMusic.Handle);
  if (LMode = ALLEGRO_PLAYMODE_LOOP) or
     (LMode = _ALLEGRO_PLAYMODE_STREAM_ONEDIR) then
  begin
    Result := True;
  end;
end;

procedure TGame.SetMusicLooping(aLoop: Boolean);
var
  LMode: ALLEGRO_PLAYMODE;
begin
  if not al_is_audio_installed then Exit;
  if aLoop then
    LMode := ALLEGRO_PLAYMODE_LOOP
  else
    LMode := ALLEGRO_PLAYMODE_ONCE;
  al_set_audio_stream_playmode(FMusic.Handle, LMode);
end;

function  TGame.GetMusicPlaying: Boolean;
begin
  Result := False;
  if not al_is_audio_installed then Exit;
  Result := al_get_audio_stream_playing(FMusic.Handle);
end;

procedure TGame.SetMusicPlaying(aPlay: Boolean);
begin
  if not al_is_audio_installed then Exit;
  if FMusic.Handle = nil then Exit;
  al_set_audio_stream_playing(FMusic.Handle, aPlay);
end;

procedure TGame.SetMusicVolume(aVolume: Single);
begin
  if not al_is_audio_installed then Exit;
  if FMusic.Handle = nil then Exit;
  al_set_audio_stream_gain(FMusic.Handle, aVolume);
end;

function  TGame.GetMusicVolume: Single;
begin
  Result := 0;
  if not al_is_audio_installed then Exit;
  if FMusic.Handle = nil then Exit;
  Result := al_get_audio_stream_gain(FMusic.Handle);
end;

procedure TGame.SeekMusic(aTime: Single);
begin
  if FMusic.Handle = nil then Exit;
  if not al_is_audio_installed then Exit;
  al_seek_audio_stream_secs(FMusic.Handle, aTime);
end;

procedure TGame.RewindMusic(aTime: Single);
begin
  if FMusic.Handle = nil then Exit;
  if not al_is_audio_installed then Exit;
  al_rewind_audio_stream(FMusic.Handle);
end;

function  TGame.ReserveSamples(aCount: Integer): Boolean;
begin
  Result := al_reserve_samples(aCount);
end;

function  TGame.LoadSample(const aFilename: string): Int64;
var
  LMarshaller: TMarshaller;
  LSample: TSample;
begin
  Result := ID_NIL;
  if not al_filename_exists(LMarshaller.AsUtf8(aFilename).ToPointer) then Exit;
  LSample.Handle := al_load_sample(LMarshaller.AsUtf8(aFilename).ToPointer);
  if LSample.Handle = nil then Exit;
  Result := GenID;
  FSampleList.Add(Result, LSample);
end;

procedure TGame.UnloadSample(var aSample: Int64);
var
  LSample: TSample;
begin
  if not FSampleList.TryGetValue(aSample, LSample) then Exit;
  if LSample.Handle = nil then Exit;
  al_destroy_sample(LSample.Handle);
  FSampleList.Remove(aSample);
  aSample := ID_NIL;
end;

procedure TGame.UnloadAllSamples;
var
  LItem: Int64;
  LSample: Int64;
begin
  for LItem in FSampleList.Keys do
  begin
    LSample := LItem;
    UnloadSample(LSample);
  end;
  FSampleList.Clear;
end;

procedure TGame.PlaySample(aSample: Int64; aVolume: Single; aPan: Single; aSpeed: Single; aLoop: Boolean; aId: PSampleID);
var
  LSample: TSample;
  LMode: ALLEGRO_PLAYMODE;
  LID: ALLEGRO_SAMPLE_ID;
begin
  if not FSampleList.TryGetValue(aSample, LSample) then Exit;
  if LSample.Handle = nil then Exit;

  if aId <> nil then
  begin
    aId.Index := -1;
    aId.Id := -1;
  end;

  if aLoop then
    LMode := ALLEGRO_PLAYMODE_LOOP
  else
    LMode := ALLEGRO_PLAYMODE_ONCE;

  if al_play_sample(LSample.Handle, aVolume, aPan, aSpeed, LMode, @LID) then
  begin
    if aId <> nil then
    begin
      aId.Index := LID._index;
      aId.Id := LID._id;
    end;
  end;
end;

procedure TGame.StopSample(aID: TSampleID);
var
  LID: ALLEGRO_SAMPLE_ID;
begin
  if IsSamplePlaying(aID) then
  begin
    LID._index := aID.Index;
    LID._id := aID.Id;
    al_stop_sample(@LID);
  end;
end;

procedure TGame.StopAllSamples;
begin
  al_stop_samples;
end;

function  TGame.IsSamplePlaying(aID: TSampleID): Boolean;
var
  LInstance: PALLEGRO_SAMPLE_INSTANCE;
  LID: ALLEGRO_SAMPLE_ID;
begin
  Result := False;
  LID._index := aID.Index;
  LID._id := aID.Id;
  LInstance := al_lock_sample_id(@LID);
  if LInstance <> nil then
  begin
    Result := al_get_sample_instance_playing(LInstance);
    al_unlock_sample_id(@LID);
  end;
end;

// Game
procedure TGame.SetTerminated(aTerminated: Boolean);
begin
  FTerminated := aTerminated;
end;

function  TGame.GetTerminated: Boolean;
begin
  Result := FTerminated;
end;

procedure TGame.OnStartup;
begin
  OpenWindow(960, 540, 'TGame');
end;

procedure TGame.OnShutdown;
begin
  CloseWindow;
end;

procedure TGame.OnUpdateFrame(aDeltaTime: Double);
begin
end;

procedure TGame.OnClearFrame;
begin
  ClearWindow(DARKSLATEBROWN);
end;

procedure TGame.OnRenderFrame;
begin
end;

procedure TGame.OnRenderHUD;
begin
  HudPos(3, 3);
  //PrintText(FFont, 3, 3, WHITE, haLeft, 'fps %d', [GetFrameRate]);
end;

procedure TGame.OnShowFrame;
begin
  ShowWindow;
end;

procedure TGame.Run;
begin
  FTerminated := True;
  FWindow.Ready := False;

  try
    OnStartup;
    ClearInput;
    if IsWindowOpen then
    begin
      ResetTiming;
      FTerminated := False;
      FWindow.Ready := True;
    end;

    while not FTerminated do
    begin
      // input
      FInput.KeyCode := 0;
      al_get_keyboard_state(@FInput.KeyboardState);
      al_get_mouse_state(@FInput.MouseState);

    repeat

      if al_get_next_event(FQueue, @FEvent) then
      begin

        case FEvent.&type of
          ALLEGRO_EVENT_DISPLAY_CLOSE:
            begin
              FTerminated := True;
            end;

          ALLEGRO_EVENT_DISPLAY_RESIZE:
            begin
            end;

          ALLEGRO_EVENT_DISPLAY_DISCONNECTED,
          ALLEGRO_EVENT_DISPLAY_HALT_DRAWING,
          ALLEGRO_EVENT_DISPLAY_LOST,
          ALLEGRO_EVENT_DISPLAY_SWITCH_OUT:
            begin
              // clear input
              if FEvent.&type = ALLEGRO_EVENT_DISPLAY_SWITCH_OUT then
                ClearInput;

              // pause audio
              PauseAudio(True);

              // display not ready
              FWindow.Ready := False;
            end;

          ALLEGRO_EVENT_DISPLAY_CONNECTED,
          ALLEGRO_EVENT_DISPLAY_RESUME_DRAWING,
          ALLEGRO_EVENT_DISPLAY_FOUND,
          ALLEGRO_EVENT_DISPLAY_SWITCH_IN:
            begin
              // reset timing
              ResetTiming;

              // unpause audio
              PauseAudio(False);

              // display ready
              FWindow.Ready := True;
            end;

          ALLEGRO_EVENT_KEY_CHAR:
            begin
              FInput.KeyCode := FEvent.keyboard.unichar;
            end;

          ALLEGRO_EVENT_JOYSTICK_AXIS:
            begin
              if (FEvent.Joystick.stick < MAX_STICKS) and
                (FEvent.Joystick.axis < MAX_AXES) then
              begin
                FInput.Joystick.Pos[FEvent.Joystick.stick][FEvent.Joystick.axis] :=
                  FEvent.Joystick.Pos;
              end;
            end;

          ALLEGRO_EVENT_JOYSTICK_BUTTON_DOWN:
            begin
              FInput.Joystick.Button[FEvent.Joystick.Button] := True;
            end;

          ALLEGRO_EVENT_JOYSTICK_BUTTON_UP:
            begin
              FInput.Joystick.Button[FEvent.Joystick.Button] := False;
            end;

          ALLEGRO_EVENT_JOYSTICK_CONFIGURATION:
            begin
              al_reconfigure_joysticks;
              FInput.Joystick.Setup(0);
            end;

          ALLEGRO_EVENT_VIDEO_FINISHED:
            begin
            end;

        end;
      end;
    until al_is_event_queue_empty(FQueue);

    if FWindow.Ready then
      begin
        //FDisplay.ResetTransform;
        UpdateTiming;
        OnClearFrame;
        OnRenderFrame;
        var trans: ALLEGRO_TRANSFORM := al_get_current_transform^;
        //Display.ResetTransform;
        OnRenderHUD;
        al_use_transform(@trans);
        OnShowFrame;
      end
    else
      begin
        Sleep(1);
      end;
    end;

  finally
    ClearInput;
    OnShutdown;
    ClearAudio;
  end;

end;
{$ENDREGION}

{$REGION '=== ALLEGRO ===================================================================='}

function al_init: Boolean;
begin
  Result := al_install_system(ALLEGRO_VERSION_INT, nil);
end;

var
  LDLL: Pointer;

procedure LoadDLL;
var
  LStream: TResourceStream;
begin
  LStream := TResourceStream.Create(HInstance, 'ALLEGRO', RT_RCDATA);
  try
    LDLL := MemoryLoadLibary(LStream.Memory);

    al_get_allegro_version := MemoryGetProcAddress(LDLL, 'al_get_allegro_version');
    al_run_main := MemoryGetProcAddress(LDLL, 'al_run_main');
    al_get_time := MemoryGetProcAddress(LDLL, 'al_get_time');
    al_rest := MemoryGetProcAddress(LDLL, 'al_rest');
    al_init_timeout := MemoryGetProcAddress(LDLL, 'al_init_timeout');
    al_map_rgb := MemoryGetProcAddress(LDLL, 'al_map_rgb');
    al_map_rgba := MemoryGetProcAddress(LDLL, 'al_map_rgba');
    al_map_rgb_f := MemoryGetProcAddress(LDLL, 'al_map_rgb_f');
    al_map_rgba_f := MemoryGetProcAddress(LDLL, 'al_map_rgba_f');
    al_premul_rgba := MemoryGetProcAddress(LDLL, 'al_premul_rgba');
    al_premul_rgba_f := MemoryGetProcAddress(LDLL, 'al_premul_rgba_f');
    al_unmap_rgb := MemoryGetProcAddress(LDLL, 'al_unmap_rgb');
    al_unmap_rgba := MemoryGetProcAddress(LDLL, 'al_unmap_rgba');
    al_unmap_rgb_f := MemoryGetProcAddress(LDLL, 'al_unmap_rgb_f');
    al_unmap_rgba_f := MemoryGetProcAddress(LDLL, 'al_unmap_rgba_f');
    al_get_pixel_size := MemoryGetProcAddress(LDLL, 'al_get_pixel_size');
    al_get_pixel_format_bits := MemoryGetProcAddress(LDLL, 'al_get_pixel_format_bits');
    al_get_pixel_block_size := MemoryGetProcAddress(LDLL, 'al_get_pixel_block_size');
    al_get_pixel_block_width := MemoryGetProcAddress(LDLL, 'al_get_pixel_block_width');
    al_get_pixel_block_height := MemoryGetProcAddress(LDLL, 'al_get_pixel_block_height');
    al_set_new_bitmap_format := MemoryGetProcAddress(LDLL, 'al_set_new_bitmap_format');
    al_set_new_bitmap_flags := MemoryGetProcAddress(LDLL, 'al_set_new_bitmap_flags');
    al_get_new_bitmap_format := MemoryGetProcAddress(LDLL, 'al_get_new_bitmap_format');
    al_get_new_bitmap_flags := MemoryGetProcAddress(LDLL, 'al_get_new_bitmap_flags');
    al_add_new_bitmap_flag := MemoryGetProcAddress(LDLL, 'al_add_new_bitmap_flag');
    al_get_new_bitmap_depth := MemoryGetProcAddress(LDLL, 'al_get_new_bitmap_depth');
    al_set_new_bitmap_depth := MemoryGetProcAddress(LDLL, 'al_set_new_bitmap_depth');
    al_get_new_bitmap_samples := MemoryGetProcAddress(LDLL, 'al_get_new_bitmap_samples');
    al_set_new_bitmap_samples := MemoryGetProcAddress(LDLL, 'al_set_new_bitmap_samples');
    al_get_bitmap_width := MemoryGetProcAddress(LDLL, 'al_get_bitmap_width');
    al_get_bitmap_height := MemoryGetProcAddress(LDLL, 'al_get_bitmap_height');
    al_get_bitmap_format := MemoryGetProcAddress(LDLL, 'al_get_bitmap_format');
    al_get_bitmap_flags := MemoryGetProcAddress(LDLL, 'al_get_bitmap_flags');
    al_get_bitmap_depth := MemoryGetProcAddress(LDLL, 'al_get_bitmap_depth');
    al_get_bitmap_samples := MemoryGetProcAddress(LDLL, 'al_get_bitmap_samples');
    al_create_bitmap := MemoryGetProcAddress(LDLL, 'al_create_bitmap');
    al_destroy_bitmap := MemoryGetProcAddress(LDLL, 'al_destroy_bitmap');
    al_put_pixel := MemoryGetProcAddress(LDLL, 'al_put_pixel');
    al_put_blended_pixel := MemoryGetProcAddress(LDLL, 'al_put_blended_pixel');
    al_get_pixel := MemoryGetProcAddress(LDLL, 'al_get_pixel');
    al_convert_mask_to_alpha := MemoryGetProcAddress(LDLL, 'al_convert_mask_to_alpha');
    al_get_bitmap_blend_color := MemoryGetProcAddress(LDLL, 'al_get_bitmap_blend_color');
    al_get_bitmap_blender := MemoryGetProcAddress(LDLL, 'al_get_bitmap_blender');
    al_get_separate_bitmap_blender := MemoryGetProcAddress(LDLL, 'al_get_separate_bitmap_blender');
    al_set_bitmap_blend_color := MemoryGetProcAddress(LDLL, 'al_set_bitmap_blend_color');
    al_set_bitmap_blender := MemoryGetProcAddress(LDLL, 'al_set_bitmap_blender');
    al_set_separate_bitmap_blender := MemoryGetProcAddress(LDLL, 'al_set_separate_bitmap_blender');
    al_reset_bitmap_blender := MemoryGetProcAddress(LDLL, 'al_reset_bitmap_blender');
    al_set_clipping_rectangle := MemoryGetProcAddress(LDLL, 'al_set_clipping_rectangle');
    al_reset_clipping_rectangle := MemoryGetProcAddress(LDLL, 'al_reset_clipping_rectangle');
    al_get_clipping_rectangle := MemoryGetProcAddress(LDLL, 'al_get_clipping_rectangle');
    al_create_sub_bitmap := MemoryGetProcAddress(LDLL, 'al_create_sub_bitmap');
    al_is_sub_bitmap := MemoryGetProcAddress(LDLL, 'al_is_sub_bitmap');
    al_get_parent_bitmap := MemoryGetProcAddress(LDLL, 'al_get_parent_bitmap');
    al_get_bitmap_x := MemoryGetProcAddress(LDLL, 'al_get_bitmap_x');
    al_get_bitmap_y := MemoryGetProcAddress(LDLL, 'al_get_bitmap_y');
    al_reparent_bitmap := MemoryGetProcAddress(LDLL, 'al_reparent_bitmap');
    al_clone_bitmap := MemoryGetProcAddress(LDLL, 'al_clone_bitmap');
    al_convert_bitmap := MemoryGetProcAddress(LDLL, 'al_convert_bitmap');
    al_convert_memory_bitmaps := MemoryGetProcAddress(LDLL, 'al_convert_memory_bitmaps');
    al_backup_dirty_bitmap := MemoryGetProcAddress(LDLL, 'al_backup_dirty_bitmap');
    al_draw_bitmap := MemoryGetProcAddress(LDLL, 'al_draw_bitmap');
    al_draw_bitmap_region := MemoryGetProcAddress(LDLL, 'al_draw_bitmap_region');
    al_draw_scaled_bitmap := MemoryGetProcAddress(LDLL, 'al_draw_scaled_bitmap');
    al_draw_rotated_bitmap := MemoryGetProcAddress(LDLL, 'al_draw_rotated_bitmap');
    al_draw_scaled_rotated_bitmap := MemoryGetProcAddress(LDLL, 'al_draw_scaled_rotated_bitmap');
    al_draw_tinted_bitmap := MemoryGetProcAddress(LDLL, 'al_draw_tinted_bitmap');
    al_draw_tinted_bitmap_region := MemoryGetProcAddress(LDLL, 'al_draw_tinted_bitmap_region');
    al_draw_tinted_scaled_bitmap := MemoryGetProcAddress(LDLL, 'al_draw_tinted_scaled_bitmap');
    al_draw_tinted_rotated_bitmap := MemoryGetProcAddress(LDLL, 'al_draw_tinted_rotated_bitmap');
    al_draw_tinted_scaled_rotated_bitmap := MemoryGetProcAddress(LDLL, 'al_draw_tinted_scaled_rotated_bitmap');
    al_draw_tinted_scaled_rotated_bitmap_region := MemoryGetProcAddress(LDLL, 'al_draw_tinted_scaled_rotated_bitmap_region');
    al_ustr_new := MemoryGetProcAddress(LDLL, 'al_ustr_new');
    al_ustr_new_from_buffer := MemoryGetProcAddress(LDLL, 'al_ustr_new_from_buffer');
    al_ustr_newf := MemoryGetProcAddress(LDLL, 'al_ustr_newf');
    al_ustr_free := MemoryGetProcAddress(LDLL, 'al_ustr_free');
    al_cstr := MemoryGetProcAddress(LDLL, 'al_cstr');
    al_ustr_to_buffer := MemoryGetProcAddress(LDLL, 'al_ustr_to_buffer');
    al_cstr_dup := MemoryGetProcAddress(LDLL, 'al_cstr_dup');
    al_ustr_dup := MemoryGetProcAddress(LDLL, 'al_ustr_dup');
    al_ustr_dup_substr := MemoryGetProcAddress(LDLL, 'al_ustr_dup_substr');
    al_ustr_empty_string := MemoryGetProcAddress(LDLL, 'al_ustr_empty_string');
    al_ref_cstr := MemoryGetProcAddress(LDLL, 'al_ref_cstr');
    al_ref_buffer := MemoryGetProcAddress(LDLL, 'al_ref_buffer');
    al_ref_ustr := MemoryGetProcAddress(LDLL, 'al_ref_ustr');
    al_ustr_size := MemoryGetProcAddress(LDLL, 'al_ustr_size');
    al_ustr_length := MemoryGetProcAddress(LDLL, 'al_ustr_length');
    al_ustr_offset := MemoryGetProcAddress(LDLL, 'al_ustr_offset');
    al_ustr_next := MemoryGetProcAddress(LDLL, 'al_ustr_next');
    al_ustr_prev := MemoryGetProcAddress(LDLL, 'al_ustr_prev');
    al_ustr_get := MemoryGetProcAddress(LDLL, 'al_ustr_get');
    al_ustr_get_next := MemoryGetProcAddress(LDLL, 'al_ustr_get_next');
    al_ustr_prev_get := MemoryGetProcAddress(LDLL, 'al_ustr_prev_get');
    al_ustr_insert := MemoryGetProcAddress(LDLL, 'al_ustr_insert');
    al_ustr_insert_cstr := MemoryGetProcAddress(LDLL, 'al_ustr_insert_cstr');
    al_ustr_insert_chr := MemoryGetProcAddress(LDLL, 'al_ustr_insert_chr');
    al_ustr_append := MemoryGetProcAddress(LDLL, 'al_ustr_append');
    al_ustr_append_cstr := MemoryGetProcAddress(LDLL, 'al_ustr_append_cstr');
    al_ustr_append_chr := MemoryGetProcAddress(LDLL, 'al_ustr_append_chr');
    al_ustr_appendf := MemoryGetProcAddress(LDLL, 'al_ustr_appendf');
    al_ustr_vappendf := MemoryGetProcAddress(LDLL, 'al_ustr_vappendf');
    al_ustr_remove_chr := MemoryGetProcAddress(LDLL, 'al_ustr_remove_chr');
    al_ustr_remove_range := MemoryGetProcAddress(LDLL, 'al_ustr_remove_range');
    al_ustr_truncate := MemoryGetProcAddress(LDLL, 'al_ustr_truncate');
    al_ustr_ltrim_ws := MemoryGetProcAddress(LDLL, 'al_ustr_ltrim_ws');
    al_ustr_rtrim_ws := MemoryGetProcAddress(LDLL, 'al_ustr_rtrim_ws');
    al_ustr_trim_ws := MemoryGetProcAddress(LDLL, 'al_ustr_trim_ws');
    al_ustr_assign := MemoryGetProcAddress(LDLL, 'al_ustr_assign');
    al_ustr_assign_substr := MemoryGetProcAddress(LDLL, 'al_ustr_assign_substr');
    al_ustr_assign_cstr := MemoryGetProcAddress(LDLL, 'al_ustr_assign_cstr');
    al_ustr_set_chr := MemoryGetProcAddress(LDLL, 'al_ustr_set_chr');
    al_ustr_replace_range := MemoryGetProcAddress(LDLL, 'al_ustr_replace_range');
    al_ustr_find_chr := MemoryGetProcAddress(LDLL, 'al_ustr_find_chr');
    al_ustr_rfind_chr := MemoryGetProcAddress(LDLL, 'al_ustr_rfind_chr');
    al_ustr_find_set := MemoryGetProcAddress(LDLL, 'al_ustr_find_set');
    al_ustr_find_set_cstr := MemoryGetProcAddress(LDLL, 'al_ustr_find_set_cstr');
    al_ustr_find_cset := MemoryGetProcAddress(LDLL, 'al_ustr_find_cset');
    al_ustr_find_cset_cstr := MemoryGetProcAddress(LDLL, 'al_ustr_find_cset_cstr');
    al_ustr_find_str := MemoryGetProcAddress(LDLL, 'al_ustr_find_str');
    al_ustr_find_cstr := MemoryGetProcAddress(LDLL, 'al_ustr_find_cstr');
    al_ustr_rfind_str := MemoryGetProcAddress(LDLL, 'al_ustr_rfind_str');
    al_ustr_rfind_cstr := MemoryGetProcAddress(LDLL, 'al_ustr_rfind_cstr');
    al_ustr_find_replace := MemoryGetProcAddress(LDLL, 'al_ustr_find_replace');
    al_ustr_find_replace_cstr := MemoryGetProcAddress(LDLL, 'al_ustr_find_replace_cstr');
    al_ustr_equal := MemoryGetProcAddress(LDLL, 'al_ustr_equal');
    al_ustr_compare := MemoryGetProcAddress(LDLL, 'al_ustr_compare');
    al_ustr_ncompare := MemoryGetProcAddress(LDLL, 'al_ustr_ncompare');
    al_ustr_has_prefix := MemoryGetProcAddress(LDLL, 'al_ustr_has_prefix');
    al_ustr_has_prefix_cstr := MemoryGetProcAddress(LDLL, 'al_ustr_has_prefix_cstr');
    al_ustr_has_suffix := MemoryGetProcAddress(LDLL, 'al_ustr_has_suffix');
    al_ustr_has_suffix_cstr := MemoryGetProcAddress(LDLL, 'al_ustr_has_suffix_cstr');
    al_utf8_width := MemoryGetProcAddress(LDLL, 'al_utf8_width');
    al_utf8_encode := MemoryGetProcAddress(LDLL, 'al_utf8_encode');
    al_ustr_new_from_utf16 := MemoryGetProcAddress(LDLL, 'al_ustr_new_from_utf16');
    al_ustr_size_utf16 := MemoryGetProcAddress(LDLL, 'al_ustr_size_utf16');
    al_ustr_encode_utf16 := MemoryGetProcAddress(LDLL, 'al_ustr_encode_utf16');
    al_utf16_width := MemoryGetProcAddress(LDLL, 'al_utf16_width');
    al_utf16_encode := MemoryGetProcAddress(LDLL, 'al_utf16_encode');
    al_create_path := MemoryGetProcAddress(LDLL, 'al_create_path');
    al_create_path_for_directory := MemoryGetProcAddress(LDLL, 'al_create_path_for_directory');
    al_clone_path := MemoryGetProcAddress(LDLL, 'al_clone_path');
    al_get_path_num_components := MemoryGetProcAddress(LDLL, 'al_get_path_num_components');
    al_get_path_component := MemoryGetProcAddress(LDLL, 'al_get_path_component');
    al_replace_path_component := MemoryGetProcAddress(LDLL, 'al_replace_path_component');
    al_remove_path_component := MemoryGetProcAddress(LDLL, 'al_remove_path_component');
    al_insert_path_component := MemoryGetProcAddress(LDLL, 'al_insert_path_component');
    al_get_path_tail := MemoryGetProcAddress(LDLL, 'al_get_path_tail');
    al_drop_path_tail := MemoryGetProcAddress(LDLL, 'al_drop_path_tail');
    al_append_path_component := MemoryGetProcAddress(LDLL, 'al_append_path_component');
    al_join_paths := MemoryGetProcAddress(LDLL, 'al_join_paths');
    al_rebase_path := MemoryGetProcAddress(LDLL, 'al_rebase_path');
    al_path_cstr := MemoryGetProcAddress(LDLL, 'al_path_cstr');
    al_path_ustr := MemoryGetProcAddress(LDLL, 'al_path_ustr');
    al_destroy_path := MemoryGetProcAddress(LDLL, 'al_destroy_path');
    al_set_path_drive := MemoryGetProcAddress(LDLL, 'al_set_path_drive');
    al_get_path_drive := MemoryGetProcAddress(LDLL, 'al_get_path_drive');
    al_set_path_filename := MemoryGetProcAddress(LDLL, 'al_set_path_filename');
    al_get_path_filename := MemoryGetProcAddress(LDLL, 'al_get_path_filename');
    al_get_path_extension := MemoryGetProcAddress(LDLL, 'al_get_path_extension');
    al_set_path_extension := MemoryGetProcAddress(LDLL, 'al_set_path_extension');
    al_get_path_basename := MemoryGetProcAddress(LDLL, 'al_get_path_basename');
    al_make_path_canonical := MemoryGetProcAddress(LDLL, 'al_make_path_canonical');
    al_fopen := MemoryGetProcAddress(LDLL, 'al_fopen');
    al_fopen_interface := MemoryGetProcAddress(LDLL, 'al_fopen_interface');
    al_create_file_handle := MemoryGetProcAddress(LDLL, 'al_create_file_handle');
    al_fclose := MemoryGetProcAddress(LDLL, 'al_fclose');
    al_fread := MemoryGetProcAddress(LDLL, 'al_fread');
    al_fwrite := MemoryGetProcAddress(LDLL, 'al_fwrite');
    al_fflush := MemoryGetProcAddress(LDLL, 'al_fflush');
    al_ftell := MemoryGetProcAddress(LDLL, 'al_ftell');
    al_fseek := MemoryGetProcAddress(LDLL, 'al_fseek');
    al_feof := MemoryGetProcAddress(LDLL, 'al_feof');
    al_ferror := MemoryGetProcAddress(LDLL, 'al_ferror');
    al_ferrmsg := MemoryGetProcAddress(LDLL, 'al_ferrmsg');
    al_fclearerr := MemoryGetProcAddress(LDLL, 'al_fclearerr');
    al_fungetc := MemoryGetProcAddress(LDLL, 'al_fungetc');
    al_fsize := MemoryGetProcAddress(LDLL, 'al_fsize');
    al_fgetc := MemoryGetProcAddress(LDLL, 'al_fgetc');
    al_fputc := MemoryGetProcAddress(LDLL, 'al_fputc');
    al_fread16le := MemoryGetProcAddress(LDLL, 'al_fread16le');
    al_fread16be := MemoryGetProcAddress(LDLL, 'al_fread16be');
    al_fwrite16le := MemoryGetProcAddress(LDLL, 'al_fwrite16le');
    al_fwrite16be := MemoryGetProcAddress(LDLL, 'al_fwrite16be');
    al_fread32le := MemoryGetProcAddress(LDLL, 'al_fread32le');
    al_fread32be := MemoryGetProcAddress(LDLL, 'al_fread32be');
    al_fwrite32le := MemoryGetProcAddress(LDLL, 'al_fwrite32le');
    al_fwrite32be := MemoryGetProcAddress(LDLL, 'al_fwrite32be');
    al_fgets := MemoryGetProcAddress(LDLL, 'al_fgets');
    al_fget_ustr := MemoryGetProcAddress(LDLL, 'al_fget_ustr');
    al_fputs := MemoryGetProcAddress(LDLL, 'al_fputs');
    al_fprintf := MemoryGetProcAddress(LDLL, 'al_fprintf');
    al_vfprintf := MemoryGetProcAddress(LDLL, 'al_vfprintf');
    al_fopen_fd := MemoryGetProcAddress(LDLL, 'al_fopen_fd');
    al_make_temp_file := MemoryGetProcAddress(LDLL, 'al_make_temp_file');
    al_fopen_slice := MemoryGetProcAddress(LDLL, 'al_fopen_slice');
    al_get_new_file_interface := MemoryGetProcAddress(LDLL, 'al_get_new_file_interface');
    al_set_new_file_interface := MemoryGetProcAddress(LDLL, 'al_set_new_file_interface');
    al_set_standard_file_interface := MemoryGetProcAddress(LDLL, 'al_set_standard_file_interface');
    al_get_file_userdata := MemoryGetProcAddress(LDLL, 'al_get_file_userdata');
    al_register_bitmap_loader := MemoryGetProcAddress(LDLL, 'al_register_bitmap_loader');
    al_register_bitmap_saver := MemoryGetProcAddress(LDLL, 'al_register_bitmap_saver');
    al_register_bitmap_loader_f := MemoryGetProcAddress(LDLL, 'al_register_bitmap_loader_f');
    al_register_bitmap_saver_f := MemoryGetProcAddress(LDLL, 'al_register_bitmap_saver_f');
    al_register_bitmap_identifier := MemoryGetProcAddress(LDLL, 'al_register_bitmap_identifier');
    al_load_bitmap := MemoryGetProcAddress(LDLL, 'al_load_bitmap');
    al_load_bitmap_flags := MemoryGetProcAddress(LDLL, 'al_load_bitmap_flags');
    al_load_bitmap_f := MemoryGetProcAddress(LDLL, 'al_load_bitmap_f');
    al_load_bitmap_flags_f := MemoryGetProcAddress(LDLL, 'al_load_bitmap_flags_f');
    al_save_bitmap := MemoryGetProcAddress(LDLL, 'al_save_bitmap');
    al_save_bitmap_f := MemoryGetProcAddress(LDLL, 'al_save_bitmap_f');
    al_identify_bitmap_f := MemoryGetProcAddress(LDLL, 'al_identify_bitmap_f');
    al_identify_bitmap := MemoryGetProcAddress(LDLL, 'al_identify_bitmap');
    al_lock_bitmap := MemoryGetProcAddress(LDLL, 'al_lock_bitmap');
    al_lock_bitmap_region := MemoryGetProcAddress(LDLL, 'al_lock_bitmap_region');
    al_lock_bitmap_blocked := MemoryGetProcAddress(LDLL, 'al_lock_bitmap_blocked');
    al_lock_bitmap_region_blocked := MemoryGetProcAddress(LDLL, 'al_lock_bitmap_region_blocked');
    al_unlock_bitmap := MemoryGetProcAddress(LDLL, 'al_unlock_bitmap');
    al_is_bitmap_locked := MemoryGetProcAddress(LDLL, 'al_is_bitmap_locked');
    al_set_blender := MemoryGetProcAddress(LDLL, 'al_set_blender');
    al_set_blend_color := MemoryGetProcAddress(LDLL, 'al_set_blend_color');
    al_get_blender := MemoryGetProcAddress(LDLL, 'al_get_blender');
    al_get_blend_color := MemoryGetProcAddress(LDLL, 'al_get_blend_color');
    al_set_separate_blender := MemoryGetProcAddress(LDLL, 'al_set_separate_blender');
    al_get_separate_blender := MemoryGetProcAddress(LDLL, 'al_get_separate_blender');
    al_init_user_event_source := MemoryGetProcAddress(LDLL, 'al_init_user_event_source');
    al_destroy_user_event_source := MemoryGetProcAddress(LDLL, 'al_destroy_user_event_source');
    al_emit_user_event := MemoryGetProcAddress(LDLL, 'al_emit_user_event');
    al_unref_user_event := MemoryGetProcAddress(LDLL, 'al_unref_user_event');
    al_set_event_source_data := MemoryGetProcAddress(LDLL, 'al_set_event_source_data');
    al_get_event_source_data := MemoryGetProcAddress(LDLL, 'al_get_event_source_data');
    al_create_event_queue := MemoryGetProcAddress(LDLL, 'al_create_event_queue');
    al_destroy_event_queue := MemoryGetProcAddress(LDLL, 'al_destroy_event_queue');
    al_is_event_source_registered := MemoryGetProcAddress(LDLL, 'al_is_event_source_registered');
    al_register_event_source := MemoryGetProcAddress(LDLL, 'al_register_event_source');
    al_unregister_event_source := MemoryGetProcAddress(LDLL, 'al_unregister_event_source');
    al_pause_event_queue := MemoryGetProcAddress(LDLL, 'al_pause_event_queue');
    al_is_event_queue_paused := MemoryGetProcAddress(LDLL, 'al_is_event_queue_paused');
    al_is_event_queue_empty := MemoryGetProcAddress(LDLL, 'al_is_event_queue_empty');
    al_get_next_event := MemoryGetProcAddress(LDLL, 'al_get_next_event');
    al_peek_next_event := MemoryGetProcAddress(LDLL, 'al_peek_next_event');
    al_drop_next_event := MemoryGetProcAddress(LDLL, 'al_drop_next_event');
    al_flush_event_queue := MemoryGetProcAddress(LDLL, 'al_flush_event_queue');
    al_wait_for_event := MemoryGetProcAddress(LDLL, 'al_wait_for_event');
    al_wait_for_event_timed := MemoryGetProcAddress(LDLL, 'al_wait_for_event_timed');
    al_wait_for_event_until := MemoryGetProcAddress(LDLL, 'al_wait_for_event_until');
    al_set_new_display_refresh_rate := MemoryGetProcAddress(LDLL, 'al_set_new_display_refresh_rate');
    al_set_new_display_flags := MemoryGetProcAddress(LDLL, 'al_set_new_display_flags');
    al_get_new_display_refresh_rate := MemoryGetProcAddress(LDLL, 'al_get_new_display_refresh_rate');
    al_get_new_display_flags := MemoryGetProcAddress(LDLL, 'al_get_new_display_flags');
    al_set_new_window_title := MemoryGetProcAddress(LDLL, 'al_set_new_window_title');
    al_get_new_window_title := MemoryGetProcAddress(LDLL, 'al_get_new_window_title');
    al_get_display_width := MemoryGetProcAddress(LDLL, 'al_get_display_width');
    al_get_display_height := MemoryGetProcAddress(LDLL, 'al_get_display_height');
    al_get_display_format := MemoryGetProcAddress(LDLL, 'al_get_display_format');
    al_get_display_refresh_rate := MemoryGetProcAddress(LDLL, 'al_get_display_refresh_rate');
    al_get_display_flags := MemoryGetProcAddress(LDLL, 'al_get_display_flags');
    al_get_display_orientation := MemoryGetProcAddress(LDLL, 'al_get_display_orientation');
    al_set_display_flag := MemoryGetProcAddress(LDLL, 'al_set_display_flag');
    al_create_display := MemoryGetProcAddress(LDLL, 'al_create_display');
    al_destroy_display := MemoryGetProcAddress(LDLL, 'al_destroy_display');
    al_get_current_display := MemoryGetProcAddress(LDLL, 'al_get_current_display');
    al_set_target_bitmap := MemoryGetProcAddress(LDLL, 'al_set_target_bitmap');
    al_set_target_backbuffer := MemoryGetProcAddress(LDLL, 'al_set_target_backbuffer');
    al_get_backbuffer := MemoryGetProcAddress(LDLL, 'al_get_backbuffer');
    al_get_target_bitmap := MemoryGetProcAddress(LDLL, 'al_get_target_bitmap');
    al_acknowledge_resize := MemoryGetProcAddress(LDLL, 'al_acknowledge_resize');
    al_resize_display := MemoryGetProcAddress(LDLL, 'al_resize_display');
    al_flip_display := MemoryGetProcAddress(LDLL, 'al_flip_display');
    al_update_display_region := MemoryGetProcAddress(LDLL, 'al_update_display_region');
    al_is_compatible_bitmap := MemoryGetProcAddress(LDLL, 'al_is_compatible_bitmap');
    al_wait_for_vsync := MemoryGetProcAddress(LDLL, 'al_wait_for_vsync');
    al_get_display_event_source := MemoryGetProcAddress(LDLL, 'al_get_display_event_source');
    al_set_display_icon := MemoryGetProcAddress(LDLL, 'al_set_display_icon');
    al_set_display_icons := MemoryGetProcAddress(LDLL, 'al_set_display_icons');
    al_get_new_display_adapter := MemoryGetProcAddress(LDLL, 'al_get_new_display_adapter');
    al_set_new_display_adapter := MemoryGetProcAddress(LDLL, 'al_set_new_display_adapter');
    al_set_new_window_position := MemoryGetProcAddress(LDLL, 'al_set_new_window_position');
    al_get_new_window_position := MemoryGetProcAddress(LDLL, 'al_get_new_window_position');
    al_set_window_position := MemoryGetProcAddress(LDLL, 'al_set_window_position');
    al_get_window_position := MemoryGetProcAddress(LDLL, 'al_get_window_position');
    al_set_window_constraints := MemoryGetProcAddress(LDLL, 'al_set_window_constraints');
    al_get_window_constraints := MemoryGetProcAddress(LDLL, 'al_get_window_constraints');
    al_apply_window_constraints := MemoryGetProcAddress(LDLL, 'al_apply_window_constraints');
    al_set_window_title := MemoryGetProcAddress(LDLL, 'al_set_window_title');
    al_set_new_display_option := MemoryGetProcAddress(LDLL, 'al_set_new_display_option');
    al_get_new_display_option := MemoryGetProcAddress(LDLL, 'al_get_new_display_option');
    al_reset_new_display_options := MemoryGetProcAddress(LDLL, 'al_reset_new_display_options');
    al_set_display_option := MemoryGetProcAddress(LDLL, 'al_set_display_option');
    al_get_display_option := MemoryGetProcAddress(LDLL, 'al_get_display_option');
    al_hold_bitmap_drawing := MemoryGetProcAddress(LDLL, 'al_hold_bitmap_drawing');
    al_is_bitmap_drawing_held := MemoryGetProcAddress(LDLL, 'al_is_bitmap_drawing_held');
    al_acknowledge_drawing_halt := MemoryGetProcAddress(LDLL, 'al_acknowledge_drawing_halt');
    al_acknowledge_drawing_resume := MemoryGetProcAddress(LDLL, 'al_acknowledge_drawing_resume');
    al_backup_dirty_bitmaps := MemoryGetProcAddress(LDLL, 'al_backup_dirty_bitmaps');
    al_get_clipboard_text := MemoryGetProcAddress(LDLL, 'al_get_clipboard_text');
    al_set_clipboard_text := MemoryGetProcAddress(LDLL, 'al_set_clipboard_text');
    al_clipboard_has_text := MemoryGetProcAddress(LDLL, 'al_clipboard_has_text');
    al_create_config := MemoryGetProcAddress(LDLL, 'al_create_config');
    al_add_config_section := MemoryGetProcAddress(LDLL, 'al_add_config_section');
    al_set_config_value := MemoryGetProcAddress(LDLL, 'al_set_config_value');
    al_add_config_comment := MemoryGetProcAddress(LDLL, 'al_add_config_comment');
    al_get_config_value := MemoryGetProcAddress(LDLL, 'al_get_config_value');
    al_load_config_file := MemoryGetProcAddress(LDLL, 'al_load_config_file');
    al_load_config_file_f := MemoryGetProcAddress(LDLL, 'al_load_config_file_f');
    al_save_config_file := MemoryGetProcAddress(LDLL, 'al_save_config_file');
    al_save_config_file_f := MemoryGetProcAddress(LDLL, 'al_save_config_file_f');
    al_merge_config_into := MemoryGetProcAddress(LDLL, 'al_merge_config_into');
    al_merge_config := MemoryGetProcAddress(LDLL, 'al_merge_config');
    al_destroy_config := MemoryGetProcAddress(LDLL, 'al_destroy_config');
    al_remove_config_section := MemoryGetProcAddress(LDLL, 'al_remove_config_section');
    al_remove_config_key := MemoryGetProcAddress(LDLL, 'al_remove_config_key');
    al_get_first_config_section := MemoryGetProcAddress(LDLL, 'al_get_first_config_section');
    al_get_next_config_section := MemoryGetProcAddress(LDLL, 'al_get_next_config_section');
    al_get_first_config_entry := MemoryGetProcAddress(LDLL, 'al_get_first_config_entry');
    al_get_next_config_entry := MemoryGetProcAddress(LDLL, 'al_get_next_config_entry');
    al_get_cpu_count := MemoryGetProcAddress(LDLL, 'al_get_cpu_count');
    al_get_ram_size := MemoryGetProcAddress(LDLL, 'al_get_ram_size');
    _al_trace_prefix := MemoryGetProcAddress(LDLL, '_al_trace_prefix');
    _al_trace_suffix := MemoryGetProcAddress(LDLL, '_al_trace_suffix');
    al_register_assert_handler := MemoryGetProcAddress(LDLL, 'al_register_assert_handler');
    al_register_trace_handler := MemoryGetProcAddress(LDLL, 'al_register_trace_handler');
    al_clear_to_color := MemoryGetProcAddress(LDLL, 'al_clear_to_color');
    al_clear_depth_buffer := MemoryGetProcAddress(LDLL, 'al_clear_depth_buffer');
    al_draw_pixel := MemoryGetProcAddress(LDLL, 'al_draw_pixel');
    al_get_errno := MemoryGetProcAddress(LDLL, 'al_get_errno');
    al_set_errno := MemoryGetProcAddress(LDLL, 'al_set_errno');
    al_fixsqrt := MemoryGetProcAddress(LDLL, 'al_fixsqrt');
    al_fixhypot := MemoryGetProcAddress(LDLL, 'al_fixhypot');
    al_fixatan := MemoryGetProcAddress(LDLL, 'al_fixatan');
    al_fixatan2 := MemoryGetProcAddress(LDLL, 'al_fixatan2');
    al_create_fs_entry := MemoryGetProcAddress(LDLL, 'al_create_fs_entry');
    al_destroy_fs_entry := MemoryGetProcAddress(LDLL, 'al_destroy_fs_entry');
    al_get_fs_entry_name := MemoryGetProcAddress(LDLL, 'al_get_fs_entry_name');
    al_update_fs_entry := MemoryGetProcAddress(LDLL, 'al_update_fs_entry');
    al_get_fs_entry_mode := MemoryGetProcAddress(LDLL, 'al_get_fs_entry_mode');
    al_get_fs_entry_atime := MemoryGetProcAddress(LDLL, 'al_get_fs_entry_atime');
    al_get_fs_entry_mtime := MemoryGetProcAddress(LDLL, 'al_get_fs_entry_mtime');
    al_get_fs_entry_ctime := MemoryGetProcAddress(LDLL, 'al_get_fs_entry_ctime');
    al_get_fs_entry_size := MemoryGetProcAddress(LDLL, 'al_get_fs_entry_size');
    al_fs_entry_exists := MemoryGetProcAddress(LDLL, 'al_fs_entry_exists');
    al_remove_fs_entry := MemoryGetProcAddress(LDLL, 'al_remove_fs_entry');
    al_open_directory := MemoryGetProcAddress(LDLL, 'al_open_directory');
    al_read_directory := MemoryGetProcAddress(LDLL, 'al_read_directory');
    al_close_directory := MemoryGetProcAddress(LDLL, 'al_close_directory');
    al_filename_exists := MemoryGetProcAddress(LDLL, 'al_filename_exists');
    al_remove_filename := MemoryGetProcAddress(LDLL, 'al_remove_filename');
    al_get_current_directory := MemoryGetProcAddress(LDLL, 'al_get_current_directory');
    al_change_directory := MemoryGetProcAddress(LDLL, 'al_change_directory');
    al_make_directory := MemoryGetProcAddress(LDLL, 'al_make_directory');
    al_open_fs_entry := MemoryGetProcAddress(LDLL, 'al_open_fs_entry');
    al_for_each_fs_entry := MemoryGetProcAddress(LDLL, 'al_for_each_fs_entry');
    al_get_fs_interface := MemoryGetProcAddress(LDLL, 'al_get_fs_interface');
    al_set_fs_interface := MemoryGetProcAddress(LDLL, 'al_set_fs_interface');
    al_set_standard_fs_interface := MemoryGetProcAddress(LDLL, 'al_set_standard_fs_interface');
    al_get_num_display_modes := MemoryGetProcAddress(LDLL, 'al_get_num_display_modes');
    al_get_display_mode := MemoryGetProcAddress(LDLL, 'al_get_display_mode');
    al_install_joystick := MemoryGetProcAddress(LDLL, 'al_install_joystick');
    al_uninstall_joystick := MemoryGetProcAddress(LDLL, 'al_uninstall_joystick');
    al_is_joystick_installed := MemoryGetProcAddress(LDLL, 'al_is_joystick_installed');
    al_reconfigure_joysticks := MemoryGetProcAddress(LDLL, 'al_reconfigure_joysticks');
    al_get_num_joysticks := MemoryGetProcAddress(LDLL, 'al_get_num_joysticks');
    al_get_joystick := MemoryGetProcAddress(LDLL, 'al_get_joystick');
    al_release_joystick := MemoryGetProcAddress(LDLL, 'al_release_joystick');
    al_get_joystick_active := MemoryGetProcAddress(LDLL, 'al_get_joystick_active');
    al_get_joystick_name := MemoryGetProcAddress(LDLL, 'al_get_joystick_name');
    al_get_joystick_num_sticks := MemoryGetProcAddress(LDLL, 'al_get_joystick_num_sticks');
    al_get_joystick_stick_flags := MemoryGetProcAddress(LDLL, 'al_get_joystick_stick_flags');
    al_get_joystick_stick_name := MemoryGetProcAddress(LDLL, 'al_get_joystick_stick_name');
    al_get_joystick_num_axes := MemoryGetProcAddress(LDLL, 'al_get_joystick_num_axes');
    al_get_joystick_axis_name := MemoryGetProcAddress(LDLL, 'al_get_joystick_axis_name');
    al_get_joystick_num_buttons := MemoryGetProcAddress(LDLL, 'al_get_joystick_num_buttons');
    al_get_joystick_button_name := MemoryGetProcAddress(LDLL, 'al_get_joystick_button_name');
    al_get_joystick_state := MemoryGetProcAddress(LDLL, 'al_get_joystick_state');
    al_get_joystick_event_source := MemoryGetProcAddress(LDLL, 'al_get_joystick_event_source');
    al_is_keyboard_installed := MemoryGetProcAddress(LDLL, 'al_is_keyboard_installed');
    al_install_keyboard := MemoryGetProcAddress(LDLL, 'al_install_keyboard');
    al_uninstall_keyboard := MemoryGetProcAddress(LDLL, 'al_uninstall_keyboard');
    al_set_keyboard_leds := MemoryGetProcAddress(LDLL, 'al_set_keyboard_leds');
    al_keycode_to_name := MemoryGetProcAddress(LDLL, 'al_keycode_to_name');
    al_get_keyboard_state := MemoryGetProcAddress(LDLL, 'al_get_keyboard_state');
    al_clear_keyboard_state := MemoryGetProcAddress(LDLL, 'al_clear_keyboard_state');
    al_key_down := MemoryGetProcAddress(LDLL, 'al_key_down');
    al_get_keyboard_event_source := MemoryGetProcAddress(LDLL, 'al_get_keyboard_event_source');
    al_is_mouse_installed := MemoryGetProcAddress(LDLL, 'al_is_mouse_installed');
    al_install_mouse := MemoryGetProcAddress(LDLL, 'al_install_mouse');
    al_uninstall_mouse := MemoryGetProcAddress(LDLL, 'al_uninstall_mouse');
    al_get_mouse_num_buttons := MemoryGetProcAddress(LDLL, 'al_get_mouse_num_buttons');
    al_get_mouse_num_axes := MemoryGetProcAddress(LDLL, 'al_get_mouse_num_axes');
    al_set_mouse_xy := MemoryGetProcAddress(LDLL, 'al_set_mouse_xy');
    al_set_mouse_z := MemoryGetProcAddress(LDLL, 'al_set_mouse_z');
    al_set_mouse_w := MemoryGetProcAddress(LDLL, 'al_set_mouse_w');
    al_set_mouse_axis := MemoryGetProcAddress(LDLL, 'al_set_mouse_axis');
    al_get_mouse_state := MemoryGetProcAddress(LDLL, 'al_get_mouse_state');
    al_mouse_button_down := MemoryGetProcAddress(LDLL, 'al_mouse_button_down');
    al_get_mouse_state_axis := MemoryGetProcAddress(LDLL, 'al_get_mouse_state_axis');
    al_get_mouse_cursor_position := MemoryGetProcAddress(LDLL, 'al_get_mouse_cursor_position');
    al_grab_mouse := MemoryGetProcAddress(LDLL, 'al_grab_mouse');
    al_ungrab_mouse := MemoryGetProcAddress(LDLL, 'al_ungrab_mouse');
    al_set_mouse_wheel_precision := MemoryGetProcAddress(LDLL, 'al_set_mouse_wheel_precision');
    al_get_mouse_wheel_precision := MemoryGetProcAddress(LDLL, 'al_get_mouse_wheel_precision');
    al_get_mouse_event_source := MemoryGetProcAddress(LDLL, 'al_get_mouse_event_source');
    al_is_touch_input_installed := MemoryGetProcAddress(LDLL, 'al_is_touch_input_installed');
    al_install_touch_input := MemoryGetProcAddress(LDLL, 'al_install_touch_input');
    al_uninstall_touch_input := MemoryGetProcAddress(LDLL, 'al_uninstall_touch_input');
    al_get_touch_input_state := MemoryGetProcAddress(LDLL, 'al_get_touch_input_state');
    al_get_touch_input_event_source := MemoryGetProcAddress(LDLL, 'al_get_touch_input_event_source');
    al_set_mouse_emulation_mode := MemoryGetProcAddress(LDLL, 'al_set_mouse_emulation_mode');
    al_get_mouse_emulation_mode := MemoryGetProcAddress(LDLL, 'al_get_mouse_emulation_mode');
    al_get_touch_input_mouse_emulation_event_source := MemoryGetProcAddress(LDLL, 'al_get_touch_input_mouse_emulation_event_source');
    al_install_haptic := MemoryGetProcAddress(LDLL, 'al_install_haptic');
    al_uninstall_haptic := MemoryGetProcAddress(LDLL, 'al_uninstall_haptic');
    al_is_haptic_installed := MemoryGetProcAddress(LDLL, 'al_is_haptic_installed');
    al_is_mouse_haptic := MemoryGetProcAddress(LDLL, 'al_is_mouse_haptic');
    al_is_joystick_haptic := MemoryGetProcAddress(LDLL, 'al_is_joystick_haptic');
    al_is_keyboard_haptic := MemoryGetProcAddress(LDLL, 'al_is_keyboard_haptic');
    al_is_display_haptic := MemoryGetProcAddress(LDLL, 'al_is_display_haptic');
    al_is_touch_input_haptic := MemoryGetProcAddress(LDLL, 'al_is_touch_input_haptic');
    al_get_haptic_from_mouse := MemoryGetProcAddress(LDLL, 'al_get_haptic_from_mouse');
    al_get_haptic_from_joystick := MemoryGetProcAddress(LDLL, 'al_get_haptic_from_joystick');
    al_get_haptic_from_keyboard := MemoryGetProcAddress(LDLL, 'al_get_haptic_from_keyboard');
    al_get_haptic_from_display := MemoryGetProcAddress(LDLL, 'al_get_haptic_from_display');
    al_get_haptic_from_touch_input := MemoryGetProcAddress(LDLL, 'al_get_haptic_from_touch_input');
    al_release_haptic := MemoryGetProcAddress(LDLL, 'al_release_haptic');
    al_is_haptic_active := MemoryGetProcAddress(LDLL, 'al_is_haptic_active');
    al_get_haptic_capabilities := MemoryGetProcAddress(LDLL, 'al_get_haptic_capabilities');
    al_is_haptic_capable := MemoryGetProcAddress(LDLL, 'al_is_haptic_capable');
    al_set_haptic_gain := MemoryGetProcAddress(LDLL, 'al_set_haptic_gain');
    al_get_haptic_gain := MemoryGetProcAddress(LDLL, 'al_get_haptic_gain');
    al_set_haptic_autocenter := MemoryGetProcAddress(LDLL, 'al_set_haptic_autocenter');
    al_get_haptic_autocenter := MemoryGetProcAddress(LDLL, 'al_get_haptic_autocenter');
    al_get_max_haptic_effects := MemoryGetProcAddress(LDLL, 'al_get_max_haptic_effects');
    al_is_haptic_effect_ok := MemoryGetProcAddress(LDLL, 'al_is_haptic_effect_ok');
    al_upload_haptic_effect := MemoryGetProcAddress(LDLL, 'al_upload_haptic_effect');
    al_play_haptic_effect := MemoryGetProcAddress(LDLL, 'al_play_haptic_effect');
    al_upload_and_play_haptic_effect := MemoryGetProcAddress(LDLL, 'al_upload_and_play_haptic_effect');
    al_stop_haptic_effect := MemoryGetProcAddress(LDLL, 'al_stop_haptic_effect');
    al_is_haptic_effect_playing := MemoryGetProcAddress(LDLL, 'al_is_haptic_effect_playing');
    al_release_haptic_effect := MemoryGetProcAddress(LDLL, 'al_release_haptic_effect');
    al_get_haptic_effect_duration := MemoryGetProcAddress(LDLL, 'al_get_haptic_effect_duration');
    al_rumble_haptic := MemoryGetProcAddress(LDLL, 'al_rumble_haptic');
    al_set_memory_interface := MemoryGetProcAddress(LDLL, 'al_set_memory_interface');
    al_malloc_with_context := MemoryGetProcAddress(LDLL, 'al_malloc_with_context');
    al_free_with_context := MemoryGetProcAddress(LDLL, 'al_free_with_context');
    al_realloc_with_context := MemoryGetProcAddress(LDLL, 'al_realloc_with_context');
    al_calloc_with_context := MemoryGetProcAddress(LDLL, 'al_calloc_with_context');
    al_get_num_video_adapters := MemoryGetProcAddress(LDLL, 'al_get_num_video_adapters');
    al_get_monitor_info := MemoryGetProcAddress(LDLL, 'al_get_monitor_info');
    al_get_monitor_dpi := MemoryGetProcAddress(LDLL, 'al_get_monitor_dpi');
    al_get_monitor_refresh_rate := MemoryGetProcAddress(LDLL, 'al_get_monitor_refresh_rate');
    al_create_mouse_cursor := MemoryGetProcAddress(LDLL, 'al_create_mouse_cursor');
    al_destroy_mouse_cursor := MemoryGetProcAddress(LDLL, 'al_destroy_mouse_cursor');
    al_set_mouse_cursor := MemoryGetProcAddress(LDLL, 'al_set_mouse_cursor');
    al_set_system_mouse_cursor := MemoryGetProcAddress(LDLL, 'al_set_system_mouse_cursor');
    al_show_mouse_cursor := MemoryGetProcAddress(LDLL, 'al_show_mouse_cursor');
    al_hide_mouse_cursor := MemoryGetProcAddress(LDLL, 'al_hide_mouse_cursor');
    al_set_render_state := MemoryGetProcAddress(LDLL, 'al_set_render_state');
    al_use_transform := MemoryGetProcAddress(LDLL, 'al_use_transform');
    al_use_projection_transform := MemoryGetProcAddress(LDLL, 'al_use_projection_transform');
    al_copy_transform := MemoryGetProcAddress(LDLL, 'al_copy_transform');
    al_identity_transform := MemoryGetProcAddress(LDLL, 'al_identity_transform');
    al_build_transform := MemoryGetProcAddress(LDLL, 'al_build_transform');
    al_build_camera_transform := MemoryGetProcAddress(LDLL, 'al_build_camera_transform');
    al_translate_transform := MemoryGetProcAddress(LDLL, 'al_translate_transform');
    al_translate_transform_3d := MemoryGetProcAddress(LDLL, 'al_translate_transform_3d');
    al_rotate_transform := MemoryGetProcAddress(LDLL, 'al_rotate_transform');
    al_rotate_transform_3d := MemoryGetProcAddress(LDLL, 'al_rotate_transform_3d');
    al_scale_transform := MemoryGetProcAddress(LDLL, 'al_scale_transform');
    al_scale_transform_3d := MemoryGetProcAddress(LDLL, 'al_scale_transform_3d');
    al_transform_coordinates := MemoryGetProcAddress(LDLL, 'al_transform_coordinates');
    al_transform_coordinates_3d := MemoryGetProcAddress(LDLL, 'al_transform_coordinates_3d');
    al_transform_coordinates_4d := MemoryGetProcAddress(LDLL, 'al_transform_coordinates_4d');
    al_transform_coordinates_3d_projective := MemoryGetProcAddress(LDLL, 'al_transform_coordinates_3d_projective');
    al_compose_transform := MemoryGetProcAddress(LDLL, 'al_compose_transform');
    al_get_current_transform := MemoryGetProcAddress(LDLL, 'al_get_current_transform');
    al_get_current_inverse_transform := MemoryGetProcAddress(LDLL, 'al_get_current_inverse_transform');
    al_get_current_projection_transform := MemoryGetProcAddress(LDLL, 'al_get_current_projection_transform');
    al_invert_transform := MemoryGetProcAddress(LDLL, 'al_invert_transform');
    al_transpose_transform := MemoryGetProcAddress(LDLL, 'al_transpose_transform');
    al_check_inverse := MemoryGetProcAddress(LDLL, 'al_check_inverse');
    al_orthographic_transform := MemoryGetProcAddress(LDLL, 'al_orthographic_transform');
    al_perspective_transform := MemoryGetProcAddress(LDLL, 'al_perspective_transform');
    al_horizontal_shear_transform := MemoryGetProcAddress(LDLL, 'al_horizontal_shear_transform');
    al_vertical_shear_transform := MemoryGetProcAddress(LDLL, 'al_vertical_shear_transform');
    al_create_shader := MemoryGetProcAddress(LDLL, 'al_create_shader');
    al_attach_shader_source := MemoryGetProcAddress(LDLL, 'al_attach_shader_source');
    al_attach_shader_source_file := MemoryGetProcAddress(LDLL, 'al_attach_shader_source_file');
    al_build_shader := MemoryGetProcAddress(LDLL, 'al_build_shader');
    al_get_shader_log := MemoryGetProcAddress(LDLL, 'al_get_shader_log');
    al_get_shader_platform := MemoryGetProcAddress(LDLL, 'al_get_shader_platform');
    al_use_shader := MemoryGetProcAddress(LDLL, 'al_use_shader');
    al_destroy_shader := MemoryGetProcAddress(LDLL, 'al_destroy_shader');
    al_set_shader_sampler := MemoryGetProcAddress(LDLL, 'al_set_shader_sampler');
    al_set_shader_matrix := MemoryGetProcAddress(LDLL, 'al_set_shader_matrix');
    al_set_shader_int := MemoryGetProcAddress(LDLL, 'al_set_shader_int');
    al_set_shader_float := MemoryGetProcAddress(LDLL, 'al_set_shader_float');
    al_set_shader_int_vector := MemoryGetProcAddress(LDLL, 'al_set_shader_int_vector');
    al_set_shader_float_vector := MemoryGetProcAddress(LDLL, 'al_set_shader_float_vector');
    al_set_shader_bool := MemoryGetProcAddress(LDLL, 'al_set_shader_bool');
    al_get_default_shader_source := MemoryGetProcAddress(LDLL, 'al_get_default_shader_source');
    al_install_system := MemoryGetProcAddress(LDLL, 'al_install_system');
    al_uninstall_system := MemoryGetProcAddress(LDLL, 'al_uninstall_system');
    al_is_system_installed := MemoryGetProcAddress(LDLL, 'al_is_system_installed');
    al_get_system_driver := MemoryGetProcAddress(LDLL, 'al_get_system_driver');
    al_get_system_config := MemoryGetProcAddress(LDLL, 'al_get_system_config');
    al_get_system_id := MemoryGetProcAddress(LDLL, 'al_get_system_id');
    al_get_standard_path := MemoryGetProcAddress(LDLL, 'al_get_standard_path');
    al_set_exe_name := MemoryGetProcAddress(LDLL, 'al_set_exe_name');
    al_set_org_name := MemoryGetProcAddress(LDLL, 'al_set_org_name');
    al_set_app_name := MemoryGetProcAddress(LDLL, 'al_set_app_name');
    al_get_org_name := MemoryGetProcAddress(LDLL, 'al_get_org_name');
    al_get_app_name := MemoryGetProcAddress(LDLL, 'al_get_app_name');
    al_inhibit_screensaver := MemoryGetProcAddress(LDLL, 'al_inhibit_screensaver');
    al_create_thread := MemoryGetProcAddress(LDLL, 'al_create_thread');
    al_create_thread_with_stacksize := MemoryGetProcAddress(LDLL, 'al_create_thread_with_stacksize');
    al_start_thread := MemoryGetProcAddress(LDLL, 'al_start_thread');
    al_join_thread := MemoryGetProcAddress(LDLL, 'al_join_thread');
    al_set_thread_should_stop := MemoryGetProcAddress(LDLL, 'al_set_thread_should_stop');
    al_get_thread_should_stop := MemoryGetProcAddress(LDLL, 'al_get_thread_should_stop');
    al_destroy_thread := MemoryGetProcAddress(LDLL, 'al_destroy_thread');
    al_run_detached_thread := MemoryGetProcAddress(LDLL, 'al_run_detached_thread');
    al_create_mutex := MemoryGetProcAddress(LDLL, 'al_create_mutex');
    al_create_mutex_recursive := MemoryGetProcAddress(LDLL, 'al_create_mutex_recursive');
    al_lock_mutex := MemoryGetProcAddress(LDLL, 'al_lock_mutex');
    al_unlock_mutex := MemoryGetProcAddress(LDLL, 'al_unlock_mutex');
    al_destroy_mutex := MemoryGetProcAddress(LDLL, 'al_destroy_mutex');
    al_create_cond := MemoryGetProcAddress(LDLL, 'al_create_cond');
    al_destroy_cond := MemoryGetProcAddress(LDLL, 'al_destroy_cond');
    al_wait_cond := MemoryGetProcAddress(LDLL, 'al_wait_cond');
    al_wait_cond_until := MemoryGetProcAddress(LDLL, 'al_wait_cond_until');
    al_broadcast_cond := MemoryGetProcAddress(LDLL, 'al_broadcast_cond');
    al_signal_cond := MemoryGetProcAddress(LDLL, 'al_signal_cond');
    al_create_timer := MemoryGetProcAddress(LDLL, 'al_create_timer');
    al_destroy_timer := MemoryGetProcAddress(LDLL, 'al_destroy_timer');
    al_start_timer := MemoryGetProcAddress(LDLL, 'al_start_timer');
    al_stop_timer := MemoryGetProcAddress(LDLL, 'al_stop_timer');
    al_resume_timer := MemoryGetProcAddress(LDLL, 'al_resume_timer');
    al_get_timer_started := MemoryGetProcAddress(LDLL, 'al_get_timer_started');
    al_get_timer_speed := MemoryGetProcAddress(LDLL, 'al_get_timer_speed');
    al_set_timer_speed := MemoryGetProcAddress(LDLL, 'al_set_timer_speed');
    al_get_timer_count := MemoryGetProcAddress(LDLL, 'al_get_timer_count');
    al_set_timer_count := MemoryGetProcAddress(LDLL, 'al_set_timer_count');
    al_add_timer_count := MemoryGetProcAddress(LDLL, 'al_add_timer_count');
    al_get_timer_event_source := MemoryGetProcAddress(LDLL, 'al_get_timer_event_source');
    al_store_state := MemoryGetProcAddress(LDLL, 'al_store_state');
    al_restore_state := MemoryGetProcAddress(LDLL, 'al_restore_state');
    al_create_sample := MemoryGetProcAddress(LDLL, 'al_create_sample');
    al_destroy_sample := MemoryGetProcAddress(LDLL, 'al_destroy_sample');
    al_create_sample_instance := MemoryGetProcAddress(LDLL, 'al_create_sample_instance');
    al_destroy_sample_instance := MemoryGetProcAddress(LDLL, 'al_destroy_sample_instance');
    al_get_sample_frequency := MemoryGetProcAddress(LDLL, 'al_get_sample_frequency');
    al_get_sample_length := MemoryGetProcAddress(LDLL, 'al_get_sample_length');
    al_get_sample_depth := MemoryGetProcAddress(LDLL, 'al_get_sample_depth');
    al_get_sample_channels := MemoryGetProcAddress(LDLL, 'al_get_sample_channels');
    al_get_sample_data := MemoryGetProcAddress(LDLL, 'al_get_sample_data');
    al_get_sample_instance_frequency := MemoryGetProcAddress(LDLL, 'al_get_sample_instance_frequency');
    al_get_sample_instance_length := MemoryGetProcAddress(LDLL, 'al_get_sample_instance_length');
    al_get_sample_instance_position := MemoryGetProcAddress(LDLL, 'al_get_sample_instance_position');
    al_get_sample_instance_speed := MemoryGetProcAddress(LDLL, 'al_get_sample_instance_speed');
    al_get_sample_instance_gain := MemoryGetProcAddress(LDLL, 'al_get_sample_instance_gain');
    al_get_sample_instance_pan := MemoryGetProcAddress(LDLL, 'al_get_sample_instance_pan');
    al_get_sample_instance_time := MemoryGetProcAddress(LDLL, 'al_get_sample_instance_time');
    al_get_sample_instance_depth := MemoryGetProcAddress(LDLL, 'al_get_sample_instance_depth');
    al_get_sample_instance_channels := MemoryGetProcAddress(LDLL, 'al_get_sample_instance_channels');
    al_get_sample_instance_playmode := MemoryGetProcAddress(LDLL, 'al_get_sample_instance_playmode');
    al_get_sample_instance_playing := MemoryGetProcAddress(LDLL, 'al_get_sample_instance_playing');
    al_get_sample_instance_attached := MemoryGetProcAddress(LDLL, 'al_get_sample_instance_attached');
    al_set_sample_instance_position := MemoryGetProcAddress(LDLL, 'al_set_sample_instance_position');
    al_set_sample_instance_length := MemoryGetProcAddress(LDLL, 'al_set_sample_instance_length');
    al_set_sample_instance_speed := MemoryGetProcAddress(LDLL, 'al_set_sample_instance_speed');
    al_set_sample_instance_gain := MemoryGetProcAddress(LDLL, 'al_set_sample_instance_gain');
    al_set_sample_instance_pan := MemoryGetProcAddress(LDLL, 'al_set_sample_instance_pan');
    al_set_sample_instance_playmode := MemoryGetProcAddress(LDLL, 'al_set_sample_instance_playmode');
    al_set_sample_instance_playing := MemoryGetProcAddress(LDLL, 'al_set_sample_instance_playing');
    al_detach_sample_instance := MemoryGetProcAddress(LDLL, 'al_detach_sample_instance');
    al_set_sample := MemoryGetProcAddress(LDLL, 'al_set_sample');
    al_get_sample := MemoryGetProcAddress(LDLL, 'al_get_sample');
    al_play_sample_instance := MemoryGetProcAddress(LDLL, 'al_play_sample_instance');
    al_stop_sample_instance := MemoryGetProcAddress(LDLL, 'al_stop_sample_instance');
    al_set_sample_instance_channel_matrix := MemoryGetProcAddress(LDLL, 'al_set_sample_instance_channel_matrix');
    al_create_audio_stream := MemoryGetProcAddress(LDLL, 'al_create_audio_stream');
    al_destroy_audio_stream := MemoryGetProcAddress(LDLL, 'al_destroy_audio_stream');
    al_drain_audio_stream := MemoryGetProcAddress(LDLL, 'al_drain_audio_stream');
    al_get_audio_stream_frequency := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_frequency');
    al_get_audio_stream_length := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_length');
    al_get_audio_stream_fragments := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_fragments');
    al_get_available_audio_stream_fragments := MemoryGetProcAddress(LDLL, 'al_get_available_audio_stream_fragments');
    al_get_audio_stream_speed := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_speed');
    al_get_audio_stream_gain := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_gain');
    al_get_audio_stream_pan := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_pan');
    al_get_audio_stream_channels := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_channels');
    al_get_audio_stream_depth := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_depth');
    al_get_audio_stream_playmode := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_playmode');
    al_get_audio_stream_playing := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_playing');
    al_get_audio_stream_attached := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_attached');
    al_get_audio_stream_played_samples := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_played_samples');
    al_get_audio_stream_fragment := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_fragment');
    al_set_audio_stream_speed := MemoryGetProcAddress(LDLL, 'al_set_audio_stream_speed');
    al_set_audio_stream_gain := MemoryGetProcAddress(LDLL, 'al_set_audio_stream_gain');
    al_set_audio_stream_pan := MemoryGetProcAddress(LDLL, 'al_set_audio_stream_pan');
    al_set_audio_stream_playmode := MemoryGetProcAddress(LDLL, 'al_set_audio_stream_playmode');
    al_set_audio_stream_playing := MemoryGetProcAddress(LDLL, 'al_set_audio_stream_playing');
    al_detach_audio_stream := MemoryGetProcAddress(LDLL, 'al_detach_audio_stream');
    al_set_audio_stream_fragment := MemoryGetProcAddress(LDLL, 'al_set_audio_stream_fragment');
    al_rewind_audio_stream := MemoryGetProcAddress(LDLL, 'al_rewind_audio_stream');
    al_seek_audio_stream_secs := MemoryGetProcAddress(LDLL, 'al_seek_audio_stream_secs');
    al_get_audio_stream_position_secs := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_position_secs');
    al_get_audio_stream_length_secs := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_length_secs');
    al_set_audio_stream_loop_secs := MemoryGetProcAddress(LDLL, 'al_set_audio_stream_loop_secs');
    al_get_audio_stream_event_source := MemoryGetProcAddress(LDLL, 'al_get_audio_stream_event_source');
    al_set_audio_stream_channel_matrix := MemoryGetProcAddress(LDLL, 'al_set_audio_stream_channel_matrix');
    al_create_mixer := MemoryGetProcAddress(LDLL, 'al_create_mixer');
    al_destroy_mixer := MemoryGetProcAddress(LDLL, 'al_destroy_mixer');
    al_attach_sample_instance_to_mixer := MemoryGetProcAddress(LDLL, 'al_attach_sample_instance_to_mixer');
    al_attach_audio_stream_to_mixer := MemoryGetProcAddress(LDLL, 'al_attach_audio_stream_to_mixer');
    al_attach_mixer_to_mixer := MemoryGetProcAddress(LDLL, 'al_attach_mixer_to_mixer');
    al_set_mixer_postprocess_callback := MemoryGetProcAddress(LDLL, 'al_set_mixer_postprocess_callback');
    al_get_mixer_frequency := MemoryGetProcAddress(LDLL, 'al_get_mixer_frequency');
    al_get_mixer_channels := MemoryGetProcAddress(LDLL, 'al_get_mixer_channels');
    al_get_mixer_depth := MemoryGetProcAddress(LDLL, 'al_get_mixer_depth');
    al_get_mixer_quality := MemoryGetProcAddress(LDLL, 'al_get_mixer_quality');
    al_get_mixer_gain := MemoryGetProcAddress(LDLL, 'al_get_mixer_gain');
    al_get_mixer_playing := MemoryGetProcAddress(LDLL, 'al_get_mixer_playing');
    al_get_mixer_attached := MemoryGetProcAddress(LDLL, 'al_get_mixer_attached');
    al_set_mixer_frequency := MemoryGetProcAddress(LDLL, 'al_set_mixer_frequency');
    al_set_mixer_quality := MemoryGetProcAddress(LDLL, 'al_set_mixer_quality');
    al_set_mixer_gain := MemoryGetProcAddress(LDLL, 'al_set_mixer_gain');
    al_set_mixer_playing := MemoryGetProcAddress(LDLL, 'al_set_mixer_playing');
    al_detach_mixer := MemoryGetProcAddress(LDLL, 'al_detach_mixer');
    al_create_voice := MemoryGetProcAddress(LDLL, 'al_create_voice');
    al_destroy_voice := MemoryGetProcAddress(LDLL, 'al_destroy_voice');
    al_attach_sample_instance_to_voice := MemoryGetProcAddress(LDLL, 'al_attach_sample_instance_to_voice');
    al_attach_audio_stream_to_voice := MemoryGetProcAddress(LDLL, 'al_attach_audio_stream_to_voice');
    al_attach_mixer_to_voice := MemoryGetProcAddress(LDLL, 'al_attach_mixer_to_voice');
    al_detach_voice := MemoryGetProcAddress(LDLL, 'al_detach_voice');
    al_get_voice_frequency := MemoryGetProcAddress(LDLL, 'al_get_voice_frequency');
    al_get_voice_position := MemoryGetProcAddress(LDLL, 'al_get_voice_position');
    al_get_voice_channels := MemoryGetProcAddress(LDLL, 'al_get_voice_channels');
    al_get_voice_depth := MemoryGetProcAddress(LDLL, 'al_get_voice_depth');
    al_get_voice_playing := MemoryGetProcAddress(LDLL, 'al_get_voice_playing');
    al_set_voice_position := MemoryGetProcAddress(LDLL, 'al_set_voice_position');
    al_set_voice_playing := MemoryGetProcAddress(LDLL, 'al_set_voice_playing');
    al_install_audio := MemoryGetProcAddress(LDLL, 'al_install_audio');
    al_uninstall_audio := MemoryGetProcAddress(LDLL, 'al_uninstall_audio');
    al_is_audio_installed := MemoryGetProcAddress(LDLL, 'al_is_audio_installed');
    al_get_allegro_audio_version := MemoryGetProcAddress(LDLL, 'al_get_allegro_audio_version');
    al_get_channel_count := MemoryGetProcAddress(LDLL, 'al_get_channel_count');
    al_get_audio_depth_size := MemoryGetProcAddress(LDLL, 'al_get_audio_depth_size');
    al_fill_silence := MemoryGetProcAddress(LDLL, 'al_fill_silence');
    al_get_num_audio_output_devices := MemoryGetProcAddress(LDLL, 'al_get_num_audio_output_devices');
    al_get_audio_output_device := MemoryGetProcAddress(LDLL, 'al_get_audio_output_device');
    al_get_audio_device_name := MemoryGetProcAddress(LDLL, 'al_get_audio_device_name');
    al_reserve_samples := MemoryGetProcAddress(LDLL, 'al_reserve_samples');
    al_get_default_mixer := MemoryGetProcAddress(LDLL, 'al_get_default_mixer');
    al_set_default_mixer := MemoryGetProcAddress(LDLL, 'al_set_default_mixer');
    al_restore_default_mixer := MemoryGetProcAddress(LDLL, 'al_restore_default_mixer');
    al_play_sample := MemoryGetProcAddress(LDLL, 'al_play_sample');
    al_stop_sample := MemoryGetProcAddress(LDLL, 'al_stop_sample');
    al_stop_samples := MemoryGetProcAddress(LDLL, 'al_stop_samples');
    al_get_default_voice := MemoryGetProcAddress(LDLL, 'al_get_default_voice');
    al_set_default_voice := MemoryGetProcAddress(LDLL, 'al_set_default_voice');
    al_lock_sample_id := MemoryGetProcAddress(LDLL, 'al_lock_sample_id');
    al_unlock_sample_id := MemoryGetProcAddress(LDLL, 'al_unlock_sample_id');
    al_register_sample_loader := MemoryGetProcAddress(LDLL, 'al_register_sample_loader');
    al_register_sample_saver := MemoryGetProcAddress(LDLL, 'al_register_sample_saver');
    al_register_audio_stream_loader := MemoryGetProcAddress(LDLL, 'al_register_audio_stream_loader');
    al_register_sample_loader_f := MemoryGetProcAddress(LDLL, 'al_register_sample_loader_f');
    al_register_sample_saver_f := MemoryGetProcAddress(LDLL, 'al_register_sample_saver_f');
    al_register_audio_stream_loader_f := MemoryGetProcAddress(LDLL, 'al_register_audio_stream_loader_f');
    al_register_sample_identifier := MemoryGetProcAddress(LDLL, 'al_register_sample_identifier');
    al_load_sample := MemoryGetProcAddress(LDLL, 'al_load_sample');
    al_save_sample := MemoryGetProcAddress(LDLL, 'al_save_sample');
    al_load_audio_stream := MemoryGetProcAddress(LDLL, 'al_load_audio_stream');
    al_load_sample_f := MemoryGetProcAddress(LDLL, 'al_load_sample_f');
    al_save_sample_f := MemoryGetProcAddress(LDLL, 'al_save_sample_f');
    al_load_audio_stream_f := MemoryGetProcAddress(LDLL, 'al_load_audio_stream_f');
    al_identify_sample_f := MemoryGetProcAddress(LDLL, 'al_identify_sample_f');
    al_identify_sample := MemoryGetProcAddress(LDLL, 'al_identify_sample');
    al_create_audio_recorder := MemoryGetProcAddress(LDLL, 'al_create_audio_recorder');
    al_start_audio_recorder := MemoryGetProcAddress(LDLL, 'al_start_audio_recorder');
    al_stop_audio_recorder := MemoryGetProcAddress(LDLL, 'al_stop_audio_recorder');
    al_is_audio_recorder_recording := MemoryGetProcAddress(LDLL, 'al_is_audio_recorder_recording');
    al_get_audio_recorder_event_source := MemoryGetProcAddress(LDLL, 'al_get_audio_recorder_event_source');
    al_get_audio_recorder_event := MemoryGetProcAddress(LDLL, 'al_get_audio_recorder_event');
    al_destroy_audio_recorder := MemoryGetProcAddress(LDLL, 'al_destroy_audio_recorder');
    al_init_acodec_addon := MemoryGetProcAddress(LDLL, 'al_init_acodec_addon');
    al_is_acodec_addon_initialized := MemoryGetProcAddress(LDLL, 'al_is_acodec_addon_initialized');
    al_get_allegro_acodec_version := MemoryGetProcAddress(LDLL, 'al_get_allegro_acodec_version');
    al_get_allegro_color_version := MemoryGetProcAddress(LDLL, 'al_get_allegro_color_version');
    al_color_hsv_to_rgb := MemoryGetProcAddress(LDLL, 'al_color_hsv_to_rgb');
    al_color_rgb_to_hsl := MemoryGetProcAddress(LDLL, 'al_color_rgb_to_hsl');
    al_color_rgb_to_hsv := MemoryGetProcAddress(LDLL, 'al_color_rgb_to_hsv');
    al_color_hsl_to_rgb := MemoryGetProcAddress(LDLL, 'al_color_hsl_to_rgb');
    al_color_name_to_rgb := MemoryGetProcAddress(LDLL, 'al_color_name_to_rgb');
    al_color_rgb_to_name := MemoryGetProcAddress(LDLL, 'al_color_rgb_to_name');
    al_color_cmyk_to_rgb := MemoryGetProcAddress(LDLL, 'al_color_cmyk_to_rgb');
    al_color_rgb_to_cmyk := MemoryGetProcAddress(LDLL, 'al_color_rgb_to_cmyk');
    al_color_yuv_to_rgb := MemoryGetProcAddress(LDLL, 'al_color_yuv_to_rgb');
    al_color_rgb_to_yuv := MemoryGetProcAddress(LDLL, 'al_color_rgb_to_yuv');
    al_color_rgb_to_html := MemoryGetProcAddress(LDLL, 'al_color_rgb_to_html');
    al_color_html_to_rgb := MemoryGetProcAddress(LDLL, 'al_color_html_to_rgb');
    al_color_yuv := MemoryGetProcAddress(LDLL, 'al_color_yuv');
    al_color_cmyk := MemoryGetProcAddress(LDLL, 'al_color_cmyk');
    al_color_hsl := MemoryGetProcAddress(LDLL, 'al_color_hsl');
    al_color_hsv := MemoryGetProcAddress(LDLL, 'al_color_hsv');
    al_color_name := MemoryGetProcAddress(LDLL, 'al_color_name');
    al_color_html := MemoryGetProcAddress(LDLL, 'al_color_html');
    al_color_xyz_to_rgb := MemoryGetProcAddress(LDLL, 'al_color_xyz_to_rgb');
    al_color_rgb_to_xyz := MemoryGetProcAddress(LDLL, 'al_color_rgb_to_xyz');
    al_color_xyz := MemoryGetProcAddress(LDLL, 'al_color_xyz');
    al_color_lab_to_rgb := MemoryGetProcAddress(LDLL, 'al_color_lab_to_rgb');
    al_color_rgb_to_lab := MemoryGetProcAddress(LDLL, 'al_color_rgb_to_lab');
    al_color_lab := MemoryGetProcAddress(LDLL, 'al_color_lab');
    al_color_xyy_to_rgb := MemoryGetProcAddress(LDLL, 'al_color_xyy_to_rgb');
    al_color_rgb_to_xyy := MemoryGetProcAddress(LDLL, 'al_color_rgb_to_xyy');
    al_color_xyy := MemoryGetProcAddress(LDLL, 'al_color_xyy');
    al_color_distance_ciede2000 := MemoryGetProcAddress(LDLL, 'al_color_distance_ciede2000');
    al_color_lch_to_rgb := MemoryGetProcAddress(LDLL, 'al_color_lch_to_rgb');
    al_color_rgb_to_lch := MemoryGetProcAddress(LDLL, 'al_color_rgb_to_lch');
    al_color_lch := MemoryGetProcAddress(LDLL, 'al_color_lch');
    al_is_color_valid := MemoryGetProcAddress(LDLL, 'al_is_color_valid');
    al_register_font_loader := MemoryGetProcAddress(LDLL, 'al_register_font_loader');
    al_load_bitmap_font := MemoryGetProcAddress(LDLL, 'al_load_bitmap_font');
    al_load_bitmap_font_flags := MemoryGetProcAddress(LDLL, 'al_load_bitmap_font_flags');
    al_load_font := MemoryGetProcAddress(LDLL, 'al_load_font');
    al_grab_font_from_bitmap := MemoryGetProcAddress(LDLL, 'al_grab_font_from_bitmap');
    al_create_builtin_font := MemoryGetProcAddress(LDLL, 'al_create_builtin_font');
    al_draw_ustr := MemoryGetProcAddress(LDLL, 'al_draw_ustr');
    al_draw_text := MemoryGetProcAddress(LDLL, 'al_draw_text');
    al_draw_justified_text := MemoryGetProcAddress(LDLL, 'al_draw_justified_text');
    al_draw_justified_ustr := MemoryGetProcAddress(LDLL, 'al_draw_justified_ustr');
    al_draw_textf := MemoryGetProcAddress(LDLL, 'al_draw_textf');
    al_draw_justified_textf := MemoryGetProcAddress(LDLL, 'al_draw_justified_textf');
    al_get_text_width := MemoryGetProcAddress(LDLL, 'al_get_text_width');
    al_get_ustr_width := MemoryGetProcAddress(LDLL, 'al_get_ustr_width');
    al_get_font_line_height := MemoryGetProcAddress(LDLL, 'al_get_font_line_height');
    al_get_font_ascent := MemoryGetProcAddress(LDLL, 'al_get_font_ascent');
    al_get_font_descent := MemoryGetProcAddress(LDLL, 'al_get_font_descent');
    al_destroy_font := MemoryGetProcAddress(LDLL, 'al_destroy_font');
    al_get_ustr_dimensions := MemoryGetProcAddress(LDLL, 'al_get_ustr_dimensions');
    al_get_text_dimensions := MemoryGetProcAddress(LDLL, 'al_get_text_dimensions');
    al_init_font_addon := MemoryGetProcAddress(LDLL, 'al_init_font_addon');
    al_is_font_addon_initialized := MemoryGetProcAddress(LDLL, 'al_is_font_addon_initialized');
    al_shutdown_font_addon := MemoryGetProcAddress(LDLL, 'al_shutdown_font_addon');
    al_get_allegro_font_version := MemoryGetProcAddress(LDLL, 'al_get_allegro_font_version');
    al_get_font_ranges := MemoryGetProcAddress(LDLL, 'al_get_font_ranges');
    al_draw_glyph := MemoryGetProcAddress(LDLL, 'al_draw_glyph');
    al_get_glyph_width := MemoryGetProcAddress(LDLL, 'al_get_glyph_width');
    al_get_glyph_dimensions := MemoryGetProcAddress(LDLL, 'al_get_glyph_dimensions');
    al_get_glyph_advance := MemoryGetProcAddress(LDLL, 'al_get_glyph_advance');
    al_get_glyph := MemoryGetProcAddress(LDLL, 'al_get_glyph');
    al_draw_multiline_text := MemoryGetProcAddress(LDLL, 'al_draw_multiline_text');
    al_draw_multiline_textf := MemoryGetProcAddress(LDLL, 'al_draw_multiline_textf');
    al_draw_multiline_ustr := MemoryGetProcAddress(LDLL, 'al_draw_multiline_ustr');
    al_do_multiline_text := MemoryGetProcAddress(LDLL, 'al_do_multiline_text');
    al_do_multiline_ustr := MemoryGetProcAddress(LDLL, 'al_do_multiline_ustr');
    al_set_fallback_font := MemoryGetProcAddress(LDLL, 'al_set_fallback_font');
    al_get_fallback_font := MemoryGetProcAddress(LDLL, 'al_get_fallback_font');
    al_init_image_addon := MemoryGetProcAddress(LDLL, 'al_init_image_addon');
    al_is_image_addon_initialized := MemoryGetProcAddress(LDLL, 'al_is_image_addon_initialized');
    al_shutdown_image_addon := MemoryGetProcAddress(LDLL, 'al_shutdown_image_addon');
    al_get_allegro_image_version := MemoryGetProcAddress(LDLL, 'al_get_allegro_image_version');
    al_open_memfile := MemoryGetProcAddress(LDLL, 'al_open_memfile');
    al_get_allegro_memfile_version := MemoryGetProcAddress(LDLL, 'al_get_allegro_memfile_version');
    al_init_native_dialog_addon := MemoryGetProcAddress(LDLL, 'al_init_native_dialog_addon');
    al_is_native_dialog_addon_initialized := MemoryGetProcAddress(LDLL, 'al_is_native_dialog_addon_initialized');
    al_shutdown_native_dialog_addon := MemoryGetProcAddress(LDLL, 'al_shutdown_native_dialog_addon');
    al_create_native_file_dialog := MemoryGetProcAddress(LDLL, 'al_create_native_file_dialog');
    al_show_native_file_dialog := MemoryGetProcAddress(LDLL, 'al_show_native_file_dialog');
    al_get_native_file_dialog_count := MemoryGetProcAddress(LDLL, 'al_get_native_file_dialog_count');
    al_get_native_file_dialog_path := MemoryGetProcAddress(LDLL, 'al_get_native_file_dialog_path');
    al_destroy_native_file_dialog := MemoryGetProcAddress(LDLL, 'al_destroy_native_file_dialog');
    al_show_native_message_box := MemoryGetProcAddress(LDLL, 'al_show_native_message_box');
    al_open_native_text_log := MemoryGetProcAddress(LDLL, 'al_open_native_text_log');
    al_close_native_text_log := MemoryGetProcAddress(LDLL, 'al_close_native_text_log');
    al_append_native_text_log := MemoryGetProcAddress(LDLL, 'al_append_native_text_log');
    al_get_native_text_log_event_source := MemoryGetProcAddress(LDLL, 'al_get_native_text_log_event_source');
    al_create_menu := MemoryGetProcAddress(LDLL, 'al_create_menu');
    al_create_popup_menu := MemoryGetProcAddress(LDLL, 'al_create_popup_menu');
    al_build_menu := MemoryGetProcAddress(LDLL, 'al_build_menu');
    al_append_menu_item := MemoryGetProcAddress(LDLL, 'al_append_menu_item');
    al_insert_menu_item := MemoryGetProcAddress(LDLL, 'al_insert_menu_item');
    al_remove_menu_item := MemoryGetProcAddress(LDLL, 'al_remove_menu_item');
    al_clone_menu := MemoryGetProcAddress(LDLL, 'al_clone_menu');
    al_clone_menu_for_popup := MemoryGetProcAddress(LDLL, 'al_clone_menu_for_popup');
    al_destroy_menu := MemoryGetProcAddress(LDLL, 'al_destroy_menu');
    al_get_menu_item_caption := MemoryGetProcAddress(LDLL, 'al_get_menu_item_caption');
    al_set_menu_item_caption := MemoryGetProcAddress(LDLL, 'al_set_menu_item_caption');
    al_get_menu_item_flags := MemoryGetProcAddress(LDLL, 'al_get_menu_item_flags');
    al_set_menu_item_flags := MemoryGetProcAddress(LDLL, 'al_set_menu_item_flags');
    al_get_menu_item_icon := MemoryGetProcAddress(LDLL, 'al_get_menu_item_icon');
    al_set_menu_item_icon := MemoryGetProcAddress(LDLL, 'al_set_menu_item_icon');
    al_toggle_menu_item_flags := MemoryGetProcAddress(LDLL, 'al_toggle_menu_item_flags');
    al_find_menu := MemoryGetProcAddress(LDLL, 'al_find_menu');
    al_find_menu_item := MemoryGetProcAddress(LDLL, 'al_find_menu_item');
    al_get_default_menu_event_source := MemoryGetProcAddress(LDLL, 'al_get_default_menu_event_source');
    al_enable_menu_event_source := MemoryGetProcAddress(LDLL, 'al_enable_menu_event_source');
    al_disable_menu_event_source := MemoryGetProcAddress(LDLL, 'al_disable_menu_event_source');
    al_get_display_menu := MemoryGetProcAddress(LDLL, 'al_get_display_menu');
    al_set_display_menu := MemoryGetProcAddress(LDLL, 'al_set_display_menu');
    al_popup_menu := MemoryGetProcAddress(LDLL, 'al_popup_menu');
    al_remove_display_menu := MemoryGetProcAddress(LDLL, 'al_remove_display_menu');
    al_get_allegro_native_dialog_version := MemoryGetProcAddress(LDLL, 'al_get_allegro_native_dialog_version');
    al_get_allegro_primitives_version := MemoryGetProcAddress(LDLL, 'al_get_allegro_primitives_version');
    al_init_primitives_addon := MemoryGetProcAddress(LDLL, 'al_init_primitives_addon');
    al_is_primitives_addon_initialized := MemoryGetProcAddress(LDLL, 'al_is_primitives_addon_initialized');
    al_shutdown_primitives_addon := MemoryGetProcAddress(LDLL, 'al_shutdown_primitives_addon');
    al_draw_prim := MemoryGetProcAddress(LDLL, 'al_draw_prim');
    al_draw_indexed_prim := MemoryGetProcAddress(LDLL, 'al_draw_indexed_prim');
    al_draw_vertex_buffer := MemoryGetProcAddress(LDLL, 'al_draw_vertex_buffer');
    al_draw_indexed_buffer := MemoryGetProcAddress(LDLL, 'al_draw_indexed_buffer');
    al_create_vertex_decl := MemoryGetProcAddress(LDLL, 'al_create_vertex_decl');
    al_destroy_vertex_decl := MemoryGetProcAddress(LDLL, 'al_destroy_vertex_decl');
    al_create_vertex_buffer := MemoryGetProcAddress(LDLL, 'al_create_vertex_buffer');
    al_destroy_vertex_buffer := MemoryGetProcAddress(LDLL, 'al_destroy_vertex_buffer');
    al_lock_vertex_buffer := MemoryGetProcAddress(LDLL, 'al_lock_vertex_buffer');
    al_unlock_vertex_buffer := MemoryGetProcAddress(LDLL, 'al_unlock_vertex_buffer');
    al_get_vertex_buffer_size := MemoryGetProcAddress(LDLL, 'al_get_vertex_buffer_size');
    al_create_index_buffer := MemoryGetProcAddress(LDLL, 'al_create_index_buffer');
    al_destroy_index_buffer := MemoryGetProcAddress(LDLL, 'al_destroy_index_buffer');
    al_lock_index_buffer := MemoryGetProcAddress(LDLL, 'al_lock_index_buffer');
    al_unlock_index_buffer := MemoryGetProcAddress(LDLL, 'al_unlock_index_buffer');
    al_get_index_buffer_size := MemoryGetProcAddress(LDLL, 'al_get_index_buffer_size');
    al_triangulate_polygon := MemoryGetProcAddress(LDLL, 'al_triangulate_polygon');
    al_draw_soft_triangle := MemoryGetProcAddress(LDLL, 'al_draw_soft_triangle');
    al_draw_soft_line := MemoryGetProcAddress(LDLL, 'al_draw_soft_line');
    al_draw_line := MemoryGetProcAddress(LDLL, 'al_draw_line');
    al_draw_triangle := MemoryGetProcAddress(LDLL, 'al_draw_triangle');
    al_draw_rectangle := MemoryGetProcAddress(LDLL, 'al_draw_rectangle');
    al_draw_rounded_rectangle := MemoryGetProcAddress(LDLL, 'al_draw_rounded_rectangle');
    al_calculate_arc := MemoryGetProcAddress(LDLL, 'al_calculate_arc');
    al_draw_circle := MemoryGetProcAddress(LDLL, 'al_draw_circle');
    al_draw_ellipse := MemoryGetProcAddress(LDLL, 'al_draw_ellipse');
    al_draw_arc := MemoryGetProcAddress(LDLL, 'al_draw_arc');
    al_draw_elliptical_arc := MemoryGetProcAddress(LDLL, 'al_draw_elliptical_arc');
    al_draw_pieslice := MemoryGetProcAddress(LDLL, 'al_draw_pieslice');
    al_calculate_spline := MemoryGetProcAddress(LDLL, 'al_calculate_spline');
    al_draw_spline := MemoryGetProcAddress(LDLL, 'al_draw_spline');
    al_calculate_ribbon := MemoryGetProcAddress(LDLL, 'al_calculate_ribbon');
    al_draw_ribbon := MemoryGetProcAddress(LDLL, 'al_draw_ribbon');
    al_draw_filled_triangle := MemoryGetProcAddress(LDLL, 'al_draw_filled_triangle');
    al_draw_filled_rectangle := MemoryGetProcAddress(LDLL, 'al_draw_filled_rectangle');
    al_draw_filled_ellipse := MemoryGetProcAddress(LDLL, 'al_draw_filled_ellipse');
    al_draw_filled_circle := MemoryGetProcAddress(LDLL, 'al_draw_filled_circle');
    al_draw_filled_pieslice := MemoryGetProcAddress(LDLL, 'al_draw_filled_pieslice');
    al_draw_filled_rounded_rectangle := MemoryGetProcAddress(LDLL, 'al_draw_filled_rounded_rectangle');
    al_draw_polyline := MemoryGetProcAddress(LDLL, 'al_draw_polyline');
    al_draw_polygon := MemoryGetProcAddress(LDLL, 'al_draw_polygon');
    al_draw_filled_polygon := MemoryGetProcAddress(LDLL, 'al_draw_filled_polygon');
    al_draw_filled_polygon_with_holes := MemoryGetProcAddress(LDLL, 'al_draw_filled_polygon_with_holes');
    al_load_ttf_font := MemoryGetProcAddress(LDLL, 'al_load_ttf_font');
    al_load_ttf_font_f := MemoryGetProcAddress(LDLL, 'al_load_ttf_font_f');
    al_load_ttf_font_stretch := MemoryGetProcAddress(LDLL, 'al_load_ttf_font_stretch');
    al_load_ttf_font_stretch_f := MemoryGetProcAddress(LDLL, 'al_load_ttf_font_stretch_f');
    al_init_ttf_addon := MemoryGetProcAddress(LDLL, 'al_init_ttf_addon');
    al_is_ttf_addon_initialized := MemoryGetProcAddress(LDLL, 'al_is_ttf_addon_initialized');
    al_shutdown_ttf_addon := MemoryGetProcAddress(LDLL, 'al_shutdown_ttf_addon');
    al_get_allegro_ttf_version := MemoryGetProcAddress(LDLL, 'al_get_allegro_ttf_version');
    al_open_video := MemoryGetProcAddress(LDLL, 'al_open_video');
    al_close_video := MemoryGetProcAddress(LDLL, 'al_close_video');
    al_start_video := MemoryGetProcAddress(LDLL, 'al_start_video');
    al_start_video_with_voice := MemoryGetProcAddress(LDLL, 'al_start_video_with_voice');
    al_get_video_event_source := MemoryGetProcAddress(LDLL, 'al_get_video_event_source');
    al_set_video_playing := MemoryGetProcAddress(LDLL, 'al_set_video_playing');
    al_is_video_playing := MemoryGetProcAddress(LDLL, 'al_is_video_playing');
    al_get_video_audio_rate := MemoryGetProcAddress(LDLL, 'al_get_video_audio_rate');
    al_get_video_fps := MemoryGetProcAddress(LDLL, 'al_get_video_fps');
    al_get_video_scaled_width := MemoryGetProcAddress(LDLL, 'al_get_video_scaled_width');
    al_get_video_scaled_height := MemoryGetProcAddress(LDLL, 'al_get_video_scaled_height');
    al_get_video_frame := MemoryGetProcAddress(LDLL, 'al_get_video_frame');
    al_get_video_position := MemoryGetProcAddress(LDLL, 'al_get_video_position');
    al_seek_video := MemoryGetProcAddress(LDLL, 'al_seek_video');
    al_init_video_addon := MemoryGetProcAddress(LDLL, 'al_init_video_addon');
    al_is_video_addon_initialized := MemoryGetProcAddress(LDLL, 'al_is_video_addon_initialized');
    al_shutdown_video_addon := MemoryGetProcAddress(LDLL, 'al_shutdown_video_addon');
    al_get_allegro_video_version := MemoryGetProcAddress(LDLL, 'al_get_allegro_video_version');
    al_identify_video_f := MemoryGetProcAddress(LDLL, 'al_identify_video_f');
    al_identify_video := MemoryGetProcAddress(LDLL, 'al_identify_video');
    al_get_win_window_handle := MemoryGetProcAddress(LDLL, 'al_get_win_window_handle');
    al_win_add_window_callback := MemoryGetProcAddress(LDLL, 'al_win_add_window_callback');
    al_win_remove_window_callback := MemoryGetProcAddress(LDLL, 'al_win_remove_window_callback');
    al_set_physfs_file_interface := MemoryGetProcAddress(LDLL, 'al_set_physfs_file_interface');
    al_get_allegro_physfs_version := MemoryGetProcAddress(LDLL, 'al_get_allegro_physfs_version');
    _WinMain := MemoryGetProcAddress(LDLL, '_WinMain');

    PHYSFS_init := MemoryGetProcAddress(LDLL, 'PHYSFS_init');
    PHYSFS_deinit := MemoryGetProcAddress(LDLL, 'PHYSFS_deinit');
    PHYSFS_mount := MemoryGetProcAddress(LDLL, 'PHYSFS_mount');
    PHYSFS_unmount := MemoryGetProcAddress(LDLL, 'PHYSFS_unmount');

  finally
    FreeAndNil(LStream);
  end;
end;

procedure UnloadDLL;
begin
  MemoryFreeLibrary(LDLL);
end;

initialization
  LoadDLL;

finalization
  UnloadDLL;
{$ENDREGION}

end.